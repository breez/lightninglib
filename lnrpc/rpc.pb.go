// Code generated by protoc-gen-go. DO NOT EDIT.
// source: rpc.proto

/*
Package lnrpc is a generated protocol buffer package.

It is generated from these files:
	rpc.proto

It has these top-level messages:
	GenSeedRequest
	GenSeedResponse
	InitWalletRequest
	InitWalletResponse
	UnlockWalletRequest
	UnlockWalletResponse
	ChangePasswordRequest
	ChangePasswordResponse
	Transaction
	GetTransactionsRequest
	TransactionDetails
	FeeLimit
	SendRequest
	SendResponse
	SendToRouteRequest
	ChannelPoint
	LightningAddress
	SendManyRequest
	SendManyResponse
	SendCoinsRequest
	SendCoinsResponse
	NewAddressRequest
	NewWitnessAddressRequest
	NewAddressResponse
	SignMessageRequest
	SignMessageResponse
	VerifyMessageRequest
	VerifyMessageResponse
	ConnectPeerRequest
	ConnectPeerResponse
	DisconnectPeerRequest
	DisconnectPeerResponse
	HTLC
	Channel
	ListChannelsRequest
	ListChannelsResponse
	ChannelCloseSummary
	ClosedChannelsRequest
	ClosedChannelsResponse
	Peer
	ListPeersRequest
	ListPeersResponse
	GetInfoRequest
	GetInfoResponse
	ConfirmationUpdate
	ChannelOpenUpdate
	ChannelCloseUpdate
	CloseChannelRequest
	CloseStatusUpdate
	PendingUpdate
	OpenChannelRequest
	OpenStatusUpdate
	PendingHTLC
	PendingChannelsRequest
	PendingChannelsResponse
	WalletBalanceRequest
	WalletBalanceResponse
	ChannelBalanceRequest
	ChannelBalanceResponse
	QueryRoutesRequest
	QueryRoutesResponse
	Hop
	Route
	NodeInfoRequest
	NodeInfo
	LightningNode
	NodeAddress
	RoutingPolicy
	ChannelEdge
	ChannelGraphRequest
	ChannelGraph
	ChanInfoRequest
	NetworkInfoRequest
	NetworkInfo
	StopRequest
	StopResponse
	GraphTopologySubscription
	GraphTopologyUpdate
	NodeUpdate
	ChannelEdgeUpdate
	ClosedChannelUpdate
	HopHint
	RouteHint
	Invoice
	AddInvoiceResponse
	PaymentHash
	ListInvoiceRequest
	ListInvoiceResponse
	InvoiceSubscription
	Payment
	ListPaymentsRequest
	ListPaymentsResponse
	DeleteAllPaymentsRequest
	DeleteAllPaymentsResponse
	DebugLevelRequest
	DebugLevelResponse
	PayReqString
	PayReq
	FeeReportRequest
	ChannelFeeReport
	FeeReportResponse
	PolicyUpdateRequest
	PolicyUpdateResponse
	ForwardingHistoryRequest
	ForwardingEvent
	ForwardingHistoryResponse
*/
package lnrpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type NewAddressRequest_AddressType int32

const (
	NewAddressRequest_WITNESS_PUBKEY_HASH NewAddressRequest_AddressType = 0
	NewAddressRequest_NESTED_PUBKEY_HASH  NewAddressRequest_AddressType = 1
)

var NewAddressRequest_AddressType_name = map[int32]string{
	0: "WITNESS_PUBKEY_HASH",
	1: "NESTED_PUBKEY_HASH",
}
var NewAddressRequest_AddressType_value = map[string]int32{
	"WITNESS_PUBKEY_HASH": 0,
	"NESTED_PUBKEY_HASH":  1,
}

func (x NewAddressRequest_AddressType) String() string {
	return proto.EnumName(NewAddressRequest_AddressType_name, int32(x))
}
func (NewAddressRequest_AddressType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{21, 0}
}

type ChannelCloseSummary_ClosureType int32

const (
	ChannelCloseSummary_COOPERATIVE_CLOSE  ChannelCloseSummary_ClosureType = 0
	ChannelCloseSummary_LOCAL_FORCE_CLOSE  ChannelCloseSummary_ClosureType = 1
	ChannelCloseSummary_REMOTE_FORCE_CLOSE ChannelCloseSummary_ClosureType = 2
	ChannelCloseSummary_BREACH_CLOSE       ChannelCloseSummary_ClosureType = 3
	ChannelCloseSummary_FUNDING_CANCELED   ChannelCloseSummary_ClosureType = 4
)

var ChannelCloseSummary_ClosureType_name = map[int32]string{
	0: "COOPERATIVE_CLOSE",
	1: "LOCAL_FORCE_CLOSE",
	2: "REMOTE_FORCE_CLOSE",
	3: "BREACH_CLOSE",
	4: "FUNDING_CANCELED",
}
var ChannelCloseSummary_ClosureType_value = map[string]int32{
	"COOPERATIVE_CLOSE":  0,
	"LOCAL_FORCE_CLOSE":  1,
	"REMOTE_FORCE_CLOSE": 2,
	"BREACH_CLOSE":       3,
	"FUNDING_CANCELED":   4,
}

func (x ChannelCloseSummary_ClosureType) String() string {
	return proto.EnumName(ChannelCloseSummary_ClosureType_name, int32(x))
}
func (ChannelCloseSummary_ClosureType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{36, 0}
}

type GenSeedRequest struct {
	// *
	// aezeed_passphrase is an optional user provided passphrase that will be used
	// to encrypt the generated aezeed cipher seed.
	AezeedPassphrase []byte `protobuf:"bytes,1,opt,name=aezeed_passphrase,json=aezeedPassphrase,proto3" json:"aezeed_passphrase,omitempty"`
	// *
	// seed_entropy is an optional 16-bytes generated via CSPRNG. If not
	// specified, then a fresh set of randomness will be used to create the seed.
	SeedEntropy []byte `protobuf:"bytes,2,opt,name=seed_entropy,json=seedEntropy,proto3" json:"seed_entropy,omitempty"`
}

func (m *GenSeedRequest) Reset()                    { *m = GenSeedRequest{} }
func (m *GenSeedRequest) String() string            { return proto.CompactTextString(m) }
func (*GenSeedRequest) ProtoMessage()               {}
func (*GenSeedRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *GenSeedRequest) GetAezeedPassphrase() []byte {
	if m != nil {
		return m.AezeedPassphrase
	}
	return nil
}

func (m *GenSeedRequest) GetSeedEntropy() []byte {
	if m != nil {
		return m.SeedEntropy
	}
	return nil
}

type GenSeedResponse struct {
	// *
	// cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
	// cipher seed obtained by the user. This field is optional, as if not
	// provided, then the daemon will generate a new cipher seed for the user.
	// Otherwise, then the daemon will attempt to recover the wallet state linked
	// to this cipher seed.
	CipherSeedMnemonic []string `protobuf:"bytes,1,rep,name=cipher_seed_mnemonic,json=cipherSeedMnemonic" json:"cipher_seed_mnemonic,omitempty"`
	// *
	// enciphered_seed are the raw aezeed cipher seed bytes. This is the raw
	// cipher text before run through our mnemonic encoding scheme.
	EncipheredSeed []byte `protobuf:"bytes,2,opt,name=enciphered_seed,json=encipheredSeed,proto3" json:"enciphered_seed,omitempty"`
}

func (m *GenSeedResponse) Reset()                    { *m = GenSeedResponse{} }
func (m *GenSeedResponse) String() string            { return proto.CompactTextString(m) }
func (*GenSeedResponse) ProtoMessage()               {}
func (*GenSeedResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *GenSeedResponse) GetCipherSeedMnemonic() []string {
	if m != nil {
		return m.CipherSeedMnemonic
	}
	return nil
}

func (m *GenSeedResponse) GetEncipheredSeed() []byte {
	if m != nil {
		return m.EncipheredSeed
	}
	return nil
}

type InitWalletRequest struct {
	// *
	// wallet_password is the passphrase that should be used to encrypt the
	// wallet. This MUST be at least 8 chars in length. After creation, this
	// password is required to unlock the daemon.
	WalletPassword []byte `protobuf:"bytes,1,opt,name=wallet_password,json=walletPassword,proto3" json:"wallet_password,omitempty"`
	// *
	// cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
	// cipher seed obtained by the user. This may have been generated by the
	// GenSeed method, or be an existing seed.
	CipherSeedMnemonic []string `protobuf:"bytes,2,rep,name=cipher_seed_mnemonic,json=cipherSeedMnemonic" json:"cipher_seed_mnemonic,omitempty"`
	// *
	// aezeed_passphrase is an optional user provided passphrase that will be used
	// to encrypt the generated aezeed cipher seed.
	AezeedPassphrase []byte `protobuf:"bytes,3,opt,name=aezeed_passphrase,json=aezeedPassphrase,proto3" json:"aezeed_passphrase,omitempty"`
	// *
	// recovery_window is an optional argument specifying the address lookahead
	// when restoring a wallet seed. The recovery window applies to each
	// invdividual branch of the BIP44 derivation paths. Supplying a recovery
	// window of zero indicates that no addresses should be recovered, such after
	// the first initialization of the wallet.
	RecoveryWindow int32 `protobuf:"varint,4,opt,name=recovery_window,json=recoveryWindow" json:"recovery_window,omitempty"`
}

func (m *InitWalletRequest) Reset()                    { *m = InitWalletRequest{} }
func (m *InitWalletRequest) String() string            { return proto.CompactTextString(m) }
func (*InitWalletRequest) ProtoMessage()               {}
func (*InitWalletRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *InitWalletRequest) GetWalletPassword() []byte {
	if m != nil {
		return m.WalletPassword
	}
	return nil
}

func (m *InitWalletRequest) GetCipherSeedMnemonic() []string {
	if m != nil {
		return m.CipherSeedMnemonic
	}
	return nil
}

func (m *InitWalletRequest) GetAezeedPassphrase() []byte {
	if m != nil {
		return m.AezeedPassphrase
	}
	return nil
}

func (m *InitWalletRequest) GetRecoveryWindow() int32 {
	if m != nil {
		return m.RecoveryWindow
	}
	return 0
}

type InitWalletResponse struct {
}

func (m *InitWalletResponse) Reset()                    { *m = InitWalletResponse{} }
func (m *InitWalletResponse) String() string            { return proto.CompactTextString(m) }
func (*InitWalletResponse) ProtoMessage()               {}
func (*InitWalletResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type UnlockWalletRequest struct {
	// *
	// wallet_password should be the current valid passphrase for the daemon. This
	// will be required to decrypt on-disk material that the daemon requires to
	// function properly.
	WalletPassword []byte `protobuf:"bytes,1,opt,name=wallet_password,json=walletPassword,proto3" json:"wallet_password,omitempty"`
	// *
	// recovery_window is an optional argument specifying the address lookahead
	// when restoring a wallet seed. The recovery window applies to each
	// invdividual branch of the BIP44 derivation paths. Supplying a recovery
	// window of zero indicates that no addresses should be recovered, such after
	// the first initialization of the wallet.
	RecoveryWindow int32 `protobuf:"varint,2,opt,name=recovery_window,json=recoveryWindow" json:"recovery_window,omitempty"`
}

func (m *UnlockWalletRequest) Reset()                    { *m = UnlockWalletRequest{} }
func (m *UnlockWalletRequest) String() string            { return proto.CompactTextString(m) }
func (*UnlockWalletRequest) ProtoMessage()               {}
func (*UnlockWalletRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *UnlockWalletRequest) GetWalletPassword() []byte {
	if m != nil {
		return m.WalletPassword
	}
	return nil
}

func (m *UnlockWalletRequest) GetRecoveryWindow() int32 {
	if m != nil {
		return m.RecoveryWindow
	}
	return 0
}

type UnlockWalletResponse struct {
}

func (m *UnlockWalletResponse) Reset()                    { *m = UnlockWalletResponse{} }
func (m *UnlockWalletResponse) String() string            { return proto.CompactTextString(m) }
func (*UnlockWalletResponse) ProtoMessage()               {}
func (*UnlockWalletResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type ChangePasswordRequest struct {
	// *
	// current_password should be the current valid passphrase used to unlock the
	// daemon.
	CurrentPassword []byte `protobuf:"bytes,1,opt,name=current_password,json=currentPassword,proto3" json:"current_password,omitempty"`
	// *
	// new_password should be the new passphrase that will be needed to unlock the
	// daemon.
	NewPassword []byte `protobuf:"bytes,2,opt,name=new_password,json=newPassword,proto3" json:"new_password,omitempty"`
}

func (m *ChangePasswordRequest) Reset()                    { *m = ChangePasswordRequest{} }
func (m *ChangePasswordRequest) String() string            { return proto.CompactTextString(m) }
func (*ChangePasswordRequest) ProtoMessage()               {}
func (*ChangePasswordRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ChangePasswordRequest) GetCurrentPassword() []byte {
	if m != nil {
		return m.CurrentPassword
	}
	return nil
}

func (m *ChangePasswordRequest) GetNewPassword() []byte {
	if m != nil {
		return m.NewPassword
	}
	return nil
}

type ChangePasswordResponse struct {
}

func (m *ChangePasswordResponse) Reset()                    { *m = ChangePasswordResponse{} }
func (m *ChangePasswordResponse) String() string            { return proto.CompactTextString(m) }
func (*ChangePasswordResponse) ProtoMessage()               {}
func (*ChangePasswordResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type Transaction struct {
	// / The transaction hash
	TxHash string `protobuf:"bytes,1,opt,name=tx_hash" json:"tx_hash,omitempty"`
	// / The transaction ammount, denominated in satoshis
	Amount int64 `protobuf:"varint,2,opt,name=amount" json:"amount,omitempty"`
	// / The number of confirmations
	NumConfirmations int32 `protobuf:"varint,3,opt,name=num_confirmations" json:"num_confirmations,omitempty"`
	// / The hash of the block this transaction was included in
	BlockHash string `protobuf:"bytes,4,opt,name=block_hash" json:"block_hash,omitempty"`
	// / The height of the block this transaction was included in
	BlockHeight int32 `protobuf:"varint,5,opt,name=block_height" json:"block_height,omitempty"`
	// / Timestamp of this transaction
	TimeStamp int64 `protobuf:"varint,6,opt,name=time_stamp" json:"time_stamp,omitempty"`
	// / Fees paid for this transaction
	TotalFees int64 `protobuf:"varint,7,opt,name=total_fees" json:"total_fees,omitempty"`
	// / Addresses that received funds for this transaction
	DestAddresses []string `protobuf:"bytes,8,rep,name=dest_addresses" json:"dest_addresses,omitempty"`
}

func (m *Transaction) Reset()                    { *m = Transaction{} }
func (m *Transaction) String() string            { return proto.CompactTextString(m) }
func (*Transaction) ProtoMessage()               {}
func (*Transaction) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *Transaction) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

func (m *Transaction) GetAmount() int64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *Transaction) GetNumConfirmations() int32 {
	if m != nil {
		return m.NumConfirmations
	}
	return 0
}

func (m *Transaction) GetBlockHash() string {
	if m != nil {
		return m.BlockHash
	}
	return ""
}

func (m *Transaction) GetBlockHeight() int32 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *Transaction) GetTimeStamp() int64 {
	if m != nil {
		return m.TimeStamp
	}
	return 0
}

func (m *Transaction) GetTotalFees() int64 {
	if m != nil {
		return m.TotalFees
	}
	return 0
}

func (m *Transaction) GetDestAddresses() []string {
	if m != nil {
		return m.DestAddresses
	}
	return nil
}

type GetTransactionsRequest struct {
}

func (m *GetTransactionsRequest) Reset()                    { *m = GetTransactionsRequest{} }
func (m *GetTransactionsRequest) String() string            { return proto.CompactTextString(m) }
func (*GetTransactionsRequest) ProtoMessage()               {}
func (*GetTransactionsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type TransactionDetails struct {
	// / The list of transactions relevant to the wallet.
	Transactions []*Transaction `protobuf:"bytes,1,rep,name=transactions" json:"transactions,omitempty"`
}

func (m *TransactionDetails) Reset()                    { *m = TransactionDetails{} }
func (m *TransactionDetails) String() string            { return proto.CompactTextString(m) }
func (*TransactionDetails) ProtoMessage()               {}
func (*TransactionDetails) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *TransactionDetails) GetTransactions() []*Transaction {
	if m != nil {
		return m.Transactions
	}
	return nil
}

type FeeLimit struct {
	// Types that are valid to be assigned to Limit:
	//	*FeeLimit_Fixed
	//	*FeeLimit_Percent
	Limit isFeeLimit_Limit `protobuf_oneof:"limit"`
}

func (m *FeeLimit) Reset()                    { *m = FeeLimit{} }
func (m *FeeLimit) String() string            { return proto.CompactTextString(m) }
func (*FeeLimit) ProtoMessage()               {}
func (*FeeLimit) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

type isFeeLimit_Limit interface{ isFeeLimit_Limit() }

type FeeLimit_Fixed struct {
	Fixed int64 `protobuf:"varint,1,opt,name=fixed,oneof"`
}
type FeeLimit_Percent struct {
	Percent int64 `protobuf:"varint,2,opt,name=percent,oneof"`
}

func (*FeeLimit_Fixed) isFeeLimit_Limit()   {}
func (*FeeLimit_Percent) isFeeLimit_Limit() {}

func (m *FeeLimit) GetLimit() isFeeLimit_Limit {
	if m != nil {
		return m.Limit
	}
	return nil
}

func (m *FeeLimit) GetFixed() int64 {
	if x, ok := m.GetLimit().(*FeeLimit_Fixed); ok {
		return x.Fixed
	}
	return 0
}

func (m *FeeLimit) GetPercent() int64 {
	if x, ok := m.GetLimit().(*FeeLimit_Percent); ok {
		return x.Percent
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FeeLimit) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FeeLimit_OneofMarshaler, _FeeLimit_OneofUnmarshaler, _FeeLimit_OneofSizer, []interface{}{
		(*FeeLimit_Fixed)(nil),
		(*FeeLimit_Percent)(nil),
	}
}

func _FeeLimit_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FeeLimit)
	// limit
	switch x := m.Limit.(type) {
	case *FeeLimit_Fixed:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Fixed))
	case *FeeLimit_Percent:
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Percent))
	case nil:
	default:
		return fmt.Errorf("FeeLimit.Limit has unexpected type %T", x)
	}
	return nil
}

func _FeeLimit_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FeeLimit)
	switch tag {
	case 1: // limit.fixed
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Limit = &FeeLimit_Fixed{int64(x)}
		return true, err
	case 2: // limit.percent
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Limit = &FeeLimit_Percent{int64(x)}
		return true, err
	default:
		return false, nil
	}
}

func _FeeLimit_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FeeLimit)
	// limit
	switch x := m.Limit.(type) {
	case *FeeLimit_Fixed:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Fixed))
	case *FeeLimit_Percent:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Percent))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type SendRequest struct {
	// / The identity pubkey of the payment recipient
	Dest []byte `protobuf:"bytes,1,opt,name=dest,proto3" json:"dest,omitempty"`
	// / The hex-encoded identity pubkey of the payment recipient
	DestString string `protobuf:"bytes,2,opt,name=dest_string,json=destString" json:"dest_string,omitempty"`
	// / Number of satoshis to send.
	Amt int64 `protobuf:"varint,3,opt,name=amt" json:"amt,omitempty"`
	// / The hash to use within the payment's HTLC
	PaymentHash []byte `protobuf:"bytes,4,opt,name=payment_hash,json=paymentHash,proto3" json:"payment_hash,omitempty"`
	// / The hex-encoded hash to use within the payment's HTLC
	PaymentHashString string `protobuf:"bytes,5,opt,name=payment_hash_string,json=paymentHashString" json:"payment_hash_string,omitempty"`
	// *
	// A bare-bones invoice for a payment within the Lightning Network.  With the
	// details of the invoice, the sender has all the data necessary to send a
	// payment to the recipient.
	PaymentRequest string `protobuf:"bytes,6,opt,name=payment_request,json=paymentRequest" json:"payment_request,omitempty"`
	// *
	// The CLTV delta from the current height that should be used to set the
	// timelock for the final hop.
	FinalCltvDelta int32 `protobuf:"varint,7,opt,name=final_cltv_delta,json=finalCltvDelta" json:"final_cltv_delta,omitempty"`
	// *
	// The maximum number of satoshis that will be paid as a fee of the payment.
	// This value can be represented either as a percentage of the amount being
	// sent, or as a fixed amount of the maximum fee the user is willing the pay to
	// send the payment.
	FeeLimit *FeeLimit `protobuf:"bytes,8,opt,name=fee_limit,json=feeLimit" json:"fee_limit,omitempty"`
}

func (m *SendRequest) Reset()                    { *m = SendRequest{} }
func (m *SendRequest) String() string            { return proto.CompactTextString(m) }
func (*SendRequest) ProtoMessage()               {}
func (*SendRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *SendRequest) GetDest() []byte {
	if m != nil {
		return m.Dest
	}
	return nil
}

func (m *SendRequest) GetDestString() string {
	if m != nil {
		return m.DestString
	}
	return ""
}

func (m *SendRequest) GetAmt() int64 {
	if m != nil {
		return m.Amt
	}
	return 0
}

func (m *SendRequest) GetPaymentHash() []byte {
	if m != nil {
		return m.PaymentHash
	}
	return nil
}

func (m *SendRequest) GetPaymentHashString() string {
	if m != nil {
		return m.PaymentHashString
	}
	return ""
}

func (m *SendRequest) GetPaymentRequest() string {
	if m != nil {
		return m.PaymentRequest
	}
	return ""
}

func (m *SendRequest) GetFinalCltvDelta() int32 {
	if m != nil {
		return m.FinalCltvDelta
	}
	return 0
}

func (m *SendRequest) GetFeeLimit() *FeeLimit {
	if m != nil {
		return m.FeeLimit
	}
	return nil
}

type SendResponse struct {
	PaymentError    string `protobuf:"bytes,1,opt,name=payment_error" json:"payment_error,omitempty"`
	PaymentPreimage []byte `protobuf:"bytes,2,opt,name=payment_preimage,proto3" json:"payment_preimage,omitempty"`
	PaymentRoute    *Route `protobuf:"bytes,3,opt,name=payment_route" json:"payment_route,omitempty"`
}

func (m *SendResponse) Reset()                    { *m = SendResponse{} }
func (m *SendResponse) String() string            { return proto.CompactTextString(m) }
func (*SendResponse) ProtoMessage()               {}
func (*SendResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *SendResponse) GetPaymentError() string {
	if m != nil {
		return m.PaymentError
	}
	return ""
}

func (m *SendResponse) GetPaymentPreimage() []byte {
	if m != nil {
		return m.PaymentPreimage
	}
	return nil
}

func (m *SendResponse) GetPaymentRoute() *Route {
	if m != nil {
		return m.PaymentRoute
	}
	return nil
}

type SendToRouteRequest struct {
	// / The payment hash to use for the HTLC.
	PaymentHash []byte `protobuf:"bytes,1,opt,name=payment_hash,json=paymentHash,proto3" json:"payment_hash,omitempty"`
	// / An optional hex-encoded payment hash to be used for the HTLC.
	PaymentHashString string `protobuf:"bytes,2,opt,name=payment_hash_string,json=paymentHashString" json:"payment_hash_string,omitempty"`
	// / The set of routes that should be used to attempt to complete the payment.
	Routes []*Route `protobuf:"bytes,3,rep,name=routes" json:"routes,omitempty"`
}

func (m *SendToRouteRequest) Reset()                    { *m = SendToRouteRequest{} }
func (m *SendToRouteRequest) String() string            { return proto.CompactTextString(m) }
func (*SendToRouteRequest) ProtoMessage()               {}
func (*SendToRouteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *SendToRouteRequest) GetPaymentHash() []byte {
	if m != nil {
		return m.PaymentHash
	}
	return nil
}

func (m *SendToRouteRequest) GetPaymentHashString() string {
	if m != nil {
		return m.PaymentHashString
	}
	return ""
}

func (m *SendToRouteRequest) GetRoutes() []*Route {
	if m != nil {
		return m.Routes
	}
	return nil
}

type ChannelPoint struct {
	// Types that are valid to be assigned to FundingTxid:
	//	*ChannelPoint_FundingTxidBytes
	//	*ChannelPoint_FundingTxidStr
	FundingTxid isChannelPoint_FundingTxid `protobuf_oneof:"funding_txid"`
	// / The index of the output of the funding transaction
	OutputIndex uint32 `protobuf:"varint,3,opt,name=output_index" json:"output_index,omitempty"`
}

func (m *ChannelPoint) Reset()                    { *m = ChannelPoint{} }
func (m *ChannelPoint) String() string            { return proto.CompactTextString(m) }
func (*ChannelPoint) ProtoMessage()               {}
func (*ChannelPoint) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

type isChannelPoint_FundingTxid interface{ isChannelPoint_FundingTxid() }

type ChannelPoint_FundingTxidBytes struct {
	FundingTxidBytes []byte `protobuf:"bytes,1,opt,name=funding_txid_bytes,proto3,oneof"`
}
type ChannelPoint_FundingTxidStr struct {
	FundingTxidStr string `protobuf:"bytes,2,opt,name=funding_txid_str,oneof"`
}

func (*ChannelPoint_FundingTxidBytes) isChannelPoint_FundingTxid() {}
func (*ChannelPoint_FundingTxidStr) isChannelPoint_FundingTxid()   {}

func (m *ChannelPoint) GetFundingTxid() isChannelPoint_FundingTxid {
	if m != nil {
		return m.FundingTxid
	}
	return nil
}

func (m *ChannelPoint) GetFundingTxidBytes() []byte {
	if x, ok := m.GetFundingTxid().(*ChannelPoint_FundingTxidBytes); ok {
		return x.FundingTxidBytes
	}
	return nil
}

func (m *ChannelPoint) GetFundingTxidStr() string {
	if x, ok := m.GetFundingTxid().(*ChannelPoint_FundingTxidStr); ok {
		return x.FundingTxidStr
	}
	return ""
}

func (m *ChannelPoint) GetOutputIndex() uint32 {
	if m != nil {
		return m.OutputIndex
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ChannelPoint) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ChannelPoint_OneofMarshaler, _ChannelPoint_OneofUnmarshaler, _ChannelPoint_OneofSizer, []interface{}{
		(*ChannelPoint_FundingTxidBytes)(nil),
		(*ChannelPoint_FundingTxidStr)(nil),
	}
}

func _ChannelPoint_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ChannelPoint)
	// funding_txid
	switch x := m.FundingTxid.(type) {
	case *ChannelPoint_FundingTxidBytes:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.FundingTxidBytes)
	case *ChannelPoint_FundingTxidStr:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.FundingTxidStr)
	case nil:
	default:
		return fmt.Errorf("ChannelPoint.FundingTxid has unexpected type %T", x)
	}
	return nil
}

func _ChannelPoint_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ChannelPoint)
	switch tag {
	case 1: // funding_txid.funding_txid_bytes
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.FundingTxid = &ChannelPoint_FundingTxidBytes{x}
		return true, err
	case 2: // funding_txid.funding_txid_str
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.FundingTxid = &ChannelPoint_FundingTxidStr{x}
		return true, err
	default:
		return false, nil
	}
}

func _ChannelPoint_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ChannelPoint)
	// funding_txid
	switch x := m.FundingTxid.(type) {
	case *ChannelPoint_FundingTxidBytes:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.FundingTxidBytes)))
		n += len(x.FundingTxidBytes)
	case *ChannelPoint_FundingTxidStr:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.FundingTxidStr)))
		n += len(x.FundingTxidStr)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type LightningAddress struct {
	// / The identity pubkey of the Lightning node
	Pubkey string `protobuf:"bytes,1,opt,name=pubkey" json:"pubkey,omitempty"`
	// / The network location of the lightning node, e.g. `69.69.69.69:1337` or `localhost:10011`
	Host string `protobuf:"bytes,2,opt,name=host" json:"host,omitempty"`
}

func (m *LightningAddress) Reset()                    { *m = LightningAddress{} }
func (m *LightningAddress) String() string            { return proto.CompactTextString(m) }
func (*LightningAddress) ProtoMessage()               {}
func (*LightningAddress) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *LightningAddress) GetPubkey() string {
	if m != nil {
		return m.Pubkey
	}
	return ""
}

func (m *LightningAddress) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

type SendManyRequest struct {
	// / The map from addresses to amounts
	AddrToAmount map[string]int64 `protobuf:"bytes,1,rep,name=AddrToAmount" json:"AddrToAmount,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	// / The target number of blocks that this transaction should be confirmed by.
	TargetConf int32 `protobuf:"varint,3,opt,name=target_conf,json=targetConf" json:"target_conf,omitempty"`
	// / A manual fee rate set in sat/byte that should be used when crafting the transaction.
	SatPerByte int64 `protobuf:"varint,5,opt,name=sat_per_byte,json=satPerByte" json:"sat_per_byte,omitempty"`
}

func (m *SendManyRequest) Reset()                    { *m = SendManyRequest{} }
func (m *SendManyRequest) String() string            { return proto.CompactTextString(m) }
func (*SendManyRequest) ProtoMessage()               {}
func (*SendManyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *SendManyRequest) GetAddrToAmount() map[string]int64 {
	if m != nil {
		return m.AddrToAmount
	}
	return nil
}

func (m *SendManyRequest) GetTargetConf() int32 {
	if m != nil {
		return m.TargetConf
	}
	return 0
}

func (m *SendManyRequest) GetSatPerByte() int64 {
	if m != nil {
		return m.SatPerByte
	}
	return 0
}

type SendManyResponse struct {
	// / The id of the transaction
	Txid string `protobuf:"bytes,1,opt,name=txid" json:"txid,omitempty"`
}

func (m *SendManyResponse) Reset()                    { *m = SendManyResponse{} }
func (m *SendManyResponse) String() string            { return proto.CompactTextString(m) }
func (*SendManyResponse) ProtoMessage()               {}
func (*SendManyResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *SendManyResponse) GetTxid() string {
	if m != nil {
		return m.Txid
	}
	return ""
}

type SendCoinsRequest struct {
	// / The address to send coins to
	Addr string `protobuf:"bytes,1,opt,name=addr" json:"addr,omitempty"`
	// / The amount in satoshis to send
	Amount int64 `protobuf:"varint,2,opt,name=amount" json:"amount,omitempty"`
	// / The target number of blocks that this transaction should be confirmed by.
	TargetConf int32 `protobuf:"varint,3,opt,name=target_conf,json=targetConf" json:"target_conf,omitempty"`
	// / A manual fee rate set in sat/byte that should be used when crafting the transaction.
	SatPerByte int64 `protobuf:"varint,5,opt,name=sat_per_byte,json=satPerByte" json:"sat_per_byte,omitempty"`
}

func (m *SendCoinsRequest) Reset()                    { *m = SendCoinsRequest{} }
func (m *SendCoinsRequest) String() string            { return proto.CompactTextString(m) }
func (*SendCoinsRequest) ProtoMessage()               {}
func (*SendCoinsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *SendCoinsRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *SendCoinsRequest) GetAmount() int64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *SendCoinsRequest) GetTargetConf() int32 {
	if m != nil {
		return m.TargetConf
	}
	return 0
}

func (m *SendCoinsRequest) GetSatPerByte() int64 {
	if m != nil {
		return m.SatPerByte
	}
	return 0
}

type SendCoinsResponse struct {
	// / The transaction ID of the transaction
	Txid string `protobuf:"bytes,1,opt,name=txid" json:"txid,omitempty"`
}

func (m *SendCoinsResponse) Reset()                    { *m = SendCoinsResponse{} }
func (m *SendCoinsResponse) String() string            { return proto.CompactTextString(m) }
func (*SendCoinsResponse) ProtoMessage()               {}
func (*SendCoinsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *SendCoinsResponse) GetTxid() string {
	if m != nil {
		return m.Txid
	}
	return ""
}

// *
// `AddressType` has to be one of:
//
// - `p2wkh`: Pay to witness key hash (`WITNESS_PUBKEY_HASH` = 0)
// - `np2wkh`: Pay to nested witness key hash (`NESTED_PUBKEY_HASH` = 1)
// - `p2pkh`:  Pay to public key hash (`PUBKEY_HASH` = 2)
type NewAddressRequest struct {
	// / The address type
	Type NewAddressRequest_AddressType `protobuf:"varint,1,opt,name=type,enum=lnrpc.NewAddressRequest_AddressType" json:"type,omitempty"`
}

func (m *NewAddressRequest) Reset()                    { *m = NewAddressRequest{} }
func (m *NewAddressRequest) String() string            { return proto.CompactTextString(m) }
func (*NewAddressRequest) ProtoMessage()               {}
func (*NewAddressRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *NewAddressRequest) GetType() NewAddressRequest_AddressType {
	if m != nil {
		return m.Type
	}
	return NewAddressRequest_WITNESS_PUBKEY_HASH
}

type NewWitnessAddressRequest struct {
}

func (m *NewWitnessAddressRequest) Reset()                    { *m = NewWitnessAddressRequest{} }
func (m *NewWitnessAddressRequest) String() string            { return proto.CompactTextString(m) }
func (*NewWitnessAddressRequest) ProtoMessage()               {}
func (*NewWitnessAddressRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

type NewAddressResponse struct {
	// / The newly generated wallet address
	Address string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
}

func (m *NewAddressResponse) Reset()                    { *m = NewAddressResponse{} }
func (m *NewAddressResponse) String() string            { return proto.CompactTextString(m) }
func (*NewAddressResponse) ProtoMessage()               {}
func (*NewAddressResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *NewAddressResponse) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type SignMessageRequest struct {
	// / The message to be signed
	Msg []byte `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *SignMessageRequest) Reset()                    { *m = SignMessageRequest{} }
func (m *SignMessageRequest) String() string            { return proto.CompactTextString(m) }
func (*SignMessageRequest) ProtoMessage()               {}
func (*SignMessageRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *SignMessageRequest) GetMsg() []byte {
	if m != nil {
		return m.Msg
	}
	return nil
}

type SignMessageResponse struct {
	// / The signature for the given message
	Signature string `protobuf:"bytes,1,opt,name=signature" json:"signature,omitempty"`
}

func (m *SignMessageResponse) Reset()                    { *m = SignMessageResponse{} }
func (m *SignMessageResponse) String() string            { return proto.CompactTextString(m) }
func (*SignMessageResponse) ProtoMessage()               {}
func (*SignMessageResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *SignMessageResponse) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

type VerifyMessageRequest struct {
	// / The message over which the signature is to be verified
	Msg []byte `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	// / The signature to be verified over the given message
	Signature string `protobuf:"bytes,2,opt,name=signature" json:"signature,omitempty"`
}

func (m *VerifyMessageRequest) Reset()                    { *m = VerifyMessageRequest{} }
func (m *VerifyMessageRequest) String() string            { return proto.CompactTextString(m) }
func (*VerifyMessageRequest) ProtoMessage()               {}
func (*VerifyMessageRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *VerifyMessageRequest) GetMsg() []byte {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *VerifyMessageRequest) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

type VerifyMessageResponse struct {
	// / Whether the signature was valid over the given message
	Valid bool `protobuf:"varint,1,opt,name=valid" json:"valid,omitempty"`
	// / The pubkey recovered from the signature
	Pubkey string `protobuf:"bytes,2,opt,name=pubkey" json:"pubkey,omitempty"`
}

func (m *VerifyMessageResponse) Reset()                    { *m = VerifyMessageResponse{} }
func (m *VerifyMessageResponse) String() string            { return proto.CompactTextString(m) }
func (*VerifyMessageResponse) ProtoMessage()               {}
func (*VerifyMessageResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *VerifyMessageResponse) GetValid() bool {
	if m != nil {
		return m.Valid
	}
	return false
}

func (m *VerifyMessageResponse) GetPubkey() string {
	if m != nil {
		return m.Pubkey
	}
	return ""
}

type ConnectPeerRequest struct {
	// / Lightning address of the peer, in the format `<pubkey>@host`
	Addr *LightningAddress `protobuf:"bytes,1,opt,name=addr" json:"addr,omitempty"`
	// * If set, the daemon will attempt to persistently connect to the target
	// peer.  Otherwise, the call will be synchronous.
	Perm bool `protobuf:"varint,2,opt,name=perm" json:"perm,omitempty"`
}

func (m *ConnectPeerRequest) Reset()                    { *m = ConnectPeerRequest{} }
func (m *ConnectPeerRequest) String() string            { return proto.CompactTextString(m) }
func (*ConnectPeerRequest) ProtoMessage()               {}
func (*ConnectPeerRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *ConnectPeerRequest) GetAddr() *LightningAddress {
	if m != nil {
		return m.Addr
	}
	return nil
}

func (m *ConnectPeerRequest) GetPerm() bool {
	if m != nil {
		return m.Perm
	}
	return false
}

type ConnectPeerResponse struct {
}

func (m *ConnectPeerResponse) Reset()                    { *m = ConnectPeerResponse{} }
func (m *ConnectPeerResponse) String() string            { return proto.CompactTextString(m) }
func (*ConnectPeerResponse) ProtoMessage()               {}
func (*ConnectPeerResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

type DisconnectPeerRequest struct {
	// / The pubkey of the node to disconnect from
	PubKey string `protobuf:"bytes,1,opt,name=pub_key" json:"pub_key,omitempty"`
}

func (m *DisconnectPeerRequest) Reset()                    { *m = DisconnectPeerRequest{} }
func (m *DisconnectPeerRequest) String() string            { return proto.CompactTextString(m) }
func (*DisconnectPeerRequest) ProtoMessage()               {}
func (*DisconnectPeerRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *DisconnectPeerRequest) GetPubKey() string {
	if m != nil {
		return m.PubKey
	}
	return ""
}

type DisconnectPeerResponse struct {
}

func (m *DisconnectPeerResponse) Reset()                    { *m = DisconnectPeerResponse{} }
func (m *DisconnectPeerResponse) String() string            { return proto.CompactTextString(m) }
func (*DisconnectPeerResponse) ProtoMessage()               {}
func (*DisconnectPeerResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

type HTLC struct {
	Incoming         bool   `protobuf:"varint,1,opt,name=incoming" json:"incoming,omitempty"`
	Amount           int64  `protobuf:"varint,2,opt,name=amount" json:"amount,omitempty"`
	HashLock         []byte `protobuf:"bytes,3,opt,name=hash_lock,proto3" json:"hash_lock,omitempty"`
	ExpirationHeight uint32 `protobuf:"varint,4,opt,name=expiration_height" json:"expiration_height,omitempty"`
}

func (m *HTLC) Reset()                    { *m = HTLC{} }
func (m *HTLC) String() string            { return proto.CompactTextString(m) }
func (*HTLC) ProtoMessage()               {}
func (*HTLC) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

func (m *HTLC) GetIncoming() bool {
	if m != nil {
		return m.Incoming
	}
	return false
}

func (m *HTLC) GetAmount() int64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *HTLC) GetHashLock() []byte {
	if m != nil {
		return m.HashLock
	}
	return nil
}

func (m *HTLC) GetExpirationHeight() uint32 {
	if m != nil {
		return m.ExpirationHeight
	}
	return 0
}

type Channel struct {
	// / Whether this channel is active or not
	Active bool `protobuf:"varint,1,opt,name=active" json:"active,omitempty"`
	// / The identity pubkey of the remote node
	RemotePubkey string `protobuf:"bytes,2,opt,name=remote_pubkey" json:"remote_pubkey,omitempty"`
	// *
	// The outpoint (txid:index) of the funding transaction. With this value, Bob
	// will be able to generate a signature for Alice's version of the commitment
	// transaction.
	ChannelPoint string `protobuf:"bytes,3,opt,name=channel_point" json:"channel_point,omitempty"`
	// *
	// The unique channel ID for the channel. The first 3 bytes are the block
	// height, the next 3 the index within the block, and the last 2 bytes are the
	// output index for the channel.
	ChanId uint64 `protobuf:"varint,4,opt,name=chan_id" json:"chan_id,omitempty"`
	// / The total amount of funds held in this channel
	Capacity int64 `protobuf:"varint,5,opt,name=capacity" json:"capacity,omitempty"`
	// / This node's current balance in this channel
	LocalBalance int64 `protobuf:"varint,6,opt,name=local_balance" json:"local_balance,omitempty"`
	// / The counterparty's current balance in this channel
	RemoteBalance int64 `protobuf:"varint,7,opt,name=remote_balance" json:"remote_balance,omitempty"`
	// *
	// The amount calculated to be paid in fees for the current set of commitment
	// transactions. The fee amount is persisted with the channel in order to
	// allow the fee amount to be removed and recalculated with each channel state
	// update, including updates that happen after a system restart.
	CommitFee int64 `protobuf:"varint,8,opt,name=commit_fee" json:"commit_fee,omitempty"`
	// / The weight of the commitment transaction
	CommitWeight int64 `protobuf:"varint,9,opt,name=commit_weight" json:"commit_weight,omitempty"`
	// *
	// The required number of satoshis per kilo-weight that the requester will pay
	// at all times, for both the funding transaction and commitment transaction.
	// This value can later be updated once the channel is open.
	FeePerKw int64 `protobuf:"varint,10,opt,name=fee_per_kw" json:"fee_per_kw,omitempty"`
	// / The unsettled balance in this channel
	UnsettledBalance int64 `protobuf:"varint,11,opt,name=unsettled_balance" json:"unsettled_balance,omitempty"`
	// *
	// The total number of satoshis we've sent within this channel.
	TotalSatoshisSent int64 `protobuf:"varint,12,opt,name=total_satoshis_sent" json:"total_satoshis_sent,omitempty"`
	// *
	// The total number of satoshis we've received within this channel.
	TotalSatoshisReceived int64 `protobuf:"varint,13,opt,name=total_satoshis_received" json:"total_satoshis_received,omitempty"`
	// *
	// The total number of updates conducted within this channel.
	NumUpdates uint64 `protobuf:"varint,14,opt,name=num_updates" json:"num_updates,omitempty"`
	// *
	// The list of active, uncleared HTLCs currently pending within the channel.
	PendingHtlcs []*HTLC `protobuf:"bytes,15,rep,name=pending_htlcs" json:"pending_htlcs,omitempty"`
	// *
	// The CSV delay expressed in relative blocks. If the channel is force
	// closed, we'll need to wait for this many blocks before we can regain our
	// funds.
	CsvDelay uint32 `protobuf:"varint,16,opt,name=csv_delay" json:"csv_delay,omitempty"`
	// / Whether this channel is advertised to the network or not
	Private bool `protobuf:"varint,17,opt,name=private" json:"private,omitempty"`
}

func (m *Channel) Reset()                    { *m = Channel{} }
func (m *Channel) String() string            { return proto.CompactTextString(m) }
func (*Channel) ProtoMessage()               {}
func (*Channel) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

func (m *Channel) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *Channel) GetRemotePubkey() string {
	if m != nil {
		return m.RemotePubkey
	}
	return ""
}

func (m *Channel) GetChannelPoint() string {
	if m != nil {
		return m.ChannelPoint
	}
	return ""
}

func (m *Channel) GetChanId() uint64 {
	if m != nil {
		return m.ChanId
	}
	return 0
}

func (m *Channel) GetCapacity() int64 {
	if m != nil {
		return m.Capacity
	}
	return 0
}

func (m *Channel) GetLocalBalance() int64 {
	if m != nil {
		return m.LocalBalance
	}
	return 0
}

func (m *Channel) GetRemoteBalance() int64 {
	if m != nil {
		return m.RemoteBalance
	}
	return 0
}

func (m *Channel) GetCommitFee() int64 {
	if m != nil {
		return m.CommitFee
	}
	return 0
}

func (m *Channel) GetCommitWeight() int64 {
	if m != nil {
		return m.CommitWeight
	}
	return 0
}

func (m *Channel) GetFeePerKw() int64 {
	if m != nil {
		return m.FeePerKw
	}
	return 0
}

func (m *Channel) GetUnsettledBalance() int64 {
	if m != nil {
		return m.UnsettledBalance
	}
	return 0
}

func (m *Channel) GetTotalSatoshisSent() int64 {
	if m != nil {
		return m.TotalSatoshisSent
	}
	return 0
}

func (m *Channel) GetTotalSatoshisReceived() int64 {
	if m != nil {
		return m.TotalSatoshisReceived
	}
	return 0
}

func (m *Channel) GetNumUpdates() uint64 {
	if m != nil {
		return m.NumUpdates
	}
	return 0
}

func (m *Channel) GetPendingHtlcs() []*HTLC {
	if m != nil {
		return m.PendingHtlcs
	}
	return nil
}

func (m *Channel) GetCsvDelay() uint32 {
	if m != nil {
		return m.CsvDelay
	}
	return 0
}

func (m *Channel) GetPrivate() bool {
	if m != nil {
		return m.Private
	}
	return false
}

type ListChannelsRequest struct {
	ActiveOnly   bool `protobuf:"varint,1,opt,name=active_only,json=activeOnly" json:"active_only,omitempty"`
	InactiveOnly bool `protobuf:"varint,2,opt,name=inactive_only,json=inactiveOnly" json:"inactive_only,omitempty"`
	PublicOnly   bool `protobuf:"varint,3,opt,name=public_only,json=publicOnly" json:"public_only,omitempty"`
	PrivateOnly  bool `protobuf:"varint,4,opt,name=private_only,json=privateOnly" json:"private_only,omitempty"`
}

func (m *ListChannelsRequest) Reset()                    { *m = ListChannelsRequest{} }
func (m *ListChannelsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListChannelsRequest) ProtoMessage()               {}
func (*ListChannelsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

func (m *ListChannelsRequest) GetActiveOnly() bool {
	if m != nil {
		return m.ActiveOnly
	}
	return false
}

func (m *ListChannelsRequest) GetInactiveOnly() bool {
	if m != nil {
		return m.InactiveOnly
	}
	return false
}

func (m *ListChannelsRequest) GetPublicOnly() bool {
	if m != nil {
		return m.PublicOnly
	}
	return false
}

func (m *ListChannelsRequest) GetPrivateOnly() bool {
	if m != nil {
		return m.PrivateOnly
	}
	return false
}

type ListChannelsResponse struct {
	// / The list of active channels
	Channels []*Channel `protobuf:"bytes,11,rep,name=channels" json:"channels,omitempty"`
}

func (m *ListChannelsResponse) Reset()                    { *m = ListChannelsResponse{} }
func (m *ListChannelsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListChannelsResponse) ProtoMessage()               {}
func (*ListChannelsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

func (m *ListChannelsResponse) GetChannels() []*Channel {
	if m != nil {
		return m.Channels
	}
	return nil
}

type ChannelCloseSummary struct {
	// / The outpoint (txid:index) of the funding transaction.
	ChannelPoint string `protobuf:"bytes,1,opt,name=channel_point" json:"channel_point,omitempty"`
	// /  The unique channel ID for the channel.
	ChanId uint64 `protobuf:"varint,2,opt,name=chan_id" json:"chan_id,omitempty"`
	// / The hash of the genesis block that this channel resides within.
	ChainHash string `protobuf:"bytes,3,opt,name=chain_hash" json:"chain_hash,omitempty"`
	// / The txid of the transaction which ultimately closed this channel.
	ClosingTxHash string `protobuf:"bytes,4,opt,name=closing_tx_hash" json:"closing_tx_hash,omitempty"`
	// / Public key of the remote peer that we formerly had a channel with.
	RemotePubkey string `protobuf:"bytes,5,opt,name=remote_pubkey" json:"remote_pubkey,omitempty"`
	// / Total capacity of the channel.
	Capacity int64 `protobuf:"varint,6,opt,name=capacity" json:"capacity,omitempty"`
	// / Height at which the funding transaction was spent.
	CloseHeight uint32 `protobuf:"varint,7,opt,name=close_height" json:"close_height,omitempty"`
	// / Settled balance at the time of channel closure
	SettledBalance int64 `protobuf:"varint,8,opt,name=settled_balance" json:"settled_balance,omitempty"`
	// / The sum of all the time-locked outputs at the time of channel closure
	TimeLockedBalance int64 `protobuf:"varint,9,opt,name=time_locked_balance" json:"time_locked_balance,omitempty"`
	// / Details on how the channel was closed.
	CloseType ChannelCloseSummary_ClosureType `protobuf:"varint,10,opt,name=close_type,enum=lnrpc.ChannelCloseSummary_ClosureType" json:"close_type,omitempty"`
}

func (m *ChannelCloseSummary) Reset()                    { *m = ChannelCloseSummary{} }
func (m *ChannelCloseSummary) String() string            { return proto.CompactTextString(m) }
func (*ChannelCloseSummary) ProtoMessage()               {}
func (*ChannelCloseSummary) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{36} }

func (m *ChannelCloseSummary) GetChannelPoint() string {
	if m != nil {
		return m.ChannelPoint
	}
	return ""
}

func (m *ChannelCloseSummary) GetChanId() uint64 {
	if m != nil {
		return m.ChanId
	}
	return 0
}

func (m *ChannelCloseSummary) GetChainHash() string {
	if m != nil {
		return m.ChainHash
	}
	return ""
}

func (m *ChannelCloseSummary) GetClosingTxHash() string {
	if m != nil {
		return m.ClosingTxHash
	}
	return ""
}

func (m *ChannelCloseSummary) GetRemotePubkey() string {
	if m != nil {
		return m.RemotePubkey
	}
	return ""
}

func (m *ChannelCloseSummary) GetCapacity() int64 {
	if m != nil {
		return m.Capacity
	}
	return 0
}

func (m *ChannelCloseSummary) GetCloseHeight() uint32 {
	if m != nil {
		return m.CloseHeight
	}
	return 0
}

func (m *ChannelCloseSummary) GetSettledBalance() int64 {
	if m != nil {
		return m.SettledBalance
	}
	return 0
}

func (m *ChannelCloseSummary) GetTimeLockedBalance() int64 {
	if m != nil {
		return m.TimeLockedBalance
	}
	return 0
}

func (m *ChannelCloseSummary) GetCloseType() ChannelCloseSummary_ClosureType {
	if m != nil {
		return m.CloseType
	}
	return ChannelCloseSummary_COOPERATIVE_CLOSE
}

type ClosedChannelsRequest struct {
	Cooperative     bool `protobuf:"varint,1,opt,name=cooperative" json:"cooperative,omitempty"`
	LocalForce      bool `protobuf:"varint,2,opt,name=local_force,json=localForce" json:"local_force,omitempty"`
	RemoteForce     bool `protobuf:"varint,3,opt,name=remote_force,json=remoteForce" json:"remote_force,omitempty"`
	Breach          bool `protobuf:"varint,4,opt,name=breach" json:"breach,omitempty"`
	FundingCanceled bool `protobuf:"varint,5,opt,name=funding_canceled,json=fundingCanceled" json:"funding_canceled,omitempty"`
}

func (m *ClosedChannelsRequest) Reset()                    { *m = ClosedChannelsRequest{} }
func (m *ClosedChannelsRequest) String() string            { return proto.CompactTextString(m) }
func (*ClosedChannelsRequest) ProtoMessage()               {}
func (*ClosedChannelsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{37} }

func (m *ClosedChannelsRequest) GetCooperative() bool {
	if m != nil {
		return m.Cooperative
	}
	return false
}

func (m *ClosedChannelsRequest) GetLocalForce() bool {
	if m != nil {
		return m.LocalForce
	}
	return false
}

func (m *ClosedChannelsRequest) GetRemoteForce() bool {
	if m != nil {
		return m.RemoteForce
	}
	return false
}

func (m *ClosedChannelsRequest) GetBreach() bool {
	if m != nil {
		return m.Breach
	}
	return false
}

func (m *ClosedChannelsRequest) GetFundingCanceled() bool {
	if m != nil {
		return m.FundingCanceled
	}
	return false
}

type ClosedChannelsResponse struct {
	Channels []*ChannelCloseSummary `protobuf:"bytes,1,rep,name=channels" json:"channels,omitempty"`
}

func (m *ClosedChannelsResponse) Reset()                    { *m = ClosedChannelsResponse{} }
func (m *ClosedChannelsResponse) String() string            { return proto.CompactTextString(m) }
func (*ClosedChannelsResponse) ProtoMessage()               {}
func (*ClosedChannelsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{38} }

func (m *ClosedChannelsResponse) GetChannels() []*ChannelCloseSummary {
	if m != nil {
		return m.Channels
	}
	return nil
}

type Peer struct {
	// / The identity pubkey of the peer
	PubKey string `protobuf:"bytes,1,opt,name=pub_key" json:"pub_key,omitempty"`
	// / Network address of the peer; eg `127.0.0.1:10011`
	Address string `protobuf:"bytes,3,opt,name=address" json:"address,omitempty"`
	// / Bytes of data transmitted to this peer
	BytesSent uint64 `protobuf:"varint,4,opt,name=bytes_sent" json:"bytes_sent,omitempty"`
	// / Bytes of data transmitted from this peer
	BytesRecv uint64 `protobuf:"varint,5,opt,name=bytes_recv" json:"bytes_recv,omitempty"`
	// / Satoshis sent to this peer
	SatSent int64 `protobuf:"varint,6,opt,name=sat_sent" json:"sat_sent,omitempty"`
	// / Satoshis received from this peer
	SatRecv int64 `protobuf:"varint,7,opt,name=sat_recv" json:"sat_recv,omitempty"`
	// / A channel is inbound if the counterparty initiated the channel
	Inbound bool `protobuf:"varint,8,opt,name=inbound" json:"inbound,omitempty"`
	// / Ping time to this peer
	PingTime int64 `protobuf:"varint,9,opt,name=ping_time" json:"ping_time,omitempty"`
}

func (m *Peer) Reset()                    { *m = Peer{} }
func (m *Peer) String() string            { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()               {}
func (*Peer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{39} }

func (m *Peer) GetPubKey() string {
	if m != nil {
		return m.PubKey
	}
	return ""
}

func (m *Peer) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Peer) GetBytesSent() uint64 {
	if m != nil {
		return m.BytesSent
	}
	return 0
}

func (m *Peer) GetBytesRecv() uint64 {
	if m != nil {
		return m.BytesRecv
	}
	return 0
}

func (m *Peer) GetSatSent() int64 {
	if m != nil {
		return m.SatSent
	}
	return 0
}

func (m *Peer) GetSatRecv() int64 {
	if m != nil {
		return m.SatRecv
	}
	return 0
}

func (m *Peer) GetInbound() bool {
	if m != nil {
		return m.Inbound
	}
	return false
}

func (m *Peer) GetPingTime() int64 {
	if m != nil {
		return m.PingTime
	}
	return 0
}

type ListPeersRequest struct {
}

func (m *ListPeersRequest) Reset()                    { *m = ListPeersRequest{} }
func (m *ListPeersRequest) String() string            { return proto.CompactTextString(m) }
func (*ListPeersRequest) ProtoMessage()               {}
func (*ListPeersRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{40} }

type ListPeersResponse struct {
	// / The list of currently connected peers
	Peers []*Peer `protobuf:"bytes,1,rep,name=peers" json:"peers,omitempty"`
}

func (m *ListPeersResponse) Reset()                    { *m = ListPeersResponse{} }
func (m *ListPeersResponse) String() string            { return proto.CompactTextString(m) }
func (*ListPeersResponse) ProtoMessage()               {}
func (*ListPeersResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{41} }

func (m *ListPeersResponse) GetPeers() []*Peer {
	if m != nil {
		return m.Peers
	}
	return nil
}

type GetInfoRequest struct {
}

func (m *GetInfoRequest) Reset()                    { *m = GetInfoRequest{} }
func (m *GetInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*GetInfoRequest) ProtoMessage()               {}
func (*GetInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{42} }

type GetInfoResponse struct {
	// / The identity pubkey of the current node.
	IdentityPubkey string `protobuf:"bytes,1,opt,name=identity_pubkey" json:"identity_pubkey,omitempty"`
	// / If applicable, the alias of the current node, e.g. "bob"
	Alias string `protobuf:"bytes,2,opt,name=alias" json:"alias,omitempty"`
	// / Number of pending channels
	NumPendingChannels uint32 `protobuf:"varint,3,opt,name=num_pending_channels" json:"num_pending_channels,omitempty"`
	// / Number of active channels
	NumActiveChannels uint32 `protobuf:"varint,4,opt,name=num_active_channels" json:"num_active_channels,omitempty"`
	// / Number of peers
	NumPeers uint32 `protobuf:"varint,5,opt,name=num_peers" json:"num_peers,omitempty"`
	// / The node's current view of the height of the best block
	BlockHeight uint32 `protobuf:"varint,6,opt,name=block_height" json:"block_height,omitempty"`
	// / The node's current view of the hash of the best block
	BlockHash string `protobuf:"bytes,8,opt,name=block_hash" json:"block_hash,omitempty"`
	// / Whether the wallet's view is synced to the main chain
	SyncedToChain bool `protobuf:"varint,9,opt,name=synced_to_chain" json:"synced_to_chain,omitempty"`
	// / Whether the current node is connected to testnet
	Testnet bool `protobuf:"varint,10,opt,name=testnet" json:"testnet,omitempty"`
	// / A list of active chains the node is connected to
	Chains []string `protobuf:"bytes,11,rep,name=chains" json:"chains,omitempty"`
	// / The URIs of the current node.
	Uris []string `protobuf:"bytes,12,rep,name=uris" json:"uris,omitempty"`
	// / Timestamp of the block best known to the wallet
	BestHeaderTimestamp int64 `protobuf:"varint,13,opt,name=best_header_timestamp" json:"best_header_timestamp,omitempty"`
	// / The version of the LND software that the node is running.
	Version string `protobuf:"bytes,14,opt,name=version" json:"version,omitempty"`
}

func (m *GetInfoResponse) Reset()                    { *m = GetInfoResponse{} }
func (m *GetInfoResponse) String() string            { return proto.CompactTextString(m) }
func (*GetInfoResponse) ProtoMessage()               {}
func (*GetInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{43} }

func (m *GetInfoResponse) GetIdentityPubkey() string {
	if m != nil {
		return m.IdentityPubkey
	}
	return ""
}

func (m *GetInfoResponse) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

func (m *GetInfoResponse) GetNumPendingChannels() uint32 {
	if m != nil {
		return m.NumPendingChannels
	}
	return 0
}

func (m *GetInfoResponse) GetNumActiveChannels() uint32 {
	if m != nil {
		return m.NumActiveChannels
	}
	return 0
}

func (m *GetInfoResponse) GetNumPeers() uint32 {
	if m != nil {
		return m.NumPeers
	}
	return 0
}

func (m *GetInfoResponse) GetBlockHeight() uint32 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *GetInfoResponse) GetBlockHash() string {
	if m != nil {
		return m.BlockHash
	}
	return ""
}

func (m *GetInfoResponse) GetSyncedToChain() bool {
	if m != nil {
		return m.SyncedToChain
	}
	return false
}

func (m *GetInfoResponse) GetTestnet() bool {
	if m != nil {
		return m.Testnet
	}
	return false
}

func (m *GetInfoResponse) GetChains() []string {
	if m != nil {
		return m.Chains
	}
	return nil
}

func (m *GetInfoResponse) GetUris() []string {
	if m != nil {
		return m.Uris
	}
	return nil
}

func (m *GetInfoResponse) GetBestHeaderTimestamp() int64 {
	if m != nil {
		return m.BestHeaderTimestamp
	}
	return 0
}

func (m *GetInfoResponse) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type ConfirmationUpdate struct {
	BlockSha     []byte `protobuf:"bytes,1,opt,name=block_sha,json=blockSha,proto3" json:"block_sha,omitempty"`
	BlockHeight  int32  `protobuf:"varint,2,opt,name=block_height,json=blockHeight" json:"block_height,omitempty"`
	NumConfsLeft uint32 `protobuf:"varint,3,opt,name=num_confs_left,json=numConfsLeft" json:"num_confs_left,omitempty"`
}

func (m *ConfirmationUpdate) Reset()                    { *m = ConfirmationUpdate{} }
func (m *ConfirmationUpdate) String() string            { return proto.CompactTextString(m) }
func (*ConfirmationUpdate) ProtoMessage()               {}
func (*ConfirmationUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{44} }

func (m *ConfirmationUpdate) GetBlockSha() []byte {
	if m != nil {
		return m.BlockSha
	}
	return nil
}

func (m *ConfirmationUpdate) GetBlockHeight() int32 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *ConfirmationUpdate) GetNumConfsLeft() uint32 {
	if m != nil {
		return m.NumConfsLeft
	}
	return 0
}

type ChannelOpenUpdate struct {
	ChannelPoint *ChannelPoint `protobuf:"bytes,1,opt,name=channel_point" json:"channel_point,omitempty"`
}

func (m *ChannelOpenUpdate) Reset()                    { *m = ChannelOpenUpdate{} }
func (m *ChannelOpenUpdate) String() string            { return proto.CompactTextString(m) }
func (*ChannelOpenUpdate) ProtoMessage()               {}
func (*ChannelOpenUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{45} }

func (m *ChannelOpenUpdate) GetChannelPoint() *ChannelPoint {
	if m != nil {
		return m.ChannelPoint
	}
	return nil
}

type ChannelCloseUpdate struct {
	ClosingTxid []byte `protobuf:"bytes,1,opt,name=closing_txid,proto3" json:"closing_txid,omitempty"`
	Success     bool   `protobuf:"varint,2,opt,name=success" json:"success,omitempty"`
}

func (m *ChannelCloseUpdate) Reset()                    { *m = ChannelCloseUpdate{} }
func (m *ChannelCloseUpdate) String() string            { return proto.CompactTextString(m) }
func (*ChannelCloseUpdate) ProtoMessage()               {}
func (*ChannelCloseUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{46} }

func (m *ChannelCloseUpdate) GetClosingTxid() []byte {
	if m != nil {
		return m.ClosingTxid
	}
	return nil
}

func (m *ChannelCloseUpdate) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type CloseChannelRequest struct {
	// *
	// The outpoint (txid:index) of the funding transaction. With this value, Bob
	// will be able to generate a signature for Alice's version of the commitment
	// transaction.
	ChannelPoint *ChannelPoint `protobuf:"bytes,1,opt,name=channel_point,json=channelPoint" json:"channel_point,omitempty"`
	// / If true, then the channel will be closed forcibly. This means the current commitment transaction will be signed and broadcast.
	Force bool `protobuf:"varint,2,opt,name=force" json:"force,omitempty"`
	// / The target number of blocks that the closure transaction should be confirmed by.
	TargetConf int32 `protobuf:"varint,3,opt,name=target_conf,json=targetConf" json:"target_conf,omitempty"`
	// / A manual fee rate set in sat/byte that should be used when crafting the closure transaction.
	SatPerByte int64 `protobuf:"varint,4,opt,name=sat_per_byte,json=satPerByte" json:"sat_per_byte,omitempty"`
}

func (m *CloseChannelRequest) Reset()                    { *m = CloseChannelRequest{} }
func (m *CloseChannelRequest) String() string            { return proto.CompactTextString(m) }
func (*CloseChannelRequest) ProtoMessage()               {}
func (*CloseChannelRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{47} }

func (m *CloseChannelRequest) GetChannelPoint() *ChannelPoint {
	if m != nil {
		return m.ChannelPoint
	}
	return nil
}

func (m *CloseChannelRequest) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

func (m *CloseChannelRequest) GetTargetConf() int32 {
	if m != nil {
		return m.TargetConf
	}
	return 0
}

func (m *CloseChannelRequest) GetSatPerByte() int64 {
	if m != nil {
		return m.SatPerByte
	}
	return 0
}

type CloseStatusUpdate struct {
	// Types that are valid to be assigned to Update:
	//	*CloseStatusUpdate_ClosePending
	//	*CloseStatusUpdate_Confirmation
	//	*CloseStatusUpdate_ChanClose
	Update isCloseStatusUpdate_Update `protobuf_oneof:"update"`
}

func (m *CloseStatusUpdate) Reset()                    { *m = CloseStatusUpdate{} }
func (m *CloseStatusUpdate) String() string            { return proto.CompactTextString(m) }
func (*CloseStatusUpdate) ProtoMessage()               {}
func (*CloseStatusUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{48} }

type isCloseStatusUpdate_Update interface{ isCloseStatusUpdate_Update() }

type CloseStatusUpdate_ClosePending struct {
	ClosePending *PendingUpdate `protobuf:"bytes,1,opt,name=close_pending,oneof"`
}
type CloseStatusUpdate_Confirmation struct {
	Confirmation *ConfirmationUpdate `protobuf:"bytes,2,opt,name=confirmation,oneof"`
}
type CloseStatusUpdate_ChanClose struct {
	ChanClose *ChannelCloseUpdate `protobuf:"bytes,3,opt,name=chan_close,oneof"`
}

func (*CloseStatusUpdate_ClosePending) isCloseStatusUpdate_Update() {}
func (*CloseStatusUpdate_Confirmation) isCloseStatusUpdate_Update() {}
func (*CloseStatusUpdate_ChanClose) isCloseStatusUpdate_Update()    {}

func (m *CloseStatusUpdate) GetUpdate() isCloseStatusUpdate_Update {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *CloseStatusUpdate) GetClosePending() *PendingUpdate {
	if x, ok := m.GetUpdate().(*CloseStatusUpdate_ClosePending); ok {
		return x.ClosePending
	}
	return nil
}

func (m *CloseStatusUpdate) GetConfirmation() *ConfirmationUpdate {
	if x, ok := m.GetUpdate().(*CloseStatusUpdate_Confirmation); ok {
		return x.Confirmation
	}
	return nil
}

func (m *CloseStatusUpdate) GetChanClose() *ChannelCloseUpdate {
	if x, ok := m.GetUpdate().(*CloseStatusUpdate_ChanClose); ok {
		return x.ChanClose
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CloseStatusUpdate) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CloseStatusUpdate_OneofMarshaler, _CloseStatusUpdate_OneofUnmarshaler, _CloseStatusUpdate_OneofSizer, []interface{}{
		(*CloseStatusUpdate_ClosePending)(nil),
		(*CloseStatusUpdate_Confirmation)(nil),
		(*CloseStatusUpdate_ChanClose)(nil),
	}
}

func _CloseStatusUpdate_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CloseStatusUpdate)
	// update
	switch x := m.Update.(type) {
	case *CloseStatusUpdate_ClosePending:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ClosePending); err != nil {
			return err
		}
	case *CloseStatusUpdate_Confirmation:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Confirmation); err != nil {
			return err
		}
	case *CloseStatusUpdate_ChanClose:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ChanClose); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CloseStatusUpdate.Update has unexpected type %T", x)
	}
	return nil
}

func _CloseStatusUpdate_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CloseStatusUpdate)
	switch tag {
	case 1: // update.close_pending
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PendingUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &CloseStatusUpdate_ClosePending{msg}
		return true, err
	case 2: // update.confirmation
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ConfirmationUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &CloseStatusUpdate_Confirmation{msg}
		return true, err
	case 3: // update.chan_close
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ChannelCloseUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &CloseStatusUpdate_ChanClose{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CloseStatusUpdate_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CloseStatusUpdate)
	// update
	switch x := m.Update.(type) {
	case *CloseStatusUpdate_ClosePending:
		s := proto.Size(x.ClosePending)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CloseStatusUpdate_Confirmation:
		s := proto.Size(x.Confirmation)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CloseStatusUpdate_ChanClose:
		s := proto.Size(x.ChanClose)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type PendingUpdate struct {
	Txid        []byte `protobuf:"bytes,1,opt,name=txid,proto3" json:"txid,omitempty"`
	OutputIndex uint32 `protobuf:"varint,2,opt,name=output_index" json:"output_index,omitempty"`
}

func (m *PendingUpdate) Reset()                    { *m = PendingUpdate{} }
func (m *PendingUpdate) String() string            { return proto.CompactTextString(m) }
func (*PendingUpdate) ProtoMessage()               {}
func (*PendingUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{49} }

func (m *PendingUpdate) GetTxid() []byte {
	if m != nil {
		return m.Txid
	}
	return nil
}

func (m *PendingUpdate) GetOutputIndex() uint32 {
	if m != nil {
		return m.OutputIndex
	}
	return 0
}

type OpenChannelRequest struct {
	// / The pubkey of the node to open a channel with
	NodePubkey []byte `protobuf:"bytes,2,opt,name=node_pubkey,proto3" json:"node_pubkey,omitempty"`
	// / The hex encoded pubkey of the node to open a channel with
	NodePubkeyString string `protobuf:"bytes,3,opt,name=node_pubkey_string" json:"node_pubkey_string,omitempty"`
	// / The number of satoshis the wallet should commit to the channel
	LocalFundingAmount int64 `protobuf:"varint,4,opt,name=local_funding_amount" json:"local_funding_amount,omitempty"`
	// / The number of satoshis to push to the remote side as part of the initial commitment state
	PushSat int64 `protobuf:"varint,5,opt,name=push_sat" json:"push_sat,omitempty"`
	// / The target number of blocks that the funding transaction should be confirmed by.
	TargetConf int32 `protobuf:"varint,6,opt,name=target_conf,json=targetConf" json:"target_conf,omitempty"`
	// / A manual fee rate set in sat/byte that should be used when crafting the funding transaction.
	SatPerByte int64 `protobuf:"varint,7,opt,name=sat_per_byte,json=satPerByte" json:"sat_per_byte,omitempty"`
	// / Whether this channel should be private, not announced to the greater network.
	Private bool `protobuf:"varint,8,opt,name=private" json:"private,omitempty"`
	// / The minimum value in millisatoshi we will require for incoming HTLCs on the channel.
	MinHtlcMsat int64 `protobuf:"varint,9,opt,name=min_htlc_msat" json:"min_htlc_msat,omitempty"`
	// / The delay we require on the remote's commitment transaction. If this is not set, it will be scaled automatically with the channel size.
	RemoteCsvDelay uint32 `protobuf:"varint,10,opt,name=remote_csv_delay" json:"remote_csv_delay,omitempty"`
}

func (m *OpenChannelRequest) Reset()                    { *m = OpenChannelRequest{} }
func (m *OpenChannelRequest) String() string            { return proto.CompactTextString(m) }
func (*OpenChannelRequest) ProtoMessage()               {}
func (*OpenChannelRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{50} }

func (m *OpenChannelRequest) GetNodePubkey() []byte {
	if m != nil {
		return m.NodePubkey
	}
	return nil
}

func (m *OpenChannelRequest) GetNodePubkeyString() string {
	if m != nil {
		return m.NodePubkeyString
	}
	return ""
}

func (m *OpenChannelRequest) GetLocalFundingAmount() int64 {
	if m != nil {
		return m.LocalFundingAmount
	}
	return 0
}

func (m *OpenChannelRequest) GetPushSat() int64 {
	if m != nil {
		return m.PushSat
	}
	return 0
}

func (m *OpenChannelRequest) GetTargetConf() int32 {
	if m != nil {
		return m.TargetConf
	}
	return 0
}

func (m *OpenChannelRequest) GetSatPerByte() int64 {
	if m != nil {
		return m.SatPerByte
	}
	return 0
}

func (m *OpenChannelRequest) GetPrivate() bool {
	if m != nil {
		return m.Private
	}
	return false
}

func (m *OpenChannelRequest) GetMinHtlcMsat() int64 {
	if m != nil {
		return m.MinHtlcMsat
	}
	return 0
}

func (m *OpenChannelRequest) GetRemoteCsvDelay() uint32 {
	if m != nil {
		return m.RemoteCsvDelay
	}
	return 0
}

type OpenStatusUpdate struct {
	// Types that are valid to be assigned to Update:
	//	*OpenStatusUpdate_ChanPending
	//	*OpenStatusUpdate_Confirmation
	//	*OpenStatusUpdate_ChanOpen
	Update isOpenStatusUpdate_Update `protobuf_oneof:"update"`
}

func (m *OpenStatusUpdate) Reset()                    { *m = OpenStatusUpdate{} }
func (m *OpenStatusUpdate) String() string            { return proto.CompactTextString(m) }
func (*OpenStatusUpdate) ProtoMessage()               {}
func (*OpenStatusUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{51} }

type isOpenStatusUpdate_Update interface{ isOpenStatusUpdate_Update() }

type OpenStatusUpdate_ChanPending struct {
	ChanPending *PendingUpdate `protobuf:"bytes,1,opt,name=chan_pending,oneof"`
}
type OpenStatusUpdate_Confirmation struct {
	Confirmation *ConfirmationUpdate `protobuf:"bytes,2,opt,name=confirmation,oneof"`
}
type OpenStatusUpdate_ChanOpen struct {
	ChanOpen *ChannelOpenUpdate `protobuf:"bytes,3,opt,name=chan_open,oneof"`
}

func (*OpenStatusUpdate_ChanPending) isOpenStatusUpdate_Update()  {}
func (*OpenStatusUpdate_Confirmation) isOpenStatusUpdate_Update() {}
func (*OpenStatusUpdate_ChanOpen) isOpenStatusUpdate_Update()     {}

func (m *OpenStatusUpdate) GetUpdate() isOpenStatusUpdate_Update {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *OpenStatusUpdate) GetChanPending() *PendingUpdate {
	if x, ok := m.GetUpdate().(*OpenStatusUpdate_ChanPending); ok {
		return x.ChanPending
	}
	return nil
}

func (m *OpenStatusUpdate) GetConfirmation() *ConfirmationUpdate {
	if x, ok := m.GetUpdate().(*OpenStatusUpdate_Confirmation); ok {
		return x.Confirmation
	}
	return nil
}

func (m *OpenStatusUpdate) GetChanOpen() *ChannelOpenUpdate {
	if x, ok := m.GetUpdate().(*OpenStatusUpdate_ChanOpen); ok {
		return x.ChanOpen
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*OpenStatusUpdate) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _OpenStatusUpdate_OneofMarshaler, _OpenStatusUpdate_OneofUnmarshaler, _OpenStatusUpdate_OneofSizer, []interface{}{
		(*OpenStatusUpdate_ChanPending)(nil),
		(*OpenStatusUpdate_Confirmation)(nil),
		(*OpenStatusUpdate_ChanOpen)(nil),
	}
}

func _OpenStatusUpdate_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*OpenStatusUpdate)
	// update
	switch x := m.Update.(type) {
	case *OpenStatusUpdate_ChanPending:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ChanPending); err != nil {
			return err
		}
	case *OpenStatusUpdate_Confirmation:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Confirmation); err != nil {
			return err
		}
	case *OpenStatusUpdate_ChanOpen:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ChanOpen); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("OpenStatusUpdate.Update has unexpected type %T", x)
	}
	return nil
}

func _OpenStatusUpdate_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*OpenStatusUpdate)
	switch tag {
	case 1: // update.chan_pending
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PendingUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &OpenStatusUpdate_ChanPending{msg}
		return true, err
	case 2: // update.confirmation
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ConfirmationUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &OpenStatusUpdate_Confirmation{msg}
		return true, err
	case 3: // update.chan_open
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ChannelOpenUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &OpenStatusUpdate_ChanOpen{msg}
		return true, err
	default:
		return false, nil
	}
}

func _OpenStatusUpdate_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*OpenStatusUpdate)
	// update
	switch x := m.Update.(type) {
	case *OpenStatusUpdate_ChanPending:
		s := proto.Size(x.ChanPending)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *OpenStatusUpdate_Confirmation:
		s := proto.Size(x.Confirmation)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *OpenStatusUpdate_ChanOpen:
		s := proto.Size(x.ChanOpen)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type PendingHTLC struct {
	// / The direction within the channel that the htlc was sent
	Incoming bool `protobuf:"varint,1,opt,name=incoming" json:"incoming,omitempty"`
	// / The total value of the htlc
	Amount int64 `protobuf:"varint,2,opt,name=amount" json:"amount,omitempty"`
	// / The final output to be swept back to the user's wallet
	Outpoint string `protobuf:"bytes,3,opt,name=outpoint" json:"outpoint,omitempty"`
	// / The next block height at which we can spend the current stage
	MaturityHeight uint32 `protobuf:"varint,4,opt,name=maturity_height" json:"maturity_height,omitempty"`
	// *
	// The number of blocks remaining until the current stage can be swept.
	// Negative values indicate how many blocks have passed since becoming
	// mature.
	BlocksTilMaturity int32 `protobuf:"varint,5,opt,name=blocks_til_maturity" json:"blocks_til_maturity,omitempty"`
	// / Indicates whether the htlc is in its first or second stage of recovery
	Stage uint32 `protobuf:"varint,6,opt,name=stage" json:"stage,omitempty"`
}

func (m *PendingHTLC) Reset()                    { *m = PendingHTLC{} }
func (m *PendingHTLC) String() string            { return proto.CompactTextString(m) }
func (*PendingHTLC) ProtoMessage()               {}
func (*PendingHTLC) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{52} }

func (m *PendingHTLC) GetIncoming() bool {
	if m != nil {
		return m.Incoming
	}
	return false
}

func (m *PendingHTLC) GetAmount() int64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *PendingHTLC) GetOutpoint() string {
	if m != nil {
		return m.Outpoint
	}
	return ""
}

func (m *PendingHTLC) GetMaturityHeight() uint32 {
	if m != nil {
		return m.MaturityHeight
	}
	return 0
}

func (m *PendingHTLC) GetBlocksTilMaturity() int32 {
	if m != nil {
		return m.BlocksTilMaturity
	}
	return 0
}

func (m *PendingHTLC) GetStage() uint32 {
	if m != nil {
		return m.Stage
	}
	return 0
}

type PendingChannelsRequest struct {
}

func (m *PendingChannelsRequest) Reset()                    { *m = PendingChannelsRequest{} }
func (m *PendingChannelsRequest) String() string            { return proto.CompactTextString(m) }
func (*PendingChannelsRequest) ProtoMessage()               {}
func (*PendingChannelsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{53} }

type PendingChannelsResponse struct {
	// / The balance in satoshis encumbered in pending channels
	TotalLimboBalance int64 `protobuf:"varint,1,opt,name=total_limbo_balance" json:"total_limbo_balance,omitempty"`
	// / Channels pending opening
	PendingOpenChannels []*PendingChannelsResponse_PendingOpenChannel `protobuf:"bytes,2,rep,name=pending_open_channels" json:"pending_open_channels,omitempty"`
	// / Channels pending closing
	PendingClosingChannels []*PendingChannelsResponse_ClosedChannel `protobuf:"bytes,3,rep,name=pending_closing_channels" json:"pending_closing_channels,omitempty"`
	// / Channels pending force closing
	PendingForceClosingChannels []*PendingChannelsResponse_ForceClosedChannel `protobuf:"bytes,4,rep,name=pending_force_closing_channels" json:"pending_force_closing_channels,omitempty"`
	// / Channels waiting for closing tx to confirm
	WaitingCloseChannels []*PendingChannelsResponse_WaitingCloseChannel `protobuf:"bytes,5,rep,name=waiting_close_channels" json:"waiting_close_channels,omitempty"`
}

func (m *PendingChannelsResponse) Reset()                    { *m = PendingChannelsResponse{} }
func (m *PendingChannelsResponse) String() string            { return proto.CompactTextString(m) }
func (*PendingChannelsResponse) ProtoMessage()               {}
func (*PendingChannelsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{54} }

func (m *PendingChannelsResponse) GetTotalLimboBalance() int64 {
	if m != nil {
		return m.TotalLimboBalance
	}
	return 0
}

func (m *PendingChannelsResponse) GetPendingOpenChannels() []*PendingChannelsResponse_PendingOpenChannel {
	if m != nil {
		return m.PendingOpenChannels
	}
	return nil
}

func (m *PendingChannelsResponse) GetPendingClosingChannels() []*PendingChannelsResponse_ClosedChannel {
	if m != nil {
		return m.PendingClosingChannels
	}
	return nil
}

func (m *PendingChannelsResponse) GetPendingForceClosingChannels() []*PendingChannelsResponse_ForceClosedChannel {
	if m != nil {
		return m.PendingForceClosingChannels
	}
	return nil
}

func (m *PendingChannelsResponse) GetWaitingCloseChannels() []*PendingChannelsResponse_WaitingCloseChannel {
	if m != nil {
		return m.WaitingCloseChannels
	}
	return nil
}

type PendingChannelsResponse_PendingChannel struct {
	RemoteNodePub string `protobuf:"bytes,1,opt,name=remote_node_pub" json:"remote_node_pub,omitempty"`
	ChannelPoint  string `protobuf:"bytes,2,opt,name=channel_point" json:"channel_point,omitempty"`
	Capacity      int64  `protobuf:"varint,3,opt,name=capacity" json:"capacity,omitempty"`
	LocalBalance  int64  `protobuf:"varint,4,opt,name=local_balance" json:"local_balance,omitempty"`
	RemoteBalance int64  `protobuf:"varint,5,opt,name=remote_balance" json:"remote_balance,omitempty"`
}

func (m *PendingChannelsResponse_PendingChannel) Reset() {
	*m = PendingChannelsResponse_PendingChannel{}
}
func (m *PendingChannelsResponse_PendingChannel) String() string { return proto.CompactTextString(m) }
func (*PendingChannelsResponse_PendingChannel) ProtoMessage()    {}
func (*PendingChannelsResponse_PendingChannel) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{54, 0}
}

func (m *PendingChannelsResponse_PendingChannel) GetRemoteNodePub() string {
	if m != nil {
		return m.RemoteNodePub
	}
	return ""
}

func (m *PendingChannelsResponse_PendingChannel) GetChannelPoint() string {
	if m != nil {
		return m.ChannelPoint
	}
	return ""
}

func (m *PendingChannelsResponse_PendingChannel) GetCapacity() int64 {
	if m != nil {
		return m.Capacity
	}
	return 0
}

func (m *PendingChannelsResponse_PendingChannel) GetLocalBalance() int64 {
	if m != nil {
		return m.LocalBalance
	}
	return 0
}

func (m *PendingChannelsResponse_PendingChannel) GetRemoteBalance() int64 {
	if m != nil {
		return m.RemoteBalance
	}
	return 0
}

type PendingChannelsResponse_PendingOpenChannel struct {
	// / The pending channel
	Channel *PendingChannelsResponse_PendingChannel `protobuf:"bytes,1,opt,name=channel" json:"channel,omitempty"`
	// / The height at which this channel will be confirmed
	ConfirmationHeight uint32 `protobuf:"varint,2,opt,name=confirmation_height" json:"confirmation_height,omitempty"`
	// *
	// The amount calculated to be paid in fees for the current set of
	// commitment transactions. The fee amount is persisted with the channel
	// in order to allow the fee amount to be removed and recalculated with
	// each channel state update, including updates that happen after a system
	// restart.
	CommitFee int64 `protobuf:"varint,4,opt,name=commit_fee" json:"commit_fee,omitempty"`
	// / The weight of the commitment transaction
	CommitWeight int64 `protobuf:"varint,5,opt,name=commit_weight" json:"commit_weight,omitempty"`
	// *
	// The required number of satoshis per kilo-weight that the requester will
	// pay at all times, for both the funding transaction and commitment
	// transaction. This value can later be updated once the channel is open.
	FeePerKw int64 `protobuf:"varint,6,opt,name=fee_per_kw" json:"fee_per_kw,omitempty"`
}

func (m *PendingChannelsResponse_PendingOpenChannel) Reset() {
	*m = PendingChannelsResponse_PendingOpenChannel{}
}
func (m *PendingChannelsResponse_PendingOpenChannel) String() string {
	return proto.CompactTextString(m)
}
func (*PendingChannelsResponse_PendingOpenChannel) ProtoMessage() {}
func (*PendingChannelsResponse_PendingOpenChannel) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{54, 1}
}

func (m *PendingChannelsResponse_PendingOpenChannel) GetChannel() *PendingChannelsResponse_PendingChannel {
	if m != nil {
		return m.Channel
	}
	return nil
}

func (m *PendingChannelsResponse_PendingOpenChannel) GetConfirmationHeight() uint32 {
	if m != nil {
		return m.ConfirmationHeight
	}
	return 0
}

func (m *PendingChannelsResponse_PendingOpenChannel) GetCommitFee() int64 {
	if m != nil {
		return m.CommitFee
	}
	return 0
}

func (m *PendingChannelsResponse_PendingOpenChannel) GetCommitWeight() int64 {
	if m != nil {
		return m.CommitWeight
	}
	return 0
}

func (m *PendingChannelsResponse_PendingOpenChannel) GetFeePerKw() int64 {
	if m != nil {
		return m.FeePerKw
	}
	return 0
}

type PendingChannelsResponse_WaitingCloseChannel struct {
	// / The pending channel waiting for closing tx to confirm
	Channel *PendingChannelsResponse_PendingChannel `protobuf:"bytes,1,opt,name=channel" json:"channel,omitempty"`
	// / The balance in satoshis encumbered in this channel
	LimboBalance int64 `protobuf:"varint,2,opt,name=limbo_balance" json:"limbo_balance,omitempty"`
}

func (m *PendingChannelsResponse_WaitingCloseChannel) Reset() {
	*m = PendingChannelsResponse_WaitingCloseChannel{}
}
func (m *PendingChannelsResponse_WaitingCloseChannel) String() string {
	return proto.CompactTextString(m)
}
func (*PendingChannelsResponse_WaitingCloseChannel) ProtoMessage() {}
func (*PendingChannelsResponse_WaitingCloseChannel) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{54, 2}
}

func (m *PendingChannelsResponse_WaitingCloseChannel) GetChannel() *PendingChannelsResponse_PendingChannel {
	if m != nil {
		return m.Channel
	}
	return nil
}

func (m *PendingChannelsResponse_WaitingCloseChannel) GetLimboBalance() int64 {
	if m != nil {
		return m.LimboBalance
	}
	return 0
}

type PendingChannelsResponse_ClosedChannel struct {
	// / The pending channel to be closed
	Channel *PendingChannelsResponse_PendingChannel `protobuf:"bytes,1,opt,name=channel" json:"channel,omitempty"`
	// / The transaction id of the closing transaction
	ClosingTxid string `protobuf:"bytes,2,opt,name=closing_txid" json:"closing_txid,omitempty"`
}

func (m *PendingChannelsResponse_ClosedChannel) Reset()         { *m = PendingChannelsResponse_ClosedChannel{} }
func (m *PendingChannelsResponse_ClosedChannel) String() string { return proto.CompactTextString(m) }
func (*PendingChannelsResponse_ClosedChannel) ProtoMessage()    {}
func (*PendingChannelsResponse_ClosedChannel) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{54, 3}
}

func (m *PendingChannelsResponse_ClosedChannel) GetChannel() *PendingChannelsResponse_PendingChannel {
	if m != nil {
		return m.Channel
	}
	return nil
}

func (m *PendingChannelsResponse_ClosedChannel) GetClosingTxid() string {
	if m != nil {
		return m.ClosingTxid
	}
	return ""
}

type PendingChannelsResponse_ForceClosedChannel struct {
	// / The pending channel to be force closed
	Channel *PendingChannelsResponse_PendingChannel `protobuf:"bytes,1,opt,name=channel" json:"channel,omitempty"`
	// / The transaction id of the closing transaction
	ClosingTxid string `protobuf:"bytes,2,opt,name=closing_txid" json:"closing_txid,omitempty"`
	// / The balance in satoshis encumbered in this pending channel
	LimboBalance int64 `protobuf:"varint,3,opt,name=limbo_balance" json:"limbo_balance,omitempty"`
	// / The height at which funds can be sweeped into the wallet
	MaturityHeight uint32 `protobuf:"varint,4,opt,name=maturity_height" json:"maturity_height,omitempty"`
	//
	// Remaining # of blocks until the commitment output can be swept.
	// Negative values indicate how many blocks have passed since becoming
	// mature.
	BlocksTilMaturity int32 `protobuf:"varint,5,opt,name=blocks_til_maturity" json:"blocks_til_maturity,omitempty"`
	// / The total value of funds successfully recovered from this channel
	RecoveredBalance int64          `protobuf:"varint,6,opt,name=recovered_balance" json:"recovered_balance,omitempty"`
	PendingHtlcs     []*PendingHTLC `protobuf:"bytes,8,rep,name=pending_htlcs" json:"pending_htlcs,omitempty"`
}

func (m *PendingChannelsResponse_ForceClosedChannel) Reset() {
	*m = PendingChannelsResponse_ForceClosedChannel{}
}
func (m *PendingChannelsResponse_ForceClosedChannel) String() string {
	return proto.CompactTextString(m)
}
func (*PendingChannelsResponse_ForceClosedChannel) ProtoMessage() {}
func (*PendingChannelsResponse_ForceClosedChannel) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{54, 4}
}

func (m *PendingChannelsResponse_ForceClosedChannel) GetChannel() *PendingChannelsResponse_PendingChannel {
	if m != nil {
		return m.Channel
	}
	return nil
}

func (m *PendingChannelsResponse_ForceClosedChannel) GetClosingTxid() string {
	if m != nil {
		return m.ClosingTxid
	}
	return ""
}

func (m *PendingChannelsResponse_ForceClosedChannel) GetLimboBalance() int64 {
	if m != nil {
		return m.LimboBalance
	}
	return 0
}

func (m *PendingChannelsResponse_ForceClosedChannel) GetMaturityHeight() uint32 {
	if m != nil {
		return m.MaturityHeight
	}
	return 0
}

func (m *PendingChannelsResponse_ForceClosedChannel) GetBlocksTilMaturity() int32 {
	if m != nil {
		return m.BlocksTilMaturity
	}
	return 0
}

func (m *PendingChannelsResponse_ForceClosedChannel) GetRecoveredBalance() int64 {
	if m != nil {
		return m.RecoveredBalance
	}
	return 0
}

func (m *PendingChannelsResponse_ForceClosedChannel) GetPendingHtlcs() []*PendingHTLC {
	if m != nil {
		return m.PendingHtlcs
	}
	return nil
}

type WalletBalanceRequest struct {
}

func (m *WalletBalanceRequest) Reset()                    { *m = WalletBalanceRequest{} }
func (m *WalletBalanceRequest) String() string            { return proto.CompactTextString(m) }
func (*WalletBalanceRequest) ProtoMessage()               {}
func (*WalletBalanceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{55} }

type WalletBalanceResponse struct {
	// / The balance of the wallet
	TotalBalance int64 `protobuf:"varint,1,opt,name=total_balance" json:"total_balance,omitempty"`
	// / The confirmed balance of a wallet(with >= 1 confirmations)
	ConfirmedBalance int64 `protobuf:"varint,2,opt,name=confirmed_balance" json:"confirmed_balance,omitempty"`
	// / The unconfirmed balance of a wallet(with 0 confirmations)
	UnconfirmedBalance int64 `protobuf:"varint,3,opt,name=unconfirmed_balance" json:"unconfirmed_balance,omitempty"`
}

func (m *WalletBalanceResponse) Reset()                    { *m = WalletBalanceResponse{} }
func (m *WalletBalanceResponse) String() string            { return proto.CompactTextString(m) }
func (*WalletBalanceResponse) ProtoMessage()               {}
func (*WalletBalanceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{56} }

func (m *WalletBalanceResponse) GetTotalBalance() int64 {
	if m != nil {
		return m.TotalBalance
	}
	return 0
}

func (m *WalletBalanceResponse) GetConfirmedBalance() int64 {
	if m != nil {
		return m.ConfirmedBalance
	}
	return 0
}

func (m *WalletBalanceResponse) GetUnconfirmedBalance() int64 {
	if m != nil {
		return m.UnconfirmedBalance
	}
	return 0
}

type ChannelBalanceRequest struct {
}

func (m *ChannelBalanceRequest) Reset()                    { *m = ChannelBalanceRequest{} }
func (m *ChannelBalanceRequest) String() string            { return proto.CompactTextString(m) }
func (*ChannelBalanceRequest) ProtoMessage()               {}
func (*ChannelBalanceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{57} }

type ChannelBalanceResponse struct {
	// / Sum of channels balances denominated in satoshis
	Balance int64 `protobuf:"varint,1,opt,name=balance" json:"balance,omitempty"`
	// / Sum of channels pending balances denominated in satoshis
	PendingOpenBalance int64 `protobuf:"varint,2,opt,name=pending_open_balance" json:"pending_open_balance,omitempty"`
}

func (m *ChannelBalanceResponse) Reset()                    { *m = ChannelBalanceResponse{} }
func (m *ChannelBalanceResponse) String() string            { return proto.CompactTextString(m) }
func (*ChannelBalanceResponse) ProtoMessage()               {}
func (*ChannelBalanceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{58} }

func (m *ChannelBalanceResponse) GetBalance() int64 {
	if m != nil {
		return m.Balance
	}
	return 0
}

func (m *ChannelBalanceResponse) GetPendingOpenBalance() int64 {
	if m != nil {
		return m.PendingOpenBalance
	}
	return 0
}

type QueryRoutesRequest struct {
	// / The 33-byte hex-encoded public key for the payment destination
	PubKey string `protobuf:"bytes,1,opt,name=pub_key,json=pubKey" json:"pub_key,omitempty"`
	// / The amount to send expressed in satoshis
	Amt int64 `protobuf:"varint,2,opt,name=amt" json:"amt,omitempty"`
	// / The max number of routes to return.
	NumRoutes int32 `protobuf:"varint,3,opt,name=num_routes,json=numRoutes" json:"num_routes,omitempty"`
	// / An optional CLTV delta from the current height that should be used for the timelock of the final hop
	FinalCltvDelta int32 `protobuf:"varint,4,opt,name=final_cltv_delta,json=finalCltvDelta" json:"final_cltv_delta,omitempty"`
	// *
	// The maximum number of satoshis that will be paid as a fee of the payment.
	// This value can be represented either as a percentage of the amount being
	// sent, or as a fixed amount of the maximum fee the user is willing the pay to
	// send the payment.
	FeeLimit *FeeLimit `protobuf:"bytes,5,opt,name=fee_limit,json=feeLimit" json:"fee_limit,omitempty"`
}

func (m *QueryRoutesRequest) Reset()                    { *m = QueryRoutesRequest{} }
func (m *QueryRoutesRequest) String() string            { return proto.CompactTextString(m) }
func (*QueryRoutesRequest) ProtoMessage()               {}
func (*QueryRoutesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{59} }

func (m *QueryRoutesRequest) GetPubKey() string {
	if m != nil {
		return m.PubKey
	}
	return ""
}

func (m *QueryRoutesRequest) GetAmt() int64 {
	if m != nil {
		return m.Amt
	}
	return 0
}

func (m *QueryRoutesRequest) GetNumRoutes() int32 {
	if m != nil {
		return m.NumRoutes
	}
	return 0
}

func (m *QueryRoutesRequest) GetFinalCltvDelta() int32 {
	if m != nil {
		return m.FinalCltvDelta
	}
	return 0
}

func (m *QueryRoutesRequest) GetFeeLimit() *FeeLimit {
	if m != nil {
		return m.FeeLimit
	}
	return nil
}

type QueryRoutesResponse struct {
	Routes []*Route `protobuf:"bytes,1,rep,name=routes" json:"routes,omitempty"`
}

func (m *QueryRoutesResponse) Reset()                    { *m = QueryRoutesResponse{} }
func (m *QueryRoutesResponse) String() string            { return proto.CompactTextString(m) }
func (*QueryRoutesResponse) ProtoMessage()               {}
func (*QueryRoutesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{60} }

func (m *QueryRoutesResponse) GetRoutes() []*Route {
	if m != nil {
		return m.Routes
	}
	return nil
}

type Hop struct {
	// *
	// The unique channel ID for the channel. The first 3 bytes are the block
	// height, the next 3 the index within the block, and the last 2 bytes are the
	// output index for the channel.
	ChanId           uint64 `protobuf:"varint,1,opt,name=chan_id" json:"chan_id,omitempty"`
	ChanCapacity     int64  `protobuf:"varint,2,opt,name=chan_capacity" json:"chan_capacity,omitempty"`
	AmtToForward     int64  `protobuf:"varint,3,opt,name=amt_to_forward" json:"amt_to_forward,omitempty"`
	Fee              int64  `protobuf:"varint,4,opt,name=fee" json:"fee,omitempty"`
	Expiry           uint32 `protobuf:"varint,5,opt,name=expiry" json:"expiry,omitempty"`
	AmtToForwardMsat int64  `protobuf:"varint,6,opt,name=amt_to_forward_msat" json:"amt_to_forward_msat,omitempty"`
	FeeMsat          int64  `protobuf:"varint,7,opt,name=fee_msat" json:"fee_msat,omitempty"`
}

func (m *Hop) Reset()                    { *m = Hop{} }
func (m *Hop) String() string            { return proto.CompactTextString(m) }
func (*Hop) ProtoMessage()               {}
func (*Hop) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{61} }

func (m *Hop) GetChanId() uint64 {
	if m != nil {
		return m.ChanId
	}
	return 0
}

func (m *Hop) GetChanCapacity() int64 {
	if m != nil {
		return m.ChanCapacity
	}
	return 0
}

func (m *Hop) GetAmtToForward() int64 {
	if m != nil {
		return m.AmtToForward
	}
	return 0
}

func (m *Hop) GetFee() int64 {
	if m != nil {
		return m.Fee
	}
	return 0
}

func (m *Hop) GetExpiry() uint32 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func (m *Hop) GetAmtToForwardMsat() int64 {
	if m != nil {
		return m.AmtToForwardMsat
	}
	return 0
}

func (m *Hop) GetFeeMsat() int64 {
	if m != nil {
		return m.FeeMsat
	}
	return 0
}

// *
// A path through the channel graph which runs over one or more channels in
// succession. This struct carries all the information required to craft the
// Sphinx onion packet, and send the payment along the first hop in the path. A
// route is only selected as valid if all the channels have sufficient capacity to
// carry the initial payment amount after fees are accounted for.
type Route struct {
	// *
	// The cumulative (final) time lock across the entire route.  This is the CLTV
	// value that should be extended to the first hop in the route. All other hops
	// will decrement the time-lock as advertised, leaving enough time for all
	// hops to wait for or present the payment preimage to complete the payment.
	TotalTimeLock uint32 `protobuf:"varint,1,opt,name=total_time_lock" json:"total_time_lock,omitempty"`
	// *
	// The sum of the fees paid at each hop within the final route.  In the case
	// of a one-hop payment, this value will be zero as we don't need to pay a fee
	// it ourself.
	TotalFees int64 `protobuf:"varint,2,opt,name=total_fees" json:"total_fees,omitempty"`
	// *
	// The total amount of funds required to complete a payment over this route.
	// This value includes the cumulative fees at each hop. As a result, the HTLC
	// extended to the first-hop in the route will need to have at least this many
	// satoshis, otherwise the route will fail at an intermediate node due to an
	// insufficient amount of fees.
	TotalAmt int64 `protobuf:"varint,3,opt,name=total_amt" json:"total_amt,omitempty"`
	// *
	// Contains details concerning the specific forwarding details at each hop.
	Hops []*Hop `protobuf:"bytes,4,rep,name=hops" json:"hops,omitempty"`
	// *
	// The total fees in millisatoshis.
	TotalFeesMsat int64 `protobuf:"varint,5,opt,name=total_fees_msat" json:"total_fees_msat,omitempty"`
	// *
	// The total amount in millisatoshis.
	TotalAmtMsat int64 `protobuf:"varint,6,opt,name=total_amt_msat" json:"total_amt_msat,omitempty"`
}

func (m *Route) Reset()                    { *m = Route{} }
func (m *Route) String() string            { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()               {}
func (*Route) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{62} }

func (m *Route) GetTotalTimeLock() uint32 {
	if m != nil {
		return m.TotalTimeLock
	}
	return 0
}

func (m *Route) GetTotalFees() int64 {
	if m != nil {
		return m.TotalFees
	}
	return 0
}

func (m *Route) GetTotalAmt() int64 {
	if m != nil {
		return m.TotalAmt
	}
	return 0
}

func (m *Route) GetHops() []*Hop {
	if m != nil {
		return m.Hops
	}
	return nil
}

func (m *Route) GetTotalFeesMsat() int64 {
	if m != nil {
		return m.TotalFeesMsat
	}
	return 0
}

func (m *Route) GetTotalAmtMsat() int64 {
	if m != nil {
		return m.TotalAmtMsat
	}
	return 0
}

type NodeInfoRequest struct {
	// / The 33-byte hex-encoded compressed public of the target node
	PubKey string `protobuf:"bytes,1,opt,name=pub_key,json=pubKey" json:"pub_key,omitempty"`
}

func (m *NodeInfoRequest) Reset()                    { *m = NodeInfoRequest{} }
func (m *NodeInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*NodeInfoRequest) ProtoMessage()               {}
func (*NodeInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{63} }

func (m *NodeInfoRequest) GetPubKey() string {
	if m != nil {
		return m.PubKey
	}
	return ""
}

type NodeInfo struct {
	// *
	// An individual vertex/node within the channel graph. A node is
	// connected to other nodes by one or more channel edges emanating from it. As
	// the graph is directed, a node will also have an incoming edge attached to
	// it for each outgoing edge.
	Node          *LightningNode `protobuf:"bytes,1,opt,name=node" json:"node,omitempty"`
	NumChannels   uint32         `protobuf:"varint,2,opt,name=num_channels" json:"num_channels,omitempty"`
	TotalCapacity int64          `protobuf:"varint,3,opt,name=total_capacity" json:"total_capacity,omitempty"`
}

func (m *NodeInfo) Reset()                    { *m = NodeInfo{} }
func (m *NodeInfo) String() string            { return proto.CompactTextString(m) }
func (*NodeInfo) ProtoMessage()               {}
func (*NodeInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{64} }

func (m *NodeInfo) GetNode() *LightningNode {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *NodeInfo) GetNumChannels() uint32 {
	if m != nil {
		return m.NumChannels
	}
	return 0
}

func (m *NodeInfo) GetTotalCapacity() int64 {
	if m != nil {
		return m.TotalCapacity
	}
	return 0
}

// *
// An individual vertex/node within the channel graph. A node is
// connected to other nodes by one or more channel edges emanating from it. As the
// graph is directed, a node will also have an incoming edge attached to it for
// each outgoing edge.
type LightningNode struct {
	LastUpdate uint32         `protobuf:"varint,1,opt,name=last_update" json:"last_update,omitempty"`
	PubKey     string         `protobuf:"bytes,2,opt,name=pub_key" json:"pub_key,omitempty"`
	Alias      string         `protobuf:"bytes,3,opt,name=alias" json:"alias,omitempty"`
	Addresses  []*NodeAddress `protobuf:"bytes,4,rep,name=addresses" json:"addresses,omitempty"`
	Color      string         `protobuf:"bytes,5,opt,name=color" json:"color,omitempty"`
}

func (m *LightningNode) Reset()                    { *m = LightningNode{} }
func (m *LightningNode) String() string            { return proto.CompactTextString(m) }
func (*LightningNode) ProtoMessage()               {}
func (*LightningNode) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{65} }

func (m *LightningNode) GetLastUpdate() uint32 {
	if m != nil {
		return m.LastUpdate
	}
	return 0
}

func (m *LightningNode) GetPubKey() string {
	if m != nil {
		return m.PubKey
	}
	return ""
}

func (m *LightningNode) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

func (m *LightningNode) GetAddresses() []*NodeAddress {
	if m != nil {
		return m.Addresses
	}
	return nil
}

func (m *LightningNode) GetColor() string {
	if m != nil {
		return m.Color
	}
	return ""
}

type NodeAddress struct {
	Network string `protobuf:"bytes,1,opt,name=network" json:"network,omitempty"`
	Addr    string `protobuf:"bytes,2,opt,name=addr" json:"addr,omitempty"`
}

func (m *NodeAddress) Reset()                    { *m = NodeAddress{} }
func (m *NodeAddress) String() string            { return proto.CompactTextString(m) }
func (*NodeAddress) ProtoMessage()               {}
func (*NodeAddress) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{66} }

func (m *NodeAddress) GetNetwork() string {
	if m != nil {
		return m.Network
	}
	return ""
}

func (m *NodeAddress) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type RoutingPolicy struct {
	TimeLockDelta    uint32 `protobuf:"varint,1,opt,name=time_lock_delta" json:"time_lock_delta,omitempty"`
	MinHtlc          int64  `protobuf:"varint,2,opt,name=min_htlc" json:"min_htlc,omitempty"`
	FeeBaseMsat      int64  `protobuf:"varint,3,opt,name=fee_base_msat" json:"fee_base_msat,omitempty"`
	FeeRateMilliMsat int64  `protobuf:"varint,4,opt,name=fee_rate_milli_msat" json:"fee_rate_milli_msat,omitempty"`
	Disabled         bool   `protobuf:"varint,5,opt,name=disabled" json:"disabled,omitempty"`
}

func (m *RoutingPolicy) Reset()                    { *m = RoutingPolicy{} }
func (m *RoutingPolicy) String() string            { return proto.CompactTextString(m) }
func (*RoutingPolicy) ProtoMessage()               {}
func (*RoutingPolicy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{67} }

func (m *RoutingPolicy) GetTimeLockDelta() uint32 {
	if m != nil {
		return m.TimeLockDelta
	}
	return 0
}

func (m *RoutingPolicy) GetMinHtlc() int64 {
	if m != nil {
		return m.MinHtlc
	}
	return 0
}

func (m *RoutingPolicy) GetFeeBaseMsat() int64 {
	if m != nil {
		return m.FeeBaseMsat
	}
	return 0
}

func (m *RoutingPolicy) GetFeeRateMilliMsat() int64 {
	if m != nil {
		return m.FeeRateMilliMsat
	}
	return 0
}

func (m *RoutingPolicy) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

// *
// A fully authenticated channel along with all its unique attributes.
// Once an authenticated channel announcement has been processed on the network,
// then an instance of ChannelEdgeInfo encapsulating the channels attributes is
// stored. The other portions relevant to routing policy of a channel are stored
// within a ChannelEdgePolicy for each direction of the channel.
type ChannelEdge struct {
	// *
	// The unique channel ID for the channel. The first 3 bytes are the block
	// height, the next 3 the index within the block, and the last 2 bytes are the
	// output index for the channel.
	ChannelId   uint64         `protobuf:"varint,1,opt,name=channel_id" json:"channel_id,omitempty"`
	ChanPoint   string         `protobuf:"bytes,2,opt,name=chan_point" json:"chan_point,omitempty"`
	LastUpdate  uint32         `protobuf:"varint,3,opt,name=last_update" json:"last_update,omitempty"`
	Node1Pub    string         `protobuf:"bytes,4,opt,name=node1_pub" json:"node1_pub,omitempty"`
	Node2Pub    string         `protobuf:"bytes,5,opt,name=node2_pub" json:"node2_pub,omitempty"`
	Capacity    int64          `protobuf:"varint,6,opt,name=capacity" json:"capacity,omitempty"`
	Node1Policy *RoutingPolicy `protobuf:"bytes,7,opt,name=node1_policy" json:"node1_policy,omitempty"`
	Node2Policy *RoutingPolicy `protobuf:"bytes,8,opt,name=node2_policy" json:"node2_policy,omitempty"`
}

func (m *ChannelEdge) Reset()                    { *m = ChannelEdge{} }
func (m *ChannelEdge) String() string            { return proto.CompactTextString(m) }
func (*ChannelEdge) ProtoMessage()               {}
func (*ChannelEdge) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{68} }

func (m *ChannelEdge) GetChannelId() uint64 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *ChannelEdge) GetChanPoint() string {
	if m != nil {
		return m.ChanPoint
	}
	return ""
}

func (m *ChannelEdge) GetLastUpdate() uint32 {
	if m != nil {
		return m.LastUpdate
	}
	return 0
}

func (m *ChannelEdge) GetNode1Pub() string {
	if m != nil {
		return m.Node1Pub
	}
	return ""
}

func (m *ChannelEdge) GetNode2Pub() string {
	if m != nil {
		return m.Node2Pub
	}
	return ""
}

func (m *ChannelEdge) GetCapacity() int64 {
	if m != nil {
		return m.Capacity
	}
	return 0
}

func (m *ChannelEdge) GetNode1Policy() *RoutingPolicy {
	if m != nil {
		return m.Node1Policy
	}
	return nil
}

func (m *ChannelEdge) GetNode2Policy() *RoutingPolicy {
	if m != nil {
		return m.Node2Policy
	}
	return nil
}

type ChannelGraphRequest struct {
}

func (m *ChannelGraphRequest) Reset()                    { *m = ChannelGraphRequest{} }
func (m *ChannelGraphRequest) String() string            { return proto.CompactTextString(m) }
func (*ChannelGraphRequest) ProtoMessage()               {}
func (*ChannelGraphRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{69} }

// / Returns a new instance of the directed channel graph.
type ChannelGraph struct {
	// / The list of `LightningNode`s in this channel graph
	Nodes []*LightningNode `protobuf:"bytes,1,rep,name=nodes" json:"nodes,omitempty"`
	// / The list of `ChannelEdge`s in this channel graph
	Edges []*ChannelEdge `protobuf:"bytes,2,rep,name=edges" json:"edges,omitempty"`
}

func (m *ChannelGraph) Reset()                    { *m = ChannelGraph{} }
func (m *ChannelGraph) String() string            { return proto.CompactTextString(m) }
func (*ChannelGraph) ProtoMessage()               {}
func (*ChannelGraph) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{70} }

func (m *ChannelGraph) GetNodes() []*LightningNode {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *ChannelGraph) GetEdges() []*ChannelEdge {
	if m != nil {
		return m.Edges
	}
	return nil
}

type ChanInfoRequest struct {
	// *
	// The unique channel ID for the channel. The first 3 bytes are the block
	// height, the next 3 the index within the block, and the last 2 bytes are the
	// output index for the channel.
	ChanId uint64 `protobuf:"varint,1,opt,name=chan_id,json=chanId" json:"chan_id,omitempty"`
}

func (m *ChanInfoRequest) Reset()                    { *m = ChanInfoRequest{} }
func (m *ChanInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*ChanInfoRequest) ProtoMessage()               {}
func (*ChanInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{71} }

func (m *ChanInfoRequest) GetChanId() uint64 {
	if m != nil {
		return m.ChanId
	}
	return 0
}

type NetworkInfoRequest struct {
}

func (m *NetworkInfoRequest) Reset()                    { *m = NetworkInfoRequest{} }
func (m *NetworkInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*NetworkInfoRequest) ProtoMessage()               {}
func (*NetworkInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{72} }

type NetworkInfo struct {
	GraphDiameter        uint32  `protobuf:"varint,1,opt,name=graph_diameter" json:"graph_diameter,omitempty"`
	AvgOutDegree         float64 `protobuf:"fixed64,2,opt,name=avg_out_degree" json:"avg_out_degree,omitempty"`
	MaxOutDegree         uint32  `protobuf:"varint,3,opt,name=max_out_degree" json:"max_out_degree,omitempty"`
	NumNodes             uint32  `protobuf:"varint,4,opt,name=num_nodes" json:"num_nodes,omitempty"`
	NumChannels          uint32  `protobuf:"varint,5,opt,name=num_channels" json:"num_channels,omitempty"`
	TotalNetworkCapacity int64   `protobuf:"varint,6,opt,name=total_network_capacity" json:"total_network_capacity,omitempty"`
	AvgChannelSize       float64 `protobuf:"fixed64,7,opt,name=avg_channel_size" json:"avg_channel_size,omitempty"`
	MinChannelSize       int64   `protobuf:"varint,8,opt,name=min_channel_size" json:"min_channel_size,omitempty"`
	MaxChannelSize       int64   `protobuf:"varint,9,opt,name=max_channel_size" json:"max_channel_size,omitempty"`
}

func (m *NetworkInfo) Reset()                    { *m = NetworkInfo{} }
func (m *NetworkInfo) String() string            { return proto.CompactTextString(m) }
func (*NetworkInfo) ProtoMessage()               {}
func (*NetworkInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{73} }

func (m *NetworkInfo) GetGraphDiameter() uint32 {
	if m != nil {
		return m.GraphDiameter
	}
	return 0
}

func (m *NetworkInfo) GetAvgOutDegree() float64 {
	if m != nil {
		return m.AvgOutDegree
	}
	return 0
}

func (m *NetworkInfo) GetMaxOutDegree() uint32 {
	if m != nil {
		return m.MaxOutDegree
	}
	return 0
}

func (m *NetworkInfo) GetNumNodes() uint32 {
	if m != nil {
		return m.NumNodes
	}
	return 0
}

func (m *NetworkInfo) GetNumChannels() uint32 {
	if m != nil {
		return m.NumChannels
	}
	return 0
}

func (m *NetworkInfo) GetTotalNetworkCapacity() int64 {
	if m != nil {
		return m.TotalNetworkCapacity
	}
	return 0
}

func (m *NetworkInfo) GetAvgChannelSize() float64 {
	if m != nil {
		return m.AvgChannelSize
	}
	return 0
}

func (m *NetworkInfo) GetMinChannelSize() int64 {
	if m != nil {
		return m.MinChannelSize
	}
	return 0
}

func (m *NetworkInfo) GetMaxChannelSize() int64 {
	if m != nil {
		return m.MaxChannelSize
	}
	return 0
}

type StopRequest struct {
}

func (m *StopRequest) Reset()                    { *m = StopRequest{} }
func (m *StopRequest) String() string            { return proto.CompactTextString(m) }
func (*StopRequest) ProtoMessage()               {}
func (*StopRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{74} }

type StopResponse struct {
}

func (m *StopResponse) Reset()                    { *m = StopResponse{} }
func (m *StopResponse) String() string            { return proto.CompactTextString(m) }
func (*StopResponse) ProtoMessage()               {}
func (*StopResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{75} }

type GraphTopologySubscription struct {
}

func (m *GraphTopologySubscription) Reset()                    { *m = GraphTopologySubscription{} }
func (m *GraphTopologySubscription) String() string            { return proto.CompactTextString(m) }
func (*GraphTopologySubscription) ProtoMessage()               {}
func (*GraphTopologySubscription) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{76} }

type GraphTopologyUpdate struct {
	NodeUpdates    []*NodeUpdate          `protobuf:"bytes,1,rep,name=node_updates,json=nodeUpdates" json:"node_updates,omitempty"`
	ChannelUpdates []*ChannelEdgeUpdate   `protobuf:"bytes,2,rep,name=channel_updates,json=channelUpdates" json:"channel_updates,omitempty"`
	ClosedChans    []*ClosedChannelUpdate `protobuf:"bytes,3,rep,name=closed_chans,json=closedChans" json:"closed_chans,omitempty"`
}

func (m *GraphTopologyUpdate) Reset()                    { *m = GraphTopologyUpdate{} }
func (m *GraphTopologyUpdate) String() string            { return proto.CompactTextString(m) }
func (*GraphTopologyUpdate) ProtoMessage()               {}
func (*GraphTopologyUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{77} }

func (m *GraphTopologyUpdate) GetNodeUpdates() []*NodeUpdate {
	if m != nil {
		return m.NodeUpdates
	}
	return nil
}

func (m *GraphTopologyUpdate) GetChannelUpdates() []*ChannelEdgeUpdate {
	if m != nil {
		return m.ChannelUpdates
	}
	return nil
}

func (m *GraphTopologyUpdate) GetClosedChans() []*ClosedChannelUpdate {
	if m != nil {
		return m.ClosedChans
	}
	return nil
}

type NodeUpdate struct {
	Addresses      []string `protobuf:"bytes,1,rep,name=addresses" json:"addresses,omitempty"`
	IdentityKey    string   `protobuf:"bytes,2,opt,name=identity_key,json=identityKey" json:"identity_key,omitempty"`
	GlobalFeatures []byte   `protobuf:"bytes,3,opt,name=global_features,json=globalFeatures,proto3" json:"global_features,omitempty"`
	Alias          string   `protobuf:"bytes,4,opt,name=alias" json:"alias,omitempty"`
}

func (m *NodeUpdate) Reset()                    { *m = NodeUpdate{} }
func (m *NodeUpdate) String() string            { return proto.CompactTextString(m) }
func (*NodeUpdate) ProtoMessage()               {}
func (*NodeUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{78} }

func (m *NodeUpdate) GetAddresses() []string {
	if m != nil {
		return m.Addresses
	}
	return nil
}

func (m *NodeUpdate) GetIdentityKey() string {
	if m != nil {
		return m.IdentityKey
	}
	return ""
}

func (m *NodeUpdate) GetGlobalFeatures() []byte {
	if m != nil {
		return m.GlobalFeatures
	}
	return nil
}

func (m *NodeUpdate) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

type ChannelEdgeUpdate struct {
	// *
	// The unique channel ID for the channel. The first 3 bytes are the block
	// height, the next 3 the index within the block, and the last 2 bytes are the
	// output index for the channel.
	ChanId          uint64         `protobuf:"varint,1,opt,name=chan_id,json=chanId" json:"chan_id,omitempty"`
	ChanPoint       *ChannelPoint  `protobuf:"bytes,2,opt,name=chan_point,json=chanPoint" json:"chan_point,omitempty"`
	Capacity        int64          `protobuf:"varint,3,opt,name=capacity" json:"capacity,omitempty"`
	RoutingPolicy   *RoutingPolicy `protobuf:"bytes,4,opt,name=routing_policy,json=routingPolicy" json:"routing_policy,omitempty"`
	AdvertisingNode string         `protobuf:"bytes,5,opt,name=advertising_node,json=advertisingNode" json:"advertising_node,omitempty"`
	ConnectingNode  string         `protobuf:"bytes,6,opt,name=connecting_node,json=connectingNode" json:"connecting_node,omitempty"`
}

func (m *ChannelEdgeUpdate) Reset()                    { *m = ChannelEdgeUpdate{} }
func (m *ChannelEdgeUpdate) String() string            { return proto.CompactTextString(m) }
func (*ChannelEdgeUpdate) ProtoMessage()               {}
func (*ChannelEdgeUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{79} }

func (m *ChannelEdgeUpdate) GetChanId() uint64 {
	if m != nil {
		return m.ChanId
	}
	return 0
}

func (m *ChannelEdgeUpdate) GetChanPoint() *ChannelPoint {
	if m != nil {
		return m.ChanPoint
	}
	return nil
}

func (m *ChannelEdgeUpdate) GetCapacity() int64 {
	if m != nil {
		return m.Capacity
	}
	return 0
}

func (m *ChannelEdgeUpdate) GetRoutingPolicy() *RoutingPolicy {
	if m != nil {
		return m.RoutingPolicy
	}
	return nil
}

func (m *ChannelEdgeUpdate) GetAdvertisingNode() string {
	if m != nil {
		return m.AdvertisingNode
	}
	return ""
}

func (m *ChannelEdgeUpdate) GetConnectingNode() string {
	if m != nil {
		return m.ConnectingNode
	}
	return ""
}

type ClosedChannelUpdate struct {
	// *
	// The unique channel ID for the channel. The first 3 bytes are the block
	// height, the next 3 the index within the block, and the last 2 bytes are the
	// output index for the channel.
	ChanId       uint64        `protobuf:"varint,1,opt,name=chan_id,json=chanId" json:"chan_id,omitempty"`
	Capacity     int64         `protobuf:"varint,2,opt,name=capacity" json:"capacity,omitempty"`
	ClosedHeight uint32        `protobuf:"varint,3,opt,name=closed_height,json=closedHeight" json:"closed_height,omitempty"`
	ChanPoint    *ChannelPoint `protobuf:"bytes,4,opt,name=chan_point,json=chanPoint" json:"chan_point,omitempty"`
}

func (m *ClosedChannelUpdate) Reset()                    { *m = ClosedChannelUpdate{} }
func (m *ClosedChannelUpdate) String() string            { return proto.CompactTextString(m) }
func (*ClosedChannelUpdate) ProtoMessage()               {}
func (*ClosedChannelUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{80} }

func (m *ClosedChannelUpdate) GetChanId() uint64 {
	if m != nil {
		return m.ChanId
	}
	return 0
}

func (m *ClosedChannelUpdate) GetCapacity() int64 {
	if m != nil {
		return m.Capacity
	}
	return 0
}

func (m *ClosedChannelUpdate) GetClosedHeight() uint32 {
	if m != nil {
		return m.ClosedHeight
	}
	return 0
}

func (m *ClosedChannelUpdate) GetChanPoint() *ChannelPoint {
	if m != nil {
		return m.ChanPoint
	}
	return nil
}

type HopHint struct {
	// / The public key of the node at the start of the channel.
	NodeId string `protobuf:"bytes,1,opt,name=node_id" json:"node_id,omitempty"`
	// / The unique identifier of the channel.
	ChanId uint64 `protobuf:"varint,2,opt,name=chan_id" json:"chan_id,omitempty"`
	// / The base fee of the channel denominated in millisatoshis.
	FeeBaseMsat uint32 `protobuf:"varint,3,opt,name=fee_base_msat" json:"fee_base_msat,omitempty"`
	// *
	// The fee rate of the channel for sending one satoshi across it denominated in
	// millionths of a satoshi.
	FeeProportionalMillionths uint32 `protobuf:"varint,4,opt,name=fee_proportional_millionths" json:"fee_proportional_millionths,omitempty"`
	// / The time-lock delta of the channel.
	CltvExpiryDelta uint32 `protobuf:"varint,5,opt,name=cltv_expiry_delta" json:"cltv_expiry_delta,omitempty"`
}

func (m *HopHint) Reset()                    { *m = HopHint{} }
func (m *HopHint) String() string            { return proto.CompactTextString(m) }
func (*HopHint) ProtoMessage()               {}
func (*HopHint) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{81} }

func (m *HopHint) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func (m *HopHint) GetChanId() uint64 {
	if m != nil {
		return m.ChanId
	}
	return 0
}

func (m *HopHint) GetFeeBaseMsat() uint32 {
	if m != nil {
		return m.FeeBaseMsat
	}
	return 0
}

func (m *HopHint) GetFeeProportionalMillionths() uint32 {
	if m != nil {
		return m.FeeProportionalMillionths
	}
	return 0
}

func (m *HopHint) GetCltvExpiryDelta() uint32 {
	if m != nil {
		return m.CltvExpiryDelta
	}
	return 0
}

type RouteHint struct {
	// *
	// A list of hop hints that when chained together can assist in reaching a
	// specific destination.
	HopHints []*HopHint `protobuf:"bytes,1,rep,name=hop_hints" json:"hop_hints,omitempty"`
}

func (m *RouteHint) Reset()                    { *m = RouteHint{} }
func (m *RouteHint) String() string            { return proto.CompactTextString(m) }
func (*RouteHint) ProtoMessage()               {}
func (*RouteHint) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{82} }

func (m *RouteHint) GetHopHints() []*HopHint {
	if m != nil {
		return m.HopHints
	}
	return nil
}

type Invoice struct {
	// *
	// An optional memo to attach along with the invoice. Used for record keeping
	// purposes for the invoice's creator, and will also be set in the description
	// field of the encoded payment request if the description_hash field is not
	// being used.
	Memo string `protobuf:"bytes,1,opt,name=memo" json:"memo,omitempty"`
	// / An optional cryptographic receipt of payment
	Receipt []byte `protobuf:"bytes,2,opt,name=receipt,proto3" json:"receipt,omitempty"`
	// *
	// The hex-encoded preimage (32 byte) which will allow settling an incoming
	// HTLC payable to this preimage
	RPreimage []byte `protobuf:"bytes,3,opt,name=r_preimage,proto3" json:"r_preimage,omitempty"`
	// / The hash of the preimage
	RHash []byte `protobuf:"bytes,4,opt,name=r_hash,proto3" json:"r_hash,omitempty"`
	// / The value of this invoice in satoshis
	Value int64 `protobuf:"varint,5,opt,name=value" json:"value,omitempty"`
	// / Whether this invoice has been fulfilled
	Settled bool `protobuf:"varint,6,opt,name=settled" json:"settled,omitempty"`
	// / When this invoice was created
	CreationDate int64 `protobuf:"varint,7,opt,name=creation_date" json:"creation_date,omitempty"`
	// / When this invoice was settled
	SettleDate int64 `protobuf:"varint,8,opt,name=settle_date" json:"settle_date,omitempty"`
	// *
	// A bare-bones invoice for a payment within the Lightning Network.  With the
	// details of the invoice, the sender has all the data necessary to send a
	// payment to the recipient.
	PaymentRequest string `protobuf:"bytes,9,opt,name=payment_request" json:"payment_request,omitempty"`
	// *
	// Hash (SHA-256) of a description of the payment. Used if the description of
	// payment (memo) is too long to naturally fit within the description field
	// of an encoded payment request.
	DescriptionHash []byte `protobuf:"bytes,10,opt,name=description_hash,proto3" json:"description_hash,omitempty"`
	// / Payment request expiry time in seconds. Default is 3600 (1 hour).
	Expiry int64 `protobuf:"varint,11,opt,name=expiry" json:"expiry,omitempty"`
	// / Fallback on-chain address.
	FallbackAddr string `protobuf:"bytes,12,opt,name=fallback_addr" json:"fallback_addr,omitempty"`
	// / Delta to use for the time-lock of the CLTV extended to the final hop.
	CltvExpiry uint64 `protobuf:"varint,13,opt,name=cltv_expiry" json:"cltv_expiry,omitempty"`
	// *
	// Route hints that can each be individually used to assist in reaching the
	// invoice's destination.
	RouteHints []*RouteHint `protobuf:"bytes,14,rep,name=route_hints" json:"route_hints,omitempty"`
	// / Whether this invoice should include routing hints for private channels.
	Private bool `protobuf:"varint,15,opt,name=private" json:"private,omitempty"`
	// *
	// The "add" index of this invoice. Each newly created invoice will increment
	// this index making it monotonically increasing. Callers to the
	// SubscribeInvoices call can use this to instantly get notified of all added
	// invoices with an add_index greater than this one.
	AddIndex uint64 `protobuf:"varint,16,opt,name=add_index" json:"add_index,omitempty"`
	// *
	// The "settle" index of this invoice. Each newly settled invoice will
	// increment this index making it monotonically increasing. Callers to the
	// SubscribeInvoices call can use this to instantly get notified of all
	// settled invoices with an settle_index greater than this one.
	SettleIndex uint64 `protobuf:"varint,17,opt,name=settle_index" json:"settle_index,omitempty"`
	// *
	// The amount that was accepted for this invoice. This will ONLY be set if
	// this invoice has been settled. We provide this field as if the invoice was
	// created with a zero value, then we need to record what amount was
	// ultimately accepted. Additionally, it's possible that the sender paid MORE
	// that was specified in the original invoice. So we'll record that here as
	// well.
	AmtPaid int64 `protobuf:"varint,18,opt,name=amt_paid" json:"amt_paid,omitempty"`
}

func (m *Invoice) Reset()                    { *m = Invoice{} }
func (m *Invoice) String() string            { return proto.CompactTextString(m) }
func (*Invoice) ProtoMessage()               {}
func (*Invoice) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{83} }

func (m *Invoice) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

func (m *Invoice) GetReceipt() []byte {
	if m != nil {
		return m.Receipt
	}
	return nil
}

func (m *Invoice) GetRPreimage() []byte {
	if m != nil {
		return m.RPreimage
	}
	return nil
}

func (m *Invoice) GetRHash() []byte {
	if m != nil {
		return m.RHash
	}
	return nil
}

func (m *Invoice) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *Invoice) GetSettled() bool {
	if m != nil {
		return m.Settled
	}
	return false
}

func (m *Invoice) GetCreationDate() int64 {
	if m != nil {
		return m.CreationDate
	}
	return 0
}

func (m *Invoice) GetSettleDate() int64 {
	if m != nil {
		return m.SettleDate
	}
	return 0
}

func (m *Invoice) GetPaymentRequest() string {
	if m != nil {
		return m.PaymentRequest
	}
	return ""
}

func (m *Invoice) GetDescriptionHash() []byte {
	if m != nil {
		return m.DescriptionHash
	}
	return nil
}

func (m *Invoice) GetExpiry() int64 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func (m *Invoice) GetFallbackAddr() string {
	if m != nil {
		return m.FallbackAddr
	}
	return ""
}

func (m *Invoice) GetCltvExpiry() uint64 {
	if m != nil {
		return m.CltvExpiry
	}
	return 0
}

func (m *Invoice) GetRouteHints() []*RouteHint {
	if m != nil {
		return m.RouteHints
	}
	return nil
}

func (m *Invoice) GetPrivate() bool {
	if m != nil {
		return m.Private
	}
	return false
}

func (m *Invoice) GetAddIndex() uint64 {
	if m != nil {
		return m.AddIndex
	}
	return 0
}

func (m *Invoice) GetSettleIndex() uint64 {
	if m != nil {
		return m.SettleIndex
	}
	return 0
}

func (m *Invoice) GetAmtPaid() int64 {
	if m != nil {
		return m.AmtPaid
	}
	return 0
}

type AddInvoiceResponse struct {
	RHash []byte `protobuf:"bytes,1,opt,name=r_hash,proto3" json:"r_hash,omitempty"`
	// *
	// A bare-bones invoice for a payment within the Lightning Network.  With the
	// details of the invoice, the sender has all the data necessary to send a
	// payment to the recipient.
	PaymentRequest string `protobuf:"bytes,2,opt,name=payment_request" json:"payment_request,omitempty"`
	// *
	// The "add" index of this invoice. Each newly created invoice will increment
	// this index making it monotonically increasing. Callers to the
	// SubscribeInvoices call can use this to instantly get notified of all added
	// invoices with an add_index greater than this one.
	AddIndex uint64 `protobuf:"varint,16,opt,name=add_index" json:"add_index,omitempty"`
}

func (m *AddInvoiceResponse) Reset()                    { *m = AddInvoiceResponse{} }
func (m *AddInvoiceResponse) String() string            { return proto.CompactTextString(m) }
func (*AddInvoiceResponse) ProtoMessage()               {}
func (*AddInvoiceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{84} }

func (m *AddInvoiceResponse) GetRHash() []byte {
	if m != nil {
		return m.RHash
	}
	return nil
}

func (m *AddInvoiceResponse) GetPaymentRequest() string {
	if m != nil {
		return m.PaymentRequest
	}
	return ""
}

func (m *AddInvoiceResponse) GetAddIndex() uint64 {
	if m != nil {
		return m.AddIndex
	}
	return 0
}

type PaymentHash struct {
	// *
	// The hex-encoded payment hash of the invoice to be looked up. The passed
	// payment hash must be exactly 32 bytes, otherwise an error is returned.
	RHashStr string `protobuf:"bytes,1,opt,name=r_hash_str" json:"r_hash_str,omitempty"`
	// / The payment hash of the invoice to be looked up.
	RHash []byte `protobuf:"bytes,2,opt,name=r_hash,proto3" json:"r_hash,omitempty"`
}

func (m *PaymentHash) Reset()                    { *m = PaymentHash{} }
func (m *PaymentHash) String() string            { return proto.CompactTextString(m) }
func (*PaymentHash) ProtoMessage()               {}
func (*PaymentHash) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{85} }

func (m *PaymentHash) GetRHashStr() string {
	if m != nil {
		return m.RHashStr
	}
	return ""
}

func (m *PaymentHash) GetRHash() []byte {
	if m != nil {
		return m.RHash
	}
	return nil
}

type ListInvoiceRequest struct {
	// / Toggles if all invoices should be returned, or only those that are currently unsettled.
	PendingOnly bool `protobuf:"varint,1,opt,name=pending_only,json=pendingOnly" json:"pending_only,omitempty"`
}

func (m *ListInvoiceRequest) Reset()                    { *m = ListInvoiceRequest{} }
func (m *ListInvoiceRequest) String() string            { return proto.CompactTextString(m) }
func (*ListInvoiceRequest) ProtoMessage()               {}
func (*ListInvoiceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{86} }

func (m *ListInvoiceRequest) GetPendingOnly() bool {
	if m != nil {
		return m.PendingOnly
	}
	return false
}

type ListInvoiceResponse struct {
	Invoices []*Invoice `protobuf:"bytes,1,rep,name=invoices" json:"invoices,omitempty"`
}

func (m *ListInvoiceResponse) Reset()                    { *m = ListInvoiceResponse{} }
func (m *ListInvoiceResponse) String() string            { return proto.CompactTextString(m) }
func (*ListInvoiceResponse) ProtoMessage()               {}
func (*ListInvoiceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{87} }

func (m *ListInvoiceResponse) GetInvoices() []*Invoice {
	if m != nil {
		return m.Invoices
	}
	return nil
}

type InvoiceSubscription struct {
	// *
	// If specified (non-zero), then we'll first start by sending out
	// notifications for all added indexes with an add_index greater than this
	// value. This allows callers to catch up on any events they missed while they
	// weren't connected to the streaming RPC.
	AddIndex uint64 `protobuf:"varint,1,opt,name=add_index" json:"add_index,omitempty"`
	// *
	// If specified (non-zero), then we'll first start by sending out
	// notifications for all settled indexes with an settle_index greater than
	// this value. This allows callers to catch up on any events they missed while
	// they weren't connected to the streaming RPC.
	SettleIndex uint64 `protobuf:"varint,2,opt,name=settle_index" json:"settle_index,omitempty"`
}

func (m *InvoiceSubscription) Reset()                    { *m = InvoiceSubscription{} }
func (m *InvoiceSubscription) String() string            { return proto.CompactTextString(m) }
func (*InvoiceSubscription) ProtoMessage()               {}
func (*InvoiceSubscription) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{88} }

func (m *InvoiceSubscription) GetAddIndex() uint64 {
	if m != nil {
		return m.AddIndex
	}
	return 0
}

func (m *InvoiceSubscription) GetSettleIndex() uint64 {
	if m != nil {
		return m.SettleIndex
	}
	return 0
}

type Payment struct {
	// / The payment hash
	PaymentHash string `protobuf:"bytes,1,opt,name=payment_hash" json:"payment_hash,omitempty"`
	// / The value of the payment in satoshis
	Value int64 `protobuf:"varint,2,opt,name=value" json:"value,omitempty"`
	// / The date of this payment
	CreationDate int64 `protobuf:"varint,3,opt,name=creation_date" json:"creation_date,omitempty"`
	// / The path this payment took
	Path []string `protobuf:"bytes,4,rep,name=path" json:"path,omitempty"`
	// / The fee paid for this payment in satoshis
	Fee int64 `protobuf:"varint,5,opt,name=fee" json:"fee,omitempty"`
	// / The payment preimage
	PaymentPreimage string `protobuf:"bytes,6,opt,name=payment_preimage" json:"payment_preimage,omitempty"`
}

func (m *Payment) Reset()                    { *m = Payment{} }
func (m *Payment) String() string            { return proto.CompactTextString(m) }
func (*Payment) ProtoMessage()               {}
func (*Payment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{89} }

func (m *Payment) GetPaymentHash() string {
	if m != nil {
		return m.PaymentHash
	}
	return ""
}

func (m *Payment) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *Payment) GetCreationDate() int64 {
	if m != nil {
		return m.CreationDate
	}
	return 0
}

func (m *Payment) GetPath() []string {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *Payment) GetFee() int64 {
	if m != nil {
		return m.Fee
	}
	return 0
}

func (m *Payment) GetPaymentPreimage() string {
	if m != nil {
		return m.PaymentPreimage
	}
	return ""
}

type ListPaymentsRequest struct {
}

func (m *ListPaymentsRequest) Reset()                    { *m = ListPaymentsRequest{} }
func (m *ListPaymentsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListPaymentsRequest) ProtoMessage()               {}
func (*ListPaymentsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{90} }

type ListPaymentsResponse struct {
	// / The list of payments
	Payments []*Payment `protobuf:"bytes,1,rep,name=payments" json:"payments,omitempty"`
}

func (m *ListPaymentsResponse) Reset()                    { *m = ListPaymentsResponse{} }
func (m *ListPaymentsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListPaymentsResponse) ProtoMessage()               {}
func (*ListPaymentsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{91} }

func (m *ListPaymentsResponse) GetPayments() []*Payment {
	if m != nil {
		return m.Payments
	}
	return nil
}

type DeleteAllPaymentsRequest struct {
}

func (m *DeleteAllPaymentsRequest) Reset()                    { *m = DeleteAllPaymentsRequest{} }
func (m *DeleteAllPaymentsRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteAllPaymentsRequest) ProtoMessage()               {}
func (*DeleteAllPaymentsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{92} }

type DeleteAllPaymentsResponse struct {
}

func (m *DeleteAllPaymentsResponse) Reset()                    { *m = DeleteAllPaymentsResponse{} }
func (m *DeleteAllPaymentsResponse) String() string            { return proto.CompactTextString(m) }
func (*DeleteAllPaymentsResponse) ProtoMessage()               {}
func (*DeleteAllPaymentsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{93} }

type DebugLevelRequest struct {
	Show      bool   `protobuf:"varint,1,opt,name=show" json:"show,omitempty"`
	LevelSpec string `protobuf:"bytes,2,opt,name=level_spec,json=levelSpec" json:"level_spec,omitempty"`
}

func (m *DebugLevelRequest) Reset()                    { *m = DebugLevelRequest{} }
func (m *DebugLevelRequest) String() string            { return proto.CompactTextString(m) }
func (*DebugLevelRequest) ProtoMessage()               {}
func (*DebugLevelRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{94} }

func (m *DebugLevelRequest) GetShow() bool {
	if m != nil {
		return m.Show
	}
	return false
}

func (m *DebugLevelRequest) GetLevelSpec() string {
	if m != nil {
		return m.LevelSpec
	}
	return ""
}

type DebugLevelResponse struct {
	SubSystems string `protobuf:"bytes,1,opt,name=sub_systems" json:"sub_systems,omitempty"`
}

func (m *DebugLevelResponse) Reset()                    { *m = DebugLevelResponse{} }
func (m *DebugLevelResponse) String() string            { return proto.CompactTextString(m) }
func (*DebugLevelResponse) ProtoMessage()               {}
func (*DebugLevelResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{95} }

func (m *DebugLevelResponse) GetSubSystems() string {
	if m != nil {
		return m.SubSystems
	}
	return ""
}

type PayReqString struct {
	// / The payment request string to be decoded
	PayReq string `protobuf:"bytes,1,opt,name=pay_req,json=payReq" json:"pay_req,omitempty"`
}

func (m *PayReqString) Reset()                    { *m = PayReqString{} }
func (m *PayReqString) String() string            { return proto.CompactTextString(m) }
func (*PayReqString) ProtoMessage()               {}
func (*PayReqString) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{96} }

func (m *PayReqString) GetPayReq() string {
	if m != nil {
		return m.PayReq
	}
	return ""
}

type PayReq struct {
	Destination     string       `protobuf:"bytes,1,opt,name=destination" json:"destination,omitempty"`
	PaymentHash     string       `protobuf:"bytes,2,opt,name=payment_hash" json:"payment_hash,omitempty"`
	NumSatoshis     int64        `protobuf:"varint,3,opt,name=num_satoshis" json:"num_satoshis,omitempty"`
	Timestamp       int64        `protobuf:"varint,4,opt,name=timestamp" json:"timestamp,omitempty"`
	Expiry          int64        `protobuf:"varint,5,opt,name=expiry" json:"expiry,omitempty"`
	Description     string       `protobuf:"bytes,6,opt,name=description" json:"description,omitempty"`
	DescriptionHash string       `protobuf:"bytes,7,opt,name=description_hash" json:"description_hash,omitempty"`
	FallbackAddr    string       `protobuf:"bytes,8,opt,name=fallback_addr" json:"fallback_addr,omitempty"`
	CltvExpiry      int64        `protobuf:"varint,9,opt,name=cltv_expiry" json:"cltv_expiry,omitempty"`
	RouteHints      []*RouteHint `protobuf:"bytes,10,rep,name=route_hints" json:"route_hints,omitempty"`
}

func (m *PayReq) Reset()                    { *m = PayReq{} }
func (m *PayReq) String() string            { return proto.CompactTextString(m) }
func (*PayReq) ProtoMessage()               {}
func (*PayReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{97} }

func (m *PayReq) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *PayReq) GetPaymentHash() string {
	if m != nil {
		return m.PaymentHash
	}
	return ""
}

func (m *PayReq) GetNumSatoshis() int64 {
	if m != nil {
		return m.NumSatoshis
	}
	return 0
}

func (m *PayReq) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *PayReq) GetExpiry() int64 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func (m *PayReq) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *PayReq) GetDescriptionHash() string {
	if m != nil {
		return m.DescriptionHash
	}
	return ""
}

func (m *PayReq) GetFallbackAddr() string {
	if m != nil {
		return m.FallbackAddr
	}
	return ""
}

func (m *PayReq) GetCltvExpiry() int64 {
	if m != nil {
		return m.CltvExpiry
	}
	return 0
}

func (m *PayReq) GetRouteHints() []*RouteHint {
	if m != nil {
		return m.RouteHints
	}
	return nil
}

type FeeReportRequest struct {
}

func (m *FeeReportRequest) Reset()                    { *m = FeeReportRequest{} }
func (m *FeeReportRequest) String() string            { return proto.CompactTextString(m) }
func (*FeeReportRequest) ProtoMessage()               {}
func (*FeeReportRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{98} }

type ChannelFeeReport struct {
	// / The channel that this fee report belongs to.
	ChanPoint string `protobuf:"bytes,1,opt,name=chan_point,json=channel_point" json:"chan_point,omitempty"`
	// / The base fee charged regardless of the number of milli-satoshis sent.
	BaseFeeMsat int64 `protobuf:"varint,2,opt,name=base_fee_msat" json:"base_fee_msat,omitempty"`
	// / The amount charged per milli-satoshis transferred expressed in millionths of a satoshi.
	FeePerMil int64 `protobuf:"varint,3,opt,name=fee_per_mil" json:"fee_per_mil,omitempty"`
	// / The effective fee rate in milli-satoshis. Computed by dividing the fee_per_mil value by 1 million.
	FeeRate float64 `protobuf:"fixed64,4,opt,name=fee_rate" json:"fee_rate,omitempty"`
}

func (m *ChannelFeeReport) Reset()                    { *m = ChannelFeeReport{} }
func (m *ChannelFeeReport) String() string            { return proto.CompactTextString(m) }
func (*ChannelFeeReport) ProtoMessage()               {}
func (*ChannelFeeReport) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{99} }

func (m *ChannelFeeReport) GetChanPoint() string {
	if m != nil {
		return m.ChanPoint
	}
	return ""
}

func (m *ChannelFeeReport) GetBaseFeeMsat() int64 {
	if m != nil {
		return m.BaseFeeMsat
	}
	return 0
}

func (m *ChannelFeeReport) GetFeePerMil() int64 {
	if m != nil {
		return m.FeePerMil
	}
	return 0
}

func (m *ChannelFeeReport) GetFeeRate() float64 {
	if m != nil {
		return m.FeeRate
	}
	return 0
}

type FeeReportResponse struct {
	// / An array of channel fee reports which describes the current fee schedule for each channel.
	ChannelFees []*ChannelFeeReport `protobuf:"bytes,1,rep,name=channel_fees" json:"channel_fees,omitempty"`
	// / The total amount of fee revenue (in satoshis) the switch has collected over the past 24 hrs.
	DayFeeSum uint64 `protobuf:"varint,2,opt,name=day_fee_sum" json:"day_fee_sum,omitempty"`
	// / The total amount of fee revenue (in satoshis) the switch has collected over the past 1 week.
	WeekFeeSum uint64 `protobuf:"varint,3,opt,name=week_fee_sum" json:"week_fee_sum,omitempty"`
	// / The total amount of fee revenue (in satoshis) the switch has collected over the past 1 month.
	MonthFeeSum uint64 `protobuf:"varint,4,opt,name=month_fee_sum" json:"month_fee_sum,omitempty"`
}

func (m *FeeReportResponse) Reset()                    { *m = FeeReportResponse{} }
func (m *FeeReportResponse) String() string            { return proto.CompactTextString(m) }
func (*FeeReportResponse) ProtoMessage()               {}
func (*FeeReportResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{100} }

func (m *FeeReportResponse) GetChannelFees() []*ChannelFeeReport {
	if m != nil {
		return m.ChannelFees
	}
	return nil
}

func (m *FeeReportResponse) GetDayFeeSum() uint64 {
	if m != nil {
		return m.DayFeeSum
	}
	return 0
}

func (m *FeeReportResponse) GetWeekFeeSum() uint64 {
	if m != nil {
		return m.WeekFeeSum
	}
	return 0
}

func (m *FeeReportResponse) GetMonthFeeSum() uint64 {
	if m != nil {
		return m.MonthFeeSum
	}
	return 0
}

type PolicyUpdateRequest struct {
	// Types that are valid to be assigned to Scope:
	//	*PolicyUpdateRequest_Global
	//	*PolicyUpdateRequest_ChanPoint
	Scope isPolicyUpdateRequest_Scope `protobuf_oneof:"scope"`
	// / The base fee charged regardless of the number of milli-satoshis sent.
	BaseFeeMsat int64 `protobuf:"varint,3,opt,name=base_fee_msat" json:"base_fee_msat,omitempty"`
	// / The effective fee rate in milli-satoshis. The precision of this value goes up to 6 decimal places, so 1e-6.
	FeeRate float64 `protobuf:"fixed64,4,opt,name=fee_rate" json:"fee_rate,omitempty"`
	// / The required timelock delta for HTLCs forwarded over the channel.
	TimeLockDelta uint32 `protobuf:"varint,5,opt,name=time_lock_delta" json:"time_lock_delta,omitempty"`
}

func (m *PolicyUpdateRequest) Reset()                    { *m = PolicyUpdateRequest{} }
func (m *PolicyUpdateRequest) String() string            { return proto.CompactTextString(m) }
func (*PolicyUpdateRequest) ProtoMessage()               {}
func (*PolicyUpdateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{101} }

type isPolicyUpdateRequest_Scope interface{ isPolicyUpdateRequest_Scope() }

type PolicyUpdateRequest_Global struct {
	Global bool `protobuf:"varint,1,opt,name=global,oneof"`
}
type PolicyUpdateRequest_ChanPoint struct {
	ChanPoint *ChannelPoint `protobuf:"bytes,2,opt,name=chan_point,oneof"`
}

func (*PolicyUpdateRequest_Global) isPolicyUpdateRequest_Scope()    {}
func (*PolicyUpdateRequest_ChanPoint) isPolicyUpdateRequest_Scope() {}

func (m *PolicyUpdateRequest) GetScope() isPolicyUpdateRequest_Scope {
	if m != nil {
		return m.Scope
	}
	return nil
}

func (m *PolicyUpdateRequest) GetGlobal() bool {
	if x, ok := m.GetScope().(*PolicyUpdateRequest_Global); ok {
		return x.Global
	}
	return false
}

func (m *PolicyUpdateRequest) GetChanPoint() *ChannelPoint {
	if x, ok := m.GetScope().(*PolicyUpdateRequest_ChanPoint); ok {
		return x.ChanPoint
	}
	return nil
}

func (m *PolicyUpdateRequest) GetBaseFeeMsat() int64 {
	if m != nil {
		return m.BaseFeeMsat
	}
	return 0
}

func (m *PolicyUpdateRequest) GetFeeRate() float64 {
	if m != nil {
		return m.FeeRate
	}
	return 0
}

func (m *PolicyUpdateRequest) GetTimeLockDelta() uint32 {
	if m != nil {
		return m.TimeLockDelta
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PolicyUpdateRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PolicyUpdateRequest_OneofMarshaler, _PolicyUpdateRequest_OneofUnmarshaler, _PolicyUpdateRequest_OneofSizer, []interface{}{
		(*PolicyUpdateRequest_Global)(nil),
		(*PolicyUpdateRequest_ChanPoint)(nil),
	}
}

func _PolicyUpdateRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PolicyUpdateRequest)
	// scope
	switch x := m.Scope.(type) {
	case *PolicyUpdateRequest_Global:
		t := uint64(0)
		if x.Global {
			t = 1
		}
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *PolicyUpdateRequest_ChanPoint:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ChanPoint); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PolicyUpdateRequest.Scope has unexpected type %T", x)
	}
	return nil
}

func _PolicyUpdateRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PolicyUpdateRequest)
	switch tag {
	case 1: // scope.global
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Scope = &PolicyUpdateRequest_Global{x != 0}
		return true, err
	case 2: // scope.chan_point
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ChannelPoint)
		err := b.DecodeMessage(msg)
		m.Scope = &PolicyUpdateRequest_ChanPoint{msg}
		return true, err
	default:
		return false, nil
	}
}

func _PolicyUpdateRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PolicyUpdateRequest)
	// scope
	switch x := m.Scope.(type) {
	case *PolicyUpdateRequest_Global:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += 1
	case *PolicyUpdateRequest_ChanPoint:
		s := proto.Size(x.ChanPoint)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type PolicyUpdateResponse struct {
}

func (m *PolicyUpdateResponse) Reset()                    { *m = PolicyUpdateResponse{} }
func (m *PolicyUpdateResponse) String() string            { return proto.CompactTextString(m) }
func (*PolicyUpdateResponse) ProtoMessage()               {}
func (*PolicyUpdateResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{102} }

type ForwardingHistoryRequest struct {
	// / Start time is the starting point of the forwarding history request. All records beyond this point will be included, respecting the end time, and the index offset.
	StartTime uint64 `protobuf:"varint,1,opt,name=start_time" json:"start_time,omitempty"`
	// / End time is the end point of the forwarding history request. The response will carry at most 50k records between the start time and the end time. The index offset can be used to implement pagination.
	EndTime uint64 `protobuf:"varint,2,opt,name=end_time" json:"end_time,omitempty"`
	// / Index offset is the offset in the time series to start at. As each response can only contain 50k records, callers can use this to skip around within a packed time series.
	IndexOffset uint32 `protobuf:"varint,3,opt,name=index_offset" json:"index_offset,omitempty"`
	// / The max number of events to return in the response to this query.
	NumMaxEvents uint32 `protobuf:"varint,4,opt,name=num_max_events" json:"num_max_events,omitempty"`
}

func (m *ForwardingHistoryRequest) Reset()                    { *m = ForwardingHistoryRequest{} }
func (m *ForwardingHistoryRequest) String() string            { return proto.CompactTextString(m) }
func (*ForwardingHistoryRequest) ProtoMessage()               {}
func (*ForwardingHistoryRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{103} }

func (m *ForwardingHistoryRequest) GetStartTime() uint64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *ForwardingHistoryRequest) GetEndTime() uint64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *ForwardingHistoryRequest) GetIndexOffset() uint32 {
	if m != nil {
		return m.IndexOffset
	}
	return 0
}

func (m *ForwardingHistoryRequest) GetNumMaxEvents() uint32 {
	if m != nil {
		return m.NumMaxEvents
	}
	return 0
}

type ForwardingEvent struct {
	// / Timestamp is the time (unix epoch offset) that this circuit was completed.
	Timestamp uint64 `protobuf:"varint,1,opt,name=timestamp" json:"timestamp,omitempty"`
	// / The incoming channel ID that carried the HTLC that created the circuit.
	ChanIdIn uint64 `protobuf:"varint,2,opt,name=chan_id_in" json:"chan_id_in,omitempty"`
	// / The outgoing channel ID that carried the preimage that completed the circuit.
	ChanIdOut uint64 `protobuf:"varint,4,opt,name=chan_id_out" json:"chan_id_out,omitempty"`
	// / The total amount of the incoming HTLC that created half the circuit.
	AmtIn uint64 `protobuf:"varint,5,opt,name=amt_in" json:"amt_in,omitempty"`
	// / The total amount of the outgoign HTLC that created the second half of the circuit.
	AmtOut uint64 `protobuf:"varint,6,opt,name=amt_out" json:"amt_out,omitempty"`
	// / The total fee that this payment circuit carried.
	Fee uint64 `protobuf:"varint,7,opt,name=fee" json:"fee,omitempty"`
}

func (m *ForwardingEvent) Reset()                    { *m = ForwardingEvent{} }
func (m *ForwardingEvent) String() string            { return proto.CompactTextString(m) }
func (*ForwardingEvent) ProtoMessage()               {}
func (*ForwardingEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{104} }

func (m *ForwardingEvent) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *ForwardingEvent) GetChanIdIn() uint64 {
	if m != nil {
		return m.ChanIdIn
	}
	return 0
}

func (m *ForwardingEvent) GetChanIdOut() uint64 {
	if m != nil {
		return m.ChanIdOut
	}
	return 0
}

func (m *ForwardingEvent) GetAmtIn() uint64 {
	if m != nil {
		return m.AmtIn
	}
	return 0
}

func (m *ForwardingEvent) GetAmtOut() uint64 {
	if m != nil {
		return m.AmtOut
	}
	return 0
}

func (m *ForwardingEvent) GetFee() uint64 {
	if m != nil {
		return m.Fee
	}
	return 0
}

type ForwardingHistoryResponse struct {
	// / A list of forwarding events from the time slice of the time series specified in the request.
	ForwardingEvents []*ForwardingEvent `protobuf:"bytes,1,rep,name=forwarding_events" json:"forwarding_events,omitempty"`
	// / The index of the last time in the set of returned forwarding events. Can be used to seek further, pagination style.
	LastOffsetIndex uint32 `protobuf:"varint,2,opt,name=last_offset_index" json:"last_offset_index,omitempty"`
}

func (m *ForwardingHistoryResponse) Reset()                    { *m = ForwardingHistoryResponse{} }
func (m *ForwardingHistoryResponse) String() string            { return proto.CompactTextString(m) }
func (*ForwardingHistoryResponse) ProtoMessage()               {}
func (*ForwardingHistoryResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{105} }

func (m *ForwardingHistoryResponse) GetForwardingEvents() []*ForwardingEvent {
	if m != nil {
		return m.ForwardingEvents
	}
	return nil
}

func (m *ForwardingHistoryResponse) GetLastOffsetIndex() uint32 {
	if m != nil {
		return m.LastOffsetIndex
	}
	return 0
}

func init() {
	proto.RegisterType((*GenSeedRequest)(nil), "lnrpc.GenSeedRequest")
	proto.RegisterType((*GenSeedResponse)(nil), "lnrpc.GenSeedResponse")
	proto.RegisterType((*InitWalletRequest)(nil), "lnrpc.InitWalletRequest")
	proto.RegisterType((*InitWalletResponse)(nil), "lnrpc.InitWalletResponse")
	proto.RegisterType((*UnlockWalletRequest)(nil), "lnrpc.UnlockWalletRequest")
	proto.RegisterType((*UnlockWalletResponse)(nil), "lnrpc.UnlockWalletResponse")
	proto.RegisterType((*ChangePasswordRequest)(nil), "lnrpc.ChangePasswordRequest")
	proto.RegisterType((*ChangePasswordResponse)(nil), "lnrpc.ChangePasswordResponse")
	proto.RegisterType((*Transaction)(nil), "lnrpc.Transaction")
	proto.RegisterType((*GetTransactionsRequest)(nil), "lnrpc.GetTransactionsRequest")
	proto.RegisterType((*TransactionDetails)(nil), "lnrpc.TransactionDetails")
	proto.RegisterType((*FeeLimit)(nil), "lnrpc.FeeLimit")
	proto.RegisterType((*SendRequest)(nil), "lnrpc.SendRequest")
	proto.RegisterType((*SendResponse)(nil), "lnrpc.SendResponse")
	proto.RegisterType((*SendToRouteRequest)(nil), "lnrpc.SendToRouteRequest")
	proto.RegisterType((*ChannelPoint)(nil), "lnrpc.ChannelPoint")
	proto.RegisterType((*LightningAddress)(nil), "lnrpc.LightningAddress")
	proto.RegisterType((*SendManyRequest)(nil), "lnrpc.SendManyRequest")
	proto.RegisterType((*SendManyResponse)(nil), "lnrpc.SendManyResponse")
	proto.RegisterType((*SendCoinsRequest)(nil), "lnrpc.SendCoinsRequest")
	proto.RegisterType((*SendCoinsResponse)(nil), "lnrpc.SendCoinsResponse")
	proto.RegisterType((*NewAddressRequest)(nil), "lnrpc.NewAddressRequest")
	proto.RegisterType((*NewWitnessAddressRequest)(nil), "lnrpc.NewWitnessAddressRequest")
	proto.RegisterType((*NewAddressResponse)(nil), "lnrpc.NewAddressResponse")
	proto.RegisterType((*SignMessageRequest)(nil), "lnrpc.SignMessageRequest")
	proto.RegisterType((*SignMessageResponse)(nil), "lnrpc.SignMessageResponse")
	proto.RegisterType((*VerifyMessageRequest)(nil), "lnrpc.VerifyMessageRequest")
	proto.RegisterType((*VerifyMessageResponse)(nil), "lnrpc.VerifyMessageResponse")
	proto.RegisterType((*ConnectPeerRequest)(nil), "lnrpc.ConnectPeerRequest")
	proto.RegisterType((*ConnectPeerResponse)(nil), "lnrpc.ConnectPeerResponse")
	proto.RegisterType((*DisconnectPeerRequest)(nil), "lnrpc.DisconnectPeerRequest")
	proto.RegisterType((*DisconnectPeerResponse)(nil), "lnrpc.DisconnectPeerResponse")
	proto.RegisterType((*HTLC)(nil), "lnrpc.HTLC")
	proto.RegisterType((*Channel)(nil), "lnrpc.Channel")
	proto.RegisterType((*ListChannelsRequest)(nil), "lnrpc.ListChannelsRequest")
	proto.RegisterType((*ListChannelsResponse)(nil), "lnrpc.ListChannelsResponse")
	proto.RegisterType((*ChannelCloseSummary)(nil), "lnrpc.ChannelCloseSummary")
	proto.RegisterType((*ClosedChannelsRequest)(nil), "lnrpc.ClosedChannelsRequest")
	proto.RegisterType((*ClosedChannelsResponse)(nil), "lnrpc.ClosedChannelsResponse")
	proto.RegisterType((*Peer)(nil), "lnrpc.Peer")
	proto.RegisterType((*ListPeersRequest)(nil), "lnrpc.ListPeersRequest")
	proto.RegisterType((*ListPeersResponse)(nil), "lnrpc.ListPeersResponse")
	proto.RegisterType((*GetInfoRequest)(nil), "lnrpc.GetInfoRequest")
	proto.RegisterType((*GetInfoResponse)(nil), "lnrpc.GetInfoResponse")
	proto.RegisterType((*ConfirmationUpdate)(nil), "lnrpc.ConfirmationUpdate")
	proto.RegisterType((*ChannelOpenUpdate)(nil), "lnrpc.ChannelOpenUpdate")
	proto.RegisterType((*ChannelCloseUpdate)(nil), "lnrpc.ChannelCloseUpdate")
	proto.RegisterType((*CloseChannelRequest)(nil), "lnrpc.CloseChannelRequest")
	proto.RegisterType((*CloseStatusUpdate)(nil), "lnrpc.CloseStatusUpdate")
	proto.RegisterType((*PendingUpdate)(nil), "lnrpc.PendingUpdate")
	proto.RegisterType((*OpenChannelRequest)(nil), "lnrpc.OpenChannelRequest")
	proto.RegisterType((*OpenStatusUpdate)(nil), "lnrpc.OpenStatusUpdate")
	proto.RegisterType((*PendingHTLC)(nil), "lnrpc.PendingHTLC")
	proto.RegisterType((*PendingChannelsRequest)(nil), "lnrpc.PendingChannelsRequest")
	proto.RegisterType((*PendingChannelsResponse)(nil), "lnrpc.PendingChannelsResponse")
	proto.RegisterType((*PendingChannelsResponse_PendingChannel)(nil), "lnrpc.PendingChannelsResponse.PendingChannel")
	proto.RegisterType((*PendingChannelsResponse_PendingOpenChannel)(nil), "lnrpc.PendingChannelsResponse.PendingOpenChannel")
	proto.RegisterType((*PendingChannelsResponse_WaitingCloseChannel)(nil), "lnrpc.PendingChannelsResponse.WaitingCloseChannel")
	proto.RegisterType((*PendingChannelsResponse_ClosedChannel)(nil), "lnrpc.PendingChannelsResponse.ClosedChannel")
	proto.RegisterType((*PendingChannelsResponse_ForceClosedChannel)(nil), "lnrpc.PendingChannelsResponse.ForceClosedChannel")
	proto.RegisterType((*WalletBalanceRequest)(nil), "lnrpc.WalletBalanceRequest")
	proto.RegisterType((*WalletBalanceResponse)(nil), "lnrpc.WalletBalanceResponse")
	proto.RegisterType((*ChannelBalanceRequest)(nil), "lnrpc.ChannelBalanceRequest")
	proto.RegisterType((*ChannelBalanceResponse)(nil), "lnrpc.ChannelBalanceResponse")
	proto.RegisterType((*QueryRoutesRequest)(nil), "lnrpc.QueryRoutesRequest")
	proto.RegisterType((*QueryRoutesResponse)(nil), "lnrpc.QueryRoutesResponse")
	proto.RegisterType((*Hop)(nil), "lnrpc.Hop")
	proto.RegisterType((*Route)(nil), "lnrpc.Route")
	proto.RegisterType((*NodeInfoRequest)(nil), "lnrpc.NodeInfoRequest")
	proto.RegisterType((*NodeInfo)(nil), "lnrpc.NodeInfo")
	proto.RegisterType((*LightningNode)(nil), "lnrpc.LightningNode")
	proto.RegisterType((*NodeAddress)(nil), "lnrpc.NodeAddress")
	proto.RegisterType((*RoutingPolicy)(nil), "lnrpc.RoutingPolicy")
	proto.RegisterType((*ChannelEdge)(nil), "lnrpc.ChannelEdge")
	proto.RegisterType((*ChannelGraphRequest)(nil), "lnrpc.ChannelGraphRequest")
	proto.RegisterType((*ChannelGraph)(nil), "lnrpc.ChannelGraph")
	proto.RegisterType((*ChanInfoRequest)(nil), "lnrpc.ChanInfoRequest")
	proto.RegisterType((*NetworkInfoRequest)(nil), "lnrpc.NetworkInfoRequest")
	proto.RegisterType((*NetworkInfo)(nil), "lnrpc.NetworkInfo")
	proto.RegisterType((*StopRequest)(nil), "lnrpc.StopRequest")
	proto.RegisterType((*StopResponse)(nil), "lnrpc.StopResponse")
	proto.RegisterType((*GraphTopologySubscription)(nil), "lnrpc.GraphTopologySubscription")
	proto.RegisterType((*GraphTopologyUpdate)(nil), "lnrpc.GraphTopologyUpdate")
	proto.RegisterType((*NodeUpdate)(nil), "lnrpc.NodeUpdate")
	proto.RegisterType((*ChannelEdgeUpdate)(nil), "lnrpc.ChannelEdgeUpdate")
	proto.RegisterType((*ClosedChannelUpdate)(nil), "lnrpc.ClosedChannelUpdate")
	proto.RegisterType((*HopHint)(nil), "lnrpc.HopHint")
	proto.RegisterType((*RouteHint)(nil), "lnrpc.RouteHint")
	proto.RegisterType((*Invoice)(nil), "lnrpc.Invoice")
	proto.RegisterType((*AddInvoiceResponse)(nil), "lnrpc.AddInvoiceResponse")
	proto.RegisterType((*PaymentHash)(nil), "lnrpc.PaymentHash")
	proto.RegisterType((*ListInvoiceRequest)(nil), "lnrpc.ListInvoiceRequest")
	proto.RegisterType((*ListInvoiceResponse)(nil), "lnrpc.ListInvoiceResponse")
	proto.RegisterType((*InvoiceSubscription)(nil), "lnrpc.InvoiceSubscription")
	proto.RegisterType((*Payment)(nil), "lnrpc.Payment")
	proto.RegisterType((*ListPaymentsRequest)(nil), "lnrpc.ListPaymentsRequest")
	proto.RegisterType((*ListPaymentsResponse)(nil), "lnrpc.ListPaymentsResponse")
	proto.RegisterType((*DeleteAllPaymentsRequest)(nil), "lnrpc.DeleteAllPaymentsRequest")
	proto.RegisterType((*DeleteAllPaymentsResponse)(nil), "lnrpc.DeleteAllPaymentsResponse")
	proto.RegisterType((*DebugLevelRequest)(nil), "lnrpc.DebugLevelRequest")
	proto.RegisterType((*DebugLevelResponse)(nil), "lnrpc.DebugLevelResponse")
	proto.RegisterType((*PayReqString)(nil), "lnrpc.PayReqString")
	proto.RegisterType((*PayReq)(nil), "lnrpc.PayReq")
	proto.RegisterType((*FeeReportRequest)(nil), "lnrpc.FeeReportRequest")
	proto.RegisterType((*ChannelFeeReport)(nil), "lnrpc.ChannelFeeReport")
	proto.RegisterType((*FeeReportResponse)(nil), "lnrpc.FeeReportResponse")
	proto.RegisterType((*PolicyUpdateRequest)(nil), "lnrpc.PolicyUpdateRequest")
	proto.RegisterType((*PolicyUpdateResponse)(nil), "lnrpc.PolicyUpdateResponse")
	proto.RegisterType((*ForwardingHistoryRequest)(nil), "lnrpc.ForwardingHistoryRequest")
	proto.RegisterType((*ForwardingEvent)(nil), "lnrpc.ForwardingEvent")
	proto.RegisterType((*ForwardingHistoryResponse)(nil), "lnrpc.ForwardingHistoryResponse")
	proto.RegisterEnum("lnrpc.NewAddressRequest_AddressType", NewAddressRequest_AddressType_name, NewAddressRequest_AddressType_value)
	proto.RegisterEnum("lnrpc.ChannelCloseSummary_ClosureType", ChannelCloseSummary_ClosureType_name, ChannelCloseSummary_ClosureType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for WalletUnlocker service

type WalletUnlockerClient interface {
	// *
	// GenSeed is the first method that should be used to instantiate a new lnd
	// instance. This method allows a caller to generate a new aezeed cipher seed
	// given an optional passphrase. If provided, the passphrase will be necessary
	// to decrypt the cipherseed to expose the internal wallet seed.
	//
	// Once the cipherseed is obtained and verified by the user, the InitWallet
	// method should be used to commit the newly generated seed, and create the
	// wallet.
	GenSeed(ctx context.Context, in *GenSeedRequest, opts ...grpc.CallOption) (*GenSeedResponse, error)
	// *
	// InitWallet is used when lnd is starting up for the first time to fully
	// initialize the daemon and its internal wallet. At the very least a wallet
	// password must be provided. This will be used to encrypt sensitive material
	// on disk.
	//
	// In the case of a recovery scenario, the user can also specify their aezeed
	// mnemonic and passphrase. If set, then the daemon will use this prior state
	// to initialize its internal wallet.
	//
	// Alternatively, this can be used along with the GenSeed RPC to obtain a
	// seed, then present it to the user. Once it has been verified by the user,
	// the seed can be fed into this RPC in order to commit the new wallet.
	InitWallet(ctx context.Context, in *InitWalletRequest, opts ...grpc.CallOption) (*InitWalletResponse, error)
	// * lncli: `unlock`
	// UnlockWallet is used at startup of lnd to provide a password to unlock
	// the wallet database.
	UnlockWallet(ctx context.Context, in *UnlockWalletRequest, opts ...grpc.CallOption) (*UnlockWalletResponse, error)
	// * lncli: `changepassword`
	// ChangePassword changes the password of the encrypted wallet. This will
	// automatically unlock the wallet database if successful.
	ChangePassword(ctx context.Context, in *ChangePasswordRequest, opts ...grpc.CallOption) (*ChangePasswordResponse, error)
}

type walletUnlockerClient struct {
	cc *grpc.ClientConn
}

func NewWalletUnlockerClient(cc *grpc.ClientConn) WalletUnlockerClient {
	return &walletUnlockerClient{cc}
}

func (c *walletUnlockerClient) GenSeed(ctx context.Context, in *GenSeedRequest, opts ...grpc.CallOption) (*GenSeedResponse, error) {
	out := new(GenSeedResponse)
	err := grpc.Invoke(ctx, "/lnrpc.WalletUnlocker/GenSeed", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletUnlockerClient) InitWallet(ctx context.Context, in *InitWalletRequest, opts ...grpc.CallOption) (*InitWalletResponse, error) {
	out := new(InitWalletResponse)
	err := grpc.Invoke(ctx, "/lnrpc.WalletUnlocker/InitWallet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletUnlockerClient) UnlockWallet(ctx context.Context, in *UnlockWalletRequest, opts ...grpc.CallOption) (*UnlockWalletResponse, error) {
	out := new(UnlockWalletResponse)
	err := grpc.Invoke(ctx, "/lnrpc.WalletUnlocker/UnlockWallet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletUnlockerClient) ChangePassword(ctx context.Context, in *ChangePasswordRequest, opts ...grpc.CallOption) (*ChangePasswordResponse, error) {
	out := new(ChangePasswordResponse)
	err := grpc.Invoke(ctx, "/lnrpc.WalletUnlocker/ChangePassword", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for WalletUnlocker service

type WalletUnlockerServer interface {
	// *
	// GenSeed is the first method that should be used to instantiate a new lnd
	// instance. This method allows a caller to generate a new aezeed cipher seed
	// given an optional passphrase. If provided, the passphrase will be necessary
	// to decrypt the cipherseed to expose the internal wallet seed.
	//
	// Once the cipherseed is obtained and verified by the user, the InitWallet
	// method should be used to commit the newly generated seed, and create the
	// wallet.
	GenSeed(context.Context, *GenSeedRequest) (*GenSeedResponse, error)
	// *
	// InitWallet is used when lnd is starting up for the first time to fully
	// initialize the daemon and its internal wallet. At the very least a wallet
	// password must be provided. This will be used to encrypt sensitive material
	// on disk.
	//
	// In the case of a recovery scenario, the user can also specify their aezeed
	// mnemonic and passphrase. If set, then the daemon will use this prior state
	// to initialize its internal wallet.
	//
	// Alternatively, this can be used along with the GenSeed RPC to obtain a
	// seed, then present it to the user. Once it has been verified by the user,
	// the seed can be fed into this RPC in order to commit the new wallet.
	InitWallet(context.Context, *InitWalletRequest) (*InitWalletResponse, error)
	// * lncli: `unlock`
	// UnlockWallet is used at startup of lnd to provide a password to unlock
	// the wallet database.
	UnlockWallet(context.Context, *UnlockWalletRequest) (*UnlockWalletResponse, error)
	// * lncli: `changepassword`
	// ChangePassword changes the password of the encrypted wallet. This will
	// automatically unlock the wallet database if successful.
	ChangePassword(context.Context, *ChangePasswordRequest) (*ChangePasswordResponse, error)
}

func RegisterWalletUnlockerServer(s *grpc.Server, srv WalletUnlockerServer) {
	s.RegisterService(&_WalletUnlocker_serviceDesc, srv)
}

func _WalletUnlocker_GenSeed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenSeedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletUnlockerServer).GenSeed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.WalletUnlocker/GenSeed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletUnlockerServer).GenSeed(ctx, req.(*GenSeedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletUnlocker_InitWallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitWalletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletUnlockerServer).InitWallet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.WalletUnlocker/InitWallet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletUnlockerServer).InitWallet(ctx, req.(*InitWalletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletUnlocker_UnlockWallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockWalletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletUnlockerServer).UnlockWallet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.WalletUnlocker/UnlockWallet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletUnlockerServer).UnlockWallet(ctx, req.(*UnlockWalletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletUnlocker_ChangePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangePasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletUnlockerServer).ChangePassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.WalletUnlocker/ChangePassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletUnlockerServer).ChangePassword(ctx, req.(*ChangePasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _WalletUnlocker_serviceDesc = grpc.ServiceDesc{
	ServiceName: "lnrpc.WalletUnlocker",
	HandlerType: (*WalletUnlockerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GenSeed",
			Handler:    _WalletUnlocker_GenSeed_Handler,
		},
		{
			MethodName: "InitWallet",
			Handler:    _WalletUnlocker_InitWallet_Handler,
		},
		{
			MethodName: "UnlockWallet",
			Handler:    _WalletUnlocker_UnlockWallet_Handler,
		},
		{
			MethodName: "ChangePassword",
			Handler:    _WalletUnlocker_ChangePassword_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc.proto",
}

// Client API for Lightning service

type LightningClient interface {
	// * lncli: `walletbalance`
	// WalletBalance returns total unspent outputs(confirmed and unconfirmed), all
	// confirmed unspent outputs and all unconfirmed unspent outputs under control
	// of the wallet.
	WalletBalance(ctx context.Context, in *WalletBalanceRequest, opts ...grpc.CallOption) (*WalletBalanceResponse, error)
	// * lncli: `channelbalance`
	// ChannelBalance returns the total funds available across all open channels
	// in satoshis.
	ChannelBalance(ctx context.Context, in *ChannelBalanceRequest, opts ...grpc.CallOption) (*ChannelBalanceResponse, error)
	// * lncli: `listchaintxns`
	// GetTransactions returns a list describing all the known transactions
	// relevant to the wallet.
	GetTransactions(ctx context.Context, in *GetTransactionsRequest, opts ...grpc.CallOption) (*TransactionDetails, error)
	// * lncli: `sendcoins`
	// SendCoins executes a request to send coins to a particular address. Unlike
	// SendMany, this RPC call only allows creating a single output at a time. If
	// neither target_conf, or sat_per_byte are set, then the internal wallet will
	// consult its fee model to determine a fee for the default confirmation
	// target.
	SendCoins(ctx context.Context, in *SendCoinsRequest, opts ...grpc.CallOption) (*SendCoinsResponse, error)
	// *
	// SubscribeTransactions creates a uni-directional stream from the server to
	// the client in which any newly discovered transactions relevant to the
	// wallet are sent over.
	SubscribeTransactions(ctx context.Context, in *GetTransactionsRequest, opts ...grpc.CallOption) (Lightning_SubscribeTransactionsClient, error)
	// * lncli: `sendmany`
	// SendMany handles a request for a transaction that creates multiple specified
	// outputs in parallel. If neither target_conf, or sat_per_byte are set, then
	// the internal wallet will consult its fee model to determine a fee for the
	// default confirmation target.
	SendMany(ctx context.Context, in *SendManyRequest, opts ...grpc.CallOption) (*SendManyResponse, error)
	// * lncli: `newaddress`
	// NewAddress creates a new address under control of the local wallet.
	NewAddress(ctx context.Context, in *NewAddressRequest, opts ...grpc.CallOption) (*NewAddressResponse, error)
	// *
	// NewWitnessAddress creates a new witness address under control of the local wallet.
	NewWitnessAddress(ctx context.Context, in *NewWitnessAddressRequest, opts ...grpc.CallOption) (*NewAddressResponse, error)
	// * lncli: `signmessage`
	// SignMessage signs a message with this node's private key. The returned
	// signature string is `zbase32` encoded and pubkey recoverable, meaning that
	// only the message digest and signature are needed for verification.
	SignMessage(ctx context.Context, in *SignMessageRequest, opts ...grpc.CallOption) (*SignMessageResponse, error)
	// * lncli: `verifymessage`
	// VerifyMessage verifies a signature over a msg. The signature must be
	// zbase32 encoded and signed by an active node in the resident node's
	// channel database. In addition to returning the validity of the signature,
	// VerifyMessage also returns the recovered pubkey from the signature.
	VerifyMessage(ctx context.Context, in *VerifyMessageRequest, opts ...grpc.CallOption) (*VerifyMessageResponse, error)
	// * lncli: `connect`
	// ConnectPeer attempts to establish a connection to a remote peer. This is at
	// the networking level, and is used for communication between nodes. This is
	// distinct from establishing a channel with a peer.
	ConnectPeer(ctx context.Context, in *ConnectPeerRequest, opts ...grpc.CallOption) (*ConnectPeerResponse, error)
	// * lncli: `disconnect`
	// DisconnectPeer attempts to disconnect one peer from another identified by a
	// given pubKey. In the case that we currently have a pending or active channel
	// with the target peer, then this action will be not be allowed.
	DisconnectPeer(ctx context.Context, in *DisconnectPeerRequest, opts ...grpc.CallOption) (*DisconnectPeerResponse, error)
	// * lncli: `listpeers`
	// ListPeers returns a verbose listing of all currently active peers.
	ListPeers(ctx context.Context, in *ListPeersRequest, opts ...grpc.CallOption) (*ListPeersResponse, error)
	// * lncli: `getinfo`
	// GetInfo returns general information concerning the lightning node including
	// it's identity pubkey, alias, the chains it is connected to, and information
	// concerning the number of open+pending channels.
	GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoResponse, error)
	// * lncli: `pendingchannels`
	// PendingChannels returns a list of all the channels that are currently
	// considered "pending". A channel is pending if it has finished the funding
	// workflow and is waiting for confirmations for the funding txn, or is in the
	// process of closure, either initiated cooperatively or non-cooperatively.
	PendingChannels(ctx context.Context, in *PendingChannelsRequest, opts ...grpc.CallOption) (*PendingChannelsResponse, error)
	// * lncli: `listchannels`
	// ListChannels returns a description of all the open channels that this node
	// is a participant in.
	ListChannels(ctx context.Context, in *ListChannelsRequest, opts ...grpc.CallOption) (*ListChannelsResponse, error)
	// * lncli: `closedchannels`
	// ClosedChannels returns a description of all the closed channels that
	// this node was a participant in.
	ClosedChannels(ctx context.Context, in *ClosedChannelsRequest, opts ...grpc.CallOption) (*ClosedChannelsResponse, error)
	// *
	// OpenChannelSync is a synchronous version of the OpenChannel RPC call. This
	// call is meant to be consumed by clients to the REST proxy. As with all
	// other sync calls, all byte slices are intended to be populated as hex
	// encoded strings.
	OpenChannelSync(ctx context.Context, in *OpenChannelRequest, opts ...grpc.CallOption) (*ChannelPoint, error)
	// * lncli: `openchannel`
	// OpenChannel attempts to open a singly funded channel specified in the
	// request to a remote peer. Users are able to specify a target number of
	// blocks that the funding transaction should be confirmed in, or a manual fee
	// rate to us for the funding transaction. If neither are specified, then a
	// lax block confirmation target is used.
	OpenChannel(ctx context.Context, in *OpenChannelRequest, opts ...grpc.CallOption) (Lightning_OpenChannelClient, error)
	// * lncli: `closechannel`
	// CloseChannel attempts to close an active channel identified by its channel
	// outpoint (ChannelPoint). The actions of this method can additionally be
	// augmented to attempt a force close after a timeout period in the case of an
	// inactive peer. If a non-force close (cooperative closure) is requested,
	// then the user can specify either a target number of blocks until the
	// closure transaction is confirmed, or a manual fee rate. If neither are
	// specified, then a default lax, block confirmation target is used.
	CloseChannel(ctx context.Context, in *CloseChannelRequest, opts ...grpc.CallOption) (Lightning_CloseChannelClient, error)
	// * lncli: `sendpayment`
	// SendPayment dispatches a bi-directional streaming RPC for sending payments
	// through the Lightning Network. A single RPC invocation creates a persistent
	// bi-directional stream allowing clients to rapidly send payments through the
	// Lightning Network with a single persistent connection.
	SendPayment(ctx context.Context, opts ...grpc.CallOption) (Lightning_SendPaymentClient, error)
	// *
	// SendPaymentSync is the synchronous non-streaming version of SendPayment.
	// This RPC is intended to be consumed by clients of the REST proxy.
	// Additionally, this RPC expects the destination's public key and the payment
	// hash (if any) to be encoded as hex strings.
	SendPaymentSync(ctx context.Context, in *SendRequest, opts ...grpc.CallOption) (*SendResponse, error)
	// * lncli: `sendtoroute`
	// SendToRoute is a bi-directional streaming RPC for sending payment through
	// the Lightning Network. This method differs from SendPayment in that it
	// allows users to specify a full route manually. This can be used for things
	// like rebalancing, and atomic swaps.
	SendToRoute(ctx context.Context, opts ...grpc.CallOption) (Lightning_SendToRouteClient, error)
	// *
	// SendToRouteSync is a synchronous version of SendToRoute. It Will block
	// until the payment either fails or succeeds.
	SendToRouteSync(ctx context.Context, in *SendToRouteRequest, opts ...grpc.CallOption) (*SendResponse, error)
	// * lncli: `addinvoice`
	// AddInvoice attempts to add a new invoice to the invoice database. Any
	// duplicated invoices are rejected, therefore all invoices *must* have a
	// unique payment preimage.
	AddInvoice(ctx context.Context, in *Invoice, opts ...grpc.CallOption) (*AddInvoiceResponse, error)
	// * lncli: `listinvoices`
	// ListInvoices returns a list of all the invoices currently stored within the
	// database. Any active debug invoices are ignored.
	ListInvoices(ctx context.Context, in *ListInvoiceRequest, opts ...grpc.CallOption) (*ListInvoiceResponse, error)
	// * lncli: `lookupinvoice`
	// LookupInvoice attempts to look up an invoice according to its payment hash.
	// The passed payment hash *must* be exactly 32 bytes, if not, an error is
	// returned.
	LookupInvoice(ctx context.Context, in *PaymentHash, opts ...grpc.CallOption) (*Invoice, error)
	// *
	// SubscribeInvoices returns a uni-directional stream (sever -> client) for
	// notifying the client of newly added/settled invoices. The caller can
	// optionally specify the add_index and/or the settle_index. If the add_index
	// is specified, then we'll first start by sending add invoice events for all
	// invoices with an add_index greater than the specified value.  If the
	// settle_index is specified, the next, we'll send out all settle events for
	// invoices with a settle_index greater than the specified value.  One or both
	// of these fields can be set. If no fields are set, then we'll only send out
	// the latest add/settle events.
	SubscribeInvoices(ctx context.Context, in *InvoiceSubscription, opts ...grpc.CallOption) (Lightning_SubscribeInvoicesClient, error)
	// * lncli: `decodepayreq`
	// DecodePayReq takes an encoded payment request string and attempts to decode
	// it, returning a full description of the conditions encoded within the
	// payment request.
	DecodePayReq(ctx context.Context, in *PayReqString, opts ...grpc.CallOption) (*PayReq, error)
	// * lncli: `listpayments`
	// ListPayments returns a list of all outgoing payments.
	ListPayments(ctx context.Context, in *ListPaymentsRequest, opts ...grpc.CallOption) (*ListPaymentsResponse, error)
	// *
	// DeleteAllPayments deletes all outgoing payments from DB.
	DeleteAllPayments(ctx context.Context, in *DeleteAllPaymentsRequest, opts ...grpc.CallOption) (*DeleteAllPaymentsResponse, error)
	// * lncli: `describegraph`
	// DescribeGraph returns a description of the latest graph state from the
	// point of view of the node. The graph information is partitioned into two
	// components: all the nodes/vertexes, and all the edges that connect the
	// vertexes themselves.  As this is a directed graph, the edges also contain
	// the node directional specific routing policy which includes: the time lock
	// delta, fee information, etc.
	DescribeGraph(ctx context.Context, in *ChannelGraphRequest, opts ...grpc.CallOption) (*ChannelGraph, error)
	// * lncli: `getchaninfo`
	// GetChanInfo returns the latest authenticated network announcement for the
	// given channel identified by its channel ID: an 8-byte integer which
	// uniquely identifies the location of transaction's funding output within the
	// blockchain.
	GetChanInfo(ctx context.Context, in *ChanInfoRequest, opts ...grpc.CallOption) (*ChannelEdge, error)
	// * lncli: `getnodeinfo`
	// GetNodeInfo returns the latest advertised, aggregated, and authenticated
	// channel information for the specified node identified by its public key.
	GetNodeInfo(ctx context.Context, in *NodeInfoRequest, opts ...grpc.CallOption) (*NodeInfo, error)
	// * lncli: `queryroutes`
	// QueryRoutes attempts to query the daemon's Channel Router for a possible
	// route to a target destination capable of carrying a specific amount of
	// satoshis. The retuned route contains the full details required to craft and
	// send an HTLC, also including the necessary information that should be
	// present within the Sphinx packet encapsulated within the HTLC.
	QueryRoutes(ctx context.Context, in *QueryRoutesRequest, opts ...grpc.CallOption) (*QueryRoutesResponse, error)
	// * lncli: `getnetworkinfo`
	// GetNetworkInfo returns some basic stats about the known channel graph from
	// the point of view of the node.
	GetNetworkInfo(ctx context.Context, in *NetworkInfoRequest, opts ...grpc.CallOption) (*NetworkInfo, error)
	// * lncli: `stop`
	// StopDaemon will send a shutdown request to the interrupt handler, triggering
	// a graceful shutdown of the daemon.
	StopDaemon(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopResponse, error)
	// *
	// SubscribeChannelGraph launches a streaming RPC that allows the caller to
	// receive notifications upon any changes to the channel graph topology from
	// the point of view of the responding node. Events notified include: new
	// nodes coming online, nodes updating their authenticated attributes, new
	// channels being advertised, updates in the routing policy for a directional
	// channel edge, and when channels are closed on-chain.
	SubscribeChannelGraph(ctx context.Context, in *GraphTopologySubscription, opts ...grpc.CallOption) (Lightning_SubscribeChannelGraphClient, error)
	// * lncli: `debuglevel`
	// DebugLevel allows a caller to programmatically set the logging verbosity of
	// lnd. The logging can be targeted according to a coarse daemon-wide logging
	// level, or in a granular fashion to specify the logging for a target
	// sub-system.
	DebugLevel(ctx context.Context, in *DebugLevelRequest, opts ...grpc.CallOption) (*DebugLevelResponse, error)
	// * lncli: `feereport`
	// FeeReport allows the caller to obtain a report detailing the current fee
	// schedule enforced by the node globally for each channel.
	FeeReport(ctx context.Context, in *FeeReportRequest, opts ...grpc.CallOption) (*FeeReportResponse, error)
	// * lncli: `updatechanpolicy`
	// UpdateChannelPolicy allows the caller to update the fee schedule and
	// channel policies for all channels globally, or a particular channel.
	UpdateChannelPolicy(ctx context.Context, in *PolicyUpdateRequest, opts ...grpc.CallOption) (*PolicyUpdateResponse, error)
	// * lncli: `fwdinghistory`
	// ForwardingHistory allows the caller to query the htlcswitch for a record of
	// all HTLC's forwarded within the target time range, and integer offset
	// within that time range. If no time-range is specified, then the first chunk
	// of the past 24 hrs of forwarding history are returned.
	//
	// A list of forwarding events are returned. The size of each forwarding event
	// is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.
	// As a result each message can only contain 50k entries.  Each response has
	// the index offset of the last entry. The index offset can be provided to the
	// request to allow the caller to skip a series of records.
	ForwardingHistory(ctx context.Context, in *ForwardingHistoryRequest, opts ...grpc.CallOption) (*ForwardingHistoryResponse, error)
}

type lightningClient struct {
	cc *grpc.ClientConn
}

func NewLightningClient(cc *grpc.ClientConn) LightningClient {
	return &lightningClient{cc}
}

func (c *lightningClient) WalletBalance(ctx context.Context, in *WalletBalanceRequest, opts ...grpc.CallOption) (*WalletBalanceResponse, error) {
	out := new(WalletBalanceResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/WalletBalance", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) ChannelBalance(ctx context.Context, in *ChannelBalanceRequest, opts ...grpc.CallOption) (*ChannelBalanceResponse, error) {
	out := new(ChannelBalanceResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/ChannelBalance", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) GetTransactions(ctx context.Context, in *GetTransactionsRequest, opts ...grpc.CallOption) (*TransactionDetails, error) {
	out := new(TransactionDetails)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/GetTransactions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) SendCoins(ctx context.Context, in *SendCoinsRequest, opts ...grpc.CallOption) (*SendCoinsResponse, error) {
	out := new(SendCoinsResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/SendCoins", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) SubscribeTransactions(ctx context.Context, in *GetTransactionsRequest, opts ...grpc.CallOption) (Lightning_SubscribeTransactionsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Lightning_serviceDesc.Streams[0], c.cc, "/lnrpc.Lightning/SubscribeTransactions", opts...)
	if err != nil {
		return nil, err
	}
	x := &lightningSubscribeTransactionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Lightning_SubscribeTransactionsClient interface {
	Recv() (*Transaction, error)
	grpc.ClientStream
}

type lightningSubscribeTransactionsClient struct {
	grpc.ClientStream
}

func (x *lightningSubscribeTransactionsClient) Recv() (*Transaction, error) {
	m := new(Transaction)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *lightningClient) SendMany(ctx context.Context, in *SendManyRequest, opts ...grpc.CallOption) (*SendManyResponse, error) {
	out := new(SendManyResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/SendMany", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) NewAddress(ctx context.Context, in *NewAddressRequest, opts ...grpc.CallOption) (*NewAddressResponse, error) {
	out := new(NewAddressResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/NewAddress", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) NewWitnessAddress(ctx context.Context, in *NewWitnessAddressRequest, opts ...grpc.CallOption) (*NewAddressResponse, error) {
	out := new(NewAddressResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/NewWitnessAddress", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) SignMessage(ctx context.Context, in *SignMessageRequest, opts ...grpc.CallOption) (*SignMessageResponse, error) {
	out := new(SignMessageResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/SignMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) VerifyMessage(ctx context.Context, in *VerifyMessageRequest, opts ...grpc.CallOption) (*VerifyMessageResponse, error) {
	out := new(VerifyMessageResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/VerifyMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) ConnectPeer(ctx context.Context, in *ConnectPeerRequest, opts ...grpc.CallOption) (*ConnectPeerResponse, error) {
	out := new(ConnectPeerResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/ConnectPeer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) DisconnectPeer(ctx context.Context, in *DisconnectPeerRequest, opts ...grpc.CallOption) (*DisconnectPeerResponse, error) {
	out := new(DisconnectPeerResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/DisconnectPeer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) ListPeers(ctx context.Context, in *ListPeersRequest, opts ...grpc.CallOption) (*ListPeersResponse, error) {
	out := new(ListPeersResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/ListPeers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoResponse, error) {
	out := new(GetInfoResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/GetInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) PendingChannels(ctx context.Context, in *PendingChannelsRequest, opts ...grpc.CallOption) (*PendingChannelsResponse, error) {
	out := new(PendingChannelsResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/PendingChannels", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) ListChannels(ctx context.Context, in *ListChannelsRequest, opts ...grpc.CallOption) (*ListChannelsResponse, error) {
	out := new(ListChannelsResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/ListChannels", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) ClosedChannels(ctx context.Context, in *ClosedChannelsRequest, opts ...grpc.CallOption) (*ClosedChannelsResponse, error) {
	out := new(ClosedChannelsResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/ClosedChannels", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) OpenChannelSync(ctx context.Context, in *OpenChannelRequest, opts ...grpc.CallOption) (*ChannelPoint, error) {
	out := new(ChannelPoint)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/OpenChannelSync", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) OpenChannel(ctx context.Context, in *OpenChannelRequest, opts ...grpc.CallOption) (Lightning_OpenChannelClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Lightning_serviceDesc.Streams[1], c.cc, "/lnrpc.Lightning/OpenChannel", opts...)
	if err != nil {
		return nil, err
	}
	x := &lightningOpenChannelClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Lightning_OpenChannelClient interface {
	Recv() (*OpenStatusUpdate, error)
	grpc.ClientStream
}

type lightningOpenChannelClient struct {
	grpc.ClientStream
}

func (x *lightningOpenChannelClient) Recv() (*OpenStatusUpdate, error) {
	m := new(OpenStatusUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *lightningClient) CloseChannel(ctx context.Context, in *CloseChannelRequest, opts ...grpc.CallOption) (Lightning_CloseChannelClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Lightning_serviceDesc.Streams[2], c.cc, "/lnrpc.Lightning/CloseChannel", opts...)
	if err != nil {
		return nil, err
	}
	x := &lightningCloseChannelClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Lightning_CloseChannelClient interface {
	Recv() (*CloseStatusUpdate, error)
	grpc.ClientStream
}

type lightningCloseChannelClient struct {
	grpc.ClientStream
}

func (x *lightningCloseChannelClient) Recv() (*CloseStatusUpdate, error) {
	m := new(CloseStatusUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *lightningClient) SendPayment(ctx context.Context, opts ...grpc.CallOption) (Lightning_SendPaymentClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Lightning_serviceDesc.Streams[3], c.cc, "/lnrpc.Lightning/SendPayment", opts...)
	if err != nil {
		return nil, err
	}
	x := &lightningSendPaymentClient{stream}
	return x, nil
}

type Lightning_SendPaymentClient interface {
	Send(*SendRequest) error
	Recv() (*SendResponse, error)
	grpc.ClientStream
}

type lightningSendPaymentClient struct {
	grpc.ClientStream
}

func (x *lightningSendPaymentClient) Send(m *SendRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *lightningSendPaymentClient) Recv() (*SendResponse, error) {
	m := new(SendResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *lightningClient) SendPaymentSync(ctx context.Context, in *SendRequest, opts ...grpc.CallOption) (*SendResponse, error) {
	out := new(SendResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/SendPaymentSync", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) SendToRoute(ctx context.Context, opts ...grpc.CallOption) (Lightning_SendToRouteClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Lightning_serviceDesc.Streams[4], c.cc, "/lnrpc.Lightning/SendToRoute", opts...)
	if err != nil {
		return nil, err
	}
	x := &lightningSendToRouteClient{stream}
	return x, nil
}

type Lightning_SendToRouteClient interface {
	Send(*SendToRouteRequest) error
	Recv() (*SendResponse, error)
	grpc.ClientStream
}

type lightningSendToRouteClient struct {
	grpc.ClientStream
}

func (x *lightningSendToRouteClient) Send(m *SendToRouteRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *lightningSendToRouteClient) Recv() (*SendResponse, error) {
	m := new(SendResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *lightningClient) SendToRouteSync(ctx context.Context, in *SendToRouteRequest, opts ...grpc.CallOption) (*SendResponse, error) {
	out := new(SendResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/SendToRouteSync", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) AddInvoice(ctx context.Context, in *Invoice, opts ...grpc.CallOption) (*AddInvoiceResponse, error) {
	out := new(AddInvoiceResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/AddInvoice", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) ListInvoices(ctx context.Context, in *ListInvoiceRequest, opts ...grpc.CallOption) (*ListInvoiceResponse, error) {
	out := new(ListInvoiceResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/ListInvoices", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) LookupInvoice(ctx context.Context, in *PaymentHash, opts ...grpc.CallOption) (*Invoice, error) {
	out := new(Invoice)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/LookupInvoice", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) SubscribeInvoices(ctx context.Context, in *InvoiceSubscription, opts ...grpc.CallOption) (Lightning_SubscribeInvoicesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Lightning_serviceDesc.Streams[5], c.cc, "/lnrpc.Lightning/SubscribeInvoices", opts...)
	if err != nil {
		return nil, err
	}
	x := &lightningSubscribeInvoicesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Lightning_SubscribeInvoicesClient interface {
	Recv() (*Invoice, error)
	grpc.ClientStream
}

type lightningSubscribeInvoicesClient struct {
	grpc.ClientStream
}

func (x *lightningSubscribeInvoicesClient) Recv() (*Invoice, error) {
	m := new(Invoice)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *lightningClient) DecodePayReq(ctx context.Context, in *PayReqString, opts ...grpc.CallOption) (*PayReq, error) {
	out := new(PayReq)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/DecodePayReq", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) ListPayments(ctx context.Context, in *ListPaymentsRequest, opts ...grpc.CallOption) (*ListPaymentsResponse, error) {
	out := new(ListPaymentsResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/ListPayments", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) DeleteAllPayments(ctx context.Context, in *DeleteAllPaymentsRequest, opts ...grpc.CallOption) (*DeleteAllPaymentsResponse, error) {
	out := new(DeleteAllPaymentsResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/DeleteAllPayments", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) DescribeGraph(ctx context.Context, in *ChannelGraphRequest, opts ...grpc.CallOption) (*ChannelGraph, error) {
	out := new(ChannelGraph)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/DescribeGraph", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) GetChanInfo(ctx context.Context, in *ChanInfoRequest, opts ...grpc.CallOption) (*ChannelEdge, error) {
	out := new(ChannelEdge)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/GetChanInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) GetNodeInfo(ctx context.Context, in *NodeInfoRequest, opts ...grpc.CallOption) (*NodeInfo, error) {
	out := new(NodeInfo)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/GetNodeInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) QueryRoutes(ctx context.Context, in *QueryRoutesRequest, opts ...grpc.CallOption) (*QueryRoutesResponse, error) {
	out := new(QueryRoutesResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/QueryRoutes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) GetNetworkInfo(ctx context.Context, in *NetworkInfoRequest, opts ...grpc.CallOption) (*NetworkInfo, error) {
	out := new(NetworkInfo)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/GetNetworkInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) StopDaemon(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopResponse, error) {
	out := new(StopResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/StopDaemon", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) SubscribeChannelGraph(ctx context.Context, in *GraphTopologySubscription, opts ...grpc.CallOption) (Lightning_SubscribeChannelGraphClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Lightning_serviceDesc.Streams[6], c.cc, "/lnrpc.Lightning/SubscribeChannelGraph", opts...)
	if err != nil {
		return nil, err
	}
	x := &lightningSubscribeChannelGraphClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Lightning_SubscribeChannelGraphClient interface {
	Recv() (*GraphTopologyUpdate, error)
	grpc.ClientStream
}

type lightningSubscribeChannelGraphClient struct {
	grpc.ClientStream
}

func (x *lightningSubscribeChannelGraphClient) Recv() (*GraphTopologyUpdate, error) {
	m := new(GraphTopologyUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *lightningClient) DebugLevel(ctx context.Context, in *DebugLevelRequest, opts ...grpc.CallOption) (*DebugLevelResponse, error) {
	out := new(DebugLevelResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/DebugLevel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) FeeReport(ctx context.Context, in *FeeReportRequest, opts ...grpc.CallOption) (*FeeReportResponse, error) {
	out := new(FeeReportResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/FeeReport", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) UpdateChannelPolicy(ctx context.Context, in *PolicyUpdateRequest, opts ...grpc.CallOption) (*PolicyUpdateResponse, error) {
	out := new(PolicyUpdateResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/UpdateChannelPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningClient) ForwardingHistory(ctx context.Context, in *ForwardingHistoryRequest, opts ...grpc.CallOption) (*ForwardingHistoryResponse, error) {
	out := new(ForwardingHistoryResponse)
	err := grpc.Invoke(ctx, "/lnrpc.Lightning/ForwardingHistory", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Lightning service

type LightningServer interface {
	// * lncli: `walletbalance`
	// WalletBalance returns total unspent outputs(confirmed and unconfirmed), all
	// confirmed unspent outputs and all unconfirmed unspent outputs under control
	// of the wallet.
	WalletBalance(context.Context, *WalletBalanceRequest) (*WalletBalanceResponse, error)
	// * lncli: `channelbalance`
	// ChannelBalance returns the total funds available across all open channels
	// in satoshis.
	ChannelBalance(context.Context, *ChannelBalanceRequest) (*ChannelBalanceResponse, error)
	// * lncli: `listchaintxns`
	// GetTransactions returns a list describing all the known transactions
	// relevant to the wallet.
	GetTransactions(context.Context, *GetTransactionsRequest) (*TransactionDetails, error)
	// * lncli: `sendcoins`
	// SendCoins executes a request to send coins to a particular address. Unlike
	// SendMany, this RPC call only allows creating a single output at a time. If
	// neither target_conf, or sat_per_byte are set, then the internal wallet will
	// consult its fee model to determine a fee for the default confirmation
	// target.
	SendCoins(context.Context, *SendCoinsRequest) (*SendCoinsResponse, error)
	// *
	// SubscribeTransactions creates a uni-directional stream from the server to
	// the client in which any newly discovered transactions relevant to the
	// wallet are sent over.
	SubscribeTransactions(*GetTransactionsRequest, Lightning_SubscribeTransactionsServer) error
	// * lncli: `sendmany`
	// SendMany handles a request for a transaction that creates multiple specified
	// outputs in parallel. If neither target_conf, or sat_per_byte are set, then
	// the internal wallet will consult its fee model to determine a fee for the
	// default confirmation target.
	SendMany(context.Context, *SendManyRequest) (*SendManyResponse, error)
	// * lncli: `newaddress`
	// NewAddress creates a new address under control of the local wallet.
	NewAddress(context.Context, *NewAddressRequest) (*NewAddressResponse, error)
	// *
	// NewWitnessAddress creates a new witness address under control of the local wallet.
	NewWitnessAddress(context.Context, *NewWitnessAddressRequest) (*NewAddressResponse, error)
	// * lncli: `signmessage`
	// SignMessage signs a message with this node's private key. The returned
	// signature string is `zbase32` encoded and pubkey recoverable, meaning that
	// only the message digest and signature are needed for verification.
	SignMessage(context.Context, *SignMessageRequest) (*SignMessageResponse, error)
	// * lncli: `verifymessage`
	// VerifyMessage verifies a signature over a msg. The signature must be
	// zbase32 encoded and signed by an active node in the resident node's
	// channel database. In addition to returning the validity of the signature,
	// VerifyMessage also returns the recovered pubkey from the signature.
	VerifyMessage(context.Context, *VerifyMessageRequest) (*VerifyMessageResponse, error)
	// * lncli: `connect`
	// ConnectPeer attempts to establish a connection to a remote peer. This is at
	// the networking level, and is used for communication between nodes. This is
	// distinct from establishing a channel with a peer.
	ConnectPeer(context.Context, *ConnectPeerRequest) (*ConnectPeerResponse, error)
	// * lncli: `disconnect`
	// DisconnectPeer attempts to disconnect one peer from another identified by a
	// given pubKey. In the case that we currently have a pending or active channel
	// with the target peer, then this action will be not be allowed.
	DisconnectPeer(context.Context, *DisconnectPeerRequest) (*DisconnectPeerResponse, error)
	// * lncli: `listpeers`
	// ListPeers returns a verbose listing of all currently active peers.
	ListPeers(context.Context, *ListPeersRequest) (*ListPeersResponse, error)
	// * lncli: `getinfo`
	// GetInfo returns general information concerning the lightning node including
	// it's identity pubkey, alias, the chains it is connected to, and information
	// concerning the number of open+pending channels.
	GetInfo(context.Context, *GetInfoRequest) (*GetInfoResponse, error)
	// * lncli: `pendingchannels`
	// PendingChannels returns a list of all the channels that are currently
	// considered "pending". A channel is pending if it has finished the funding
	// workflow and is waiting for confirmations for the funding txn, or is in the
	// process of closure, either initiated cooperatively or non-cooperatively.
	PendingChannels(context.Context, *PendingChannelsRequest) (*PendingChannelsResponse, error)
	// * lncli: `listchannels`
	// ListChannels returns a description of all the open channels that this node
	// is a participant in.
	ListChannels(context.Context, *ListChannelsRequest) (*ListChannelsResponse, error)
	// * lncli: `closedchannels`
	// ClosedChannels returns a description of all the closed channels that
	// this node was a participant in.
	ClosedChannels(context.Context, *ClosedChannelsRequest) (*ClosedChannelsResponse, error)
	// *
	// OpenChannelSync is a synchronous version of the OpenChannel RPC call. This
	// call is meant to be consumed by clients to the REST proxy. As with all
	// other sync calls, all byte slices are intended to be populated as hex
	// encoded strings.
	OpenChannelSync(context.Context, *OpenChannelRequest) (*ChannelPoint, error)
	// * lncli: `openchannel`
	// OpenChannel attempts to open a singly funded channel specified in the
	// request to a remote peer. Users are able to specify a target number of
	// blocks that the funding transaction should be confirmed in, or a manual fee
	// rate to us for the funding transaction. If neither are specified, then a
	// lax block confirmation target is used.
	OpenChannel(*OpenChannelRequest, Lightning_OpenChannelServer) error
	// * lncli: `closechannel`
	// CloseChannel attempts to close an active channel identified by its channel
	// outpoint (ChannelPoint). The actions of this method can additionally be
	// augmented to attempt a force close after a timeout period in the case of an
	// inactive peer. If a non-force close (cooperative closure) is requested,
	// then the user can specify either a target number of blocks until the
	// closure transaction is confirmed, or a manual fee rate. If neither are
	// specified, then a default lax, block confirmation target is used.
	CloseChannel(*CloseChannelRequest, Lightning_CloseChannelServer) error
	// * lncli: `sendpayment`
	// SendPayment dispatches a bi-directional streaming RPC for sending payments
	// through the Lightning Network. A single RPC invocation creates a persistent
	// bi-directional stream allowing clients to rapidly send payments through the
	// Lightning Network with a single persistent connection.
	SendPayment(Lightning_SendPaymentServer) error
	// *
	// SendPaymentSync is the synchronous non-streaming version of SendPayment.
	// This RPC is intended to be consumed by clients of the REST proxy.
	// Additionally, this RPC expects the destination's public key and the payment
	// hash (if any) to be encoded as hex strings.
	SendPaymentSync(context.Context, *SendRequest) (*SendResponse, error)
	// * lncli: `sendtoroute`
	// SendToRoute is a bi-directional streaming RPC for sending payment through
	// the Lightning Network. This method differs from SendPayment in that it
	// allows users to specify a full route manually. This can be used for things
	// like rebalancing, and atomic swaps.
	SendToRoute(Lightning_SendToRouteServer) error
	// *
	// SendToRouteSync is a synchronous version of SendToRoute. It Will block
	// until the payment either fails or succeeds.
	SendToRouteSync(context.Context, *SendToRouteRequest) (*SendResponse, error)
	// * lncli: `addinvoice`
	// AddInvoice attempts to add a new invoice to the invoice database. Any
	// duplicated invoices are rejected, therefore all invoices *must* have a
	// unique payment preimage.
	AddInvoice(context.Context, *Invoice) (*AddInvoiceResponse, error)
	// * lncli: `listinvoices`
	// ListInvoices returns a list of all the invoices currently stored within the
	// database. Any active debug invoices are ignored.
	ListInvoices(context.Context, *ListInvoiceRequest) (*ListInvoiceResponse, error)
	// * lncli: `lookupinvoice`
	// LookupInvoice attempts to look up an invoice according to its payment hash.
	// The passed payment hash *must* be exactly 32 bytes, if not, an error is
	// returned.
	LookupInvoice(context.Context, *PaymentHash) (*Invoice, error)
	// *
	// SubscribeInvoices returns a uni-directional stream (sever -> client) for
	// notifying the client of newly added/settled invoices. The caller can
	// optionally specify the add_index and/or the settle_index. If the add_index
	// is specified, then we'll first start by sending add invoice events for all
	// invoices with an add_index greater than the specified value.  If the
	// settle_index is specified, the next, we'll send out all settle events for
	// invoices with a settle_index greater than the specified value.  One or both
	// of these fields can be set. If no fields are set, then we'll only send out
	// the latest add/settle events.
	SubscribeInvoices(*InvoiceSubscription, Lightning_SubscribeInvoicesServer) error
	// * lncli: `decodepayreq`
	// DecodePayReq takes an encoded payment request string and attempts to decode
	// it, returning a full description of the conditions encoded within the
	// payment request.
	DecodePayReq(context.Context, *PayReqString) (*PayReq, error)
	// * lncli: `listpayments`
	// ListPayments returns a list of all outgoing payments.
	ListPayments(context.Context, *ListPaymentsRequest) (*ListPaymentsResponse, error)
	// *
	// DeleteAllPayments deletes all outgoing payments from DB.
	DeleteAllPayments(context.Context, *DeleteAllPaymentsRequest) (*DeleteAllPaymentsResponse, error)
	// * lncli: `describegraph`
	// DescribeGraph returns a description of the latest graph state from the
	// point of view of the node. The graph information is partitioned into two
	// components: all the nodes/vertexes, and all the edges that connect the
	// vertexes themselves.  As this is a directed graph, the edges also contain
	// the node directional specific routing policy which includes: the time lock
	// delta, fee information, etc.
	DescribeGraph(context.Context, *ChannelGraphRequest) (*ChannelGraph, error)
	// * lncli: `getchaninfo`
	// GetChanInfo returns the latest authenticated network announcement for the
	// given channel identified by its channel ID: an 8-byte integer which
	// uniquely identifies the location of transaction's funding output within the
	// blockchain.
	GetChanInfo(context.Context, *ChanInfoRequest) (*ChannelEdge, error)
	// * lncli: `getnodeinfo`
	// GetNodeInfo returns the latest advertised, aggregated, and authenticated
	// channel information for the specified node identified by its public key.
	GetNodeInfo(context.Context, *NodeInfoRequest) (*NodeInfo, error)
	// * lncli: `queryroutes`
	// QueryRoutes attempts to query the daemon's Channel Router for a possible
	// route to a target destination capable of carrying a specific amount of
	// satoshis. The retuned route contains the full details required to craft and
	// send an HTLC, also including the necessary information that should be
	// present within the Sphinx packet encapsulated within the HTLC.
	QueryRoutes(context.Context, *QueryRoutesRequest) (*QueryRoutesResponse, error)
	// * lncli: `getnetworkinfo`
	// GetNetworkInfo returns some basic stats about the known channel graph from
	// the point of view of the node.
	GetNetworkInfo(context.Context, *NetworkInfoRequest) (*NetworkInfo, error)
	// * lncli: `stop`
	// StopDaemon will send a shutdown request to the interrupt handler, triggering
	// a graceful shutdown of the daemon.
	StopDaemon(context.Context, *StopRequest) (*StopResponse, error)
	// *
	// SubscribeChannelGraph launches a streaming RPC that allows the caller to
	// receive notifications upon any changes to the channel graph topology from
	// the point of view of the responding node. Events notified include: new
	// nodes coming online, nodes updating their authenticated attributes, new
	// channels being advertised, updates in the routing policy for a directional
	// channel edge, and when channels are closed on-chain.
	SubscribeChannelGraph(*GraphTopologySubscription, Lightning_SubscribeChannelGraphServer) error
	// * lncli: `debuglevel`
	// DebugLevel allows a caller to programmatically set the logging verbosity of
	// lnd. The logging can be targeted according to a coarse daemon-wide logging
	// level, or in a granular fashion to specify the logging for a target
	// sub-system.
	DebugLevel(context.Context, *DebugLevelRequest) (*DebugLevelResponse, error)
	// * lncli: `feereport`
	// FeeReport allows the caller to obtain a report detailing the current fee
	// schedule enforced by the node globally for each channel.
	FeeReport(context.Context, *FeeReportRequest) (*FeeReportResponse, error)
	// * lncli: `updatechanpolicy`
	// UpdateChannelPolicy allows the caller to update the fee schedule and
	// channel policies for all channels globally, or a particular channel.
	UpdateChannelPolicy(context.Context, *PolicyUpdateRequest) (*PolicyUpdateResponse, error)
	// * lncli: `fwdinghistory`
	// ForwardingHistory allows the caller to query the htlcswitch for a record of
	// all HTLC's forwarded within the target time range, and integer offset
	// within that time range. If no time-range is specified, then the first chunk
	// of the past 24 hrs of forwarding history are returned.
	//
	// A list of forwarding events are returned. The size of each forwarding event
	// is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.
	// As a result each message can only contain 50k entries.  Each response has
	// the index offset of the last entry. The index offset can be provided to the
	// request to allow the caller to skip a series of records.
	ForwardingHistory(context.Context, *ForwardingHistoryRequest) (*ForwardingHistoryResponse, error)
}

func RegisterLightningServer(s *grpc.Server, srv LightningServer) {
	s.RegisterService(&_Lightning_serviceDesc, srv)
}

func _Lightning_WalletBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WalletBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).WalletBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/WalletBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).WalletBalance(ctx, req.(*WalletBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_ChannelBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).ChannelBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/ChannelBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).ChannelBalance(ctx, req.(*ChannelBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_GetTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).GetTransactions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/GetTransactions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).GetTransactions(ctx, req.(*GetTransactionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_SendCoins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendCoinsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).SendCoins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/SendCoins",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).SendCoins(ctx, req.(*SendCoinsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_SubscribeTransactions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetTransactionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LightningServer).SubscribeTransactions(m, &lightningSubscribeTransactionsServer{stream})
}

type Lightning_SubscribeTransactionsServer interface {
	Send(*Transaction) error
	grpc.ServerStream
}

type lightningSubscribeTransactionsServer struct {
	grpc.ServerStream
}

func (x *lightningSubscribeTransactionsServer) Send(m *Transaction) error {
	return x.ServerStream.SendMsg(m)
}

func _Lightning_SendMany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendManyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).SendMany(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/SendMany",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).SendMany(ctx, req.(*SendManyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_NewAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).NewAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/NewAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).NewAddress(ctx, req.(*NewAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_NewWitnessAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewWitnessAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).NewWitnessAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/NewWitnessAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).NewWitnessAddress(ctx, req.(*NewWitnessAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_SignMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).SignMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/SignMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).SignMessage(ctx, req.(*SignMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_VerifyMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).VerifyMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/VerifyMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).VerifyMessage(ctx, req.(*VerifyMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_ConnectPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).ConnectPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/ConnectPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).ConnectPeer(ctx, req.(*ConnectPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_DisconnectPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisconnectPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).DisconnectPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/DisconnectPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).DisconnectPeer(ctx, req.(*DisconnectPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_ListPeers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPeersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).ListPeers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/ListPeers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).ListPeers(ctx, req.(*ListPeersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_GetInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).GetInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/GetInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).GetInfo(ctx, req.(*GetInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_PendingChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PendingChannelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).PendingChannels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/PendingChannels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).PendingChannels(ctx, req.(*PendingChannelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_ListChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListChannelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).ListChannels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/ListChannels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).ListChannels(ctx, req.(*ListChannelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_ClosedChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClosedChannelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).ClosedChannels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/ClosedChannels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).ClosedChannels(ctx, req.(*ClosedChannelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_OpenChannelSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).OpenChannelSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/OpenChannelSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).OpenChannelSync(ctx, req.(*OpenChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_OpenChannel_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(OpenChannelRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LightningServer).OpenChannel(m, &lightningOpenChannelServer{stream})
}

type Lightning_OpenChannelServer interface {
	Send(*OpenStatusUpdate) error
	grpc.ServerStream
}

type lightningOpenChannelServer struct {
	grpc.ServerStream
}

func (x *lightningOpenChannelServer) Send(m *OpenStatusUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func _Lightning_CloseChannel_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CloseChannelRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LightningServer).CloseChannel(m, &lightningCloseChannelServer{stream})
}

type Lightning_CloseChannelServer interface {
	Send(*CloseStatusUpdate) error
	grpc.ServerStream
}

type lightningCloseChannelServer struct {
	grpc.ServerStream
}

func (x *lightningCloseChannelServer) Send(m *CloseStatusUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func _Lightning_SendPayment_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LightningServer).SendPayment(&lightningSendPaymentServer{stream})
}

type Lightning_SendPaymentServer interface {
	Send(*SendResponse) error
	Recv() (*SendRequest, error)
	grpc.ServerStream
}

type lightningSendPaymentServer struct {
	grpc.ServerStream
}

func (x *lightningSendPaymentServer) Send(m *SendResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *lightningSendPaymentServer) Recv() (*SendRequest, error) {
	m := new(SendRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Lightning_SendPaymentSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).SendPaymentSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/SendPaymentSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).SendPaymentSync(ctx, req.(*SendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_SendToRoute_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LightningServer).SendToRoute(&lightningSendToRouteServer{stream})
}

type Lightning_SendToRouteServer interface {
	Send(*SendResponse) error
	Recv() (*SendToRouteRequest, error)
	grpc.ServerStream
}

type lightningSendToRouteServer struct {
	grpc.ServerStream
}

func (x *lightningSendToRouteServer) Send(m *SendResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *lightningSendToRouteServer) Recv() (*SendToRouteRequest, error) {
	m := new(SendToRouteRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Lightning_SendToRouteSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendToRouteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).SendToRouteSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/SendToRouteSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).SendToRouteSync(ctx, req.(*SendToRouteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_AddInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Invoice)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).AddInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/AddInvoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).AddInvoice(ctx, req.(*Invoice))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_ListInvoices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInvoiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).ListInvoices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/ListInvoices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).ListInvoices(ctx, req.(*ListInvoiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_LookupInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PaymentHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).LookupInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/LookupInvoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).LookupInvoice(ctx, req.(*PaymentHash))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_SubscribeInvoices_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InvoiceSubscription)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LightningServer).SubscribeInvoices(m, &lightningSubscribeInvoicesServer{stream})
}

type Lightning_SubscribeInvoicesServer interface {
	Send(*Invoice) error
	grpc.ServerStream
}

type lightningSubscribeInvoicesServer struct {
	grpc.ServerStream
}

func (x *lightningSubscribeInvoicesServer) Send(m *Invoice) error {
	return x.ServerStream.SendMsg(m)
}

func _Lightning_DecodePayReq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PayReqString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).DecodePayReq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/DecodePayReq",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).DecodePayReq(ctx, req.(*PayReqString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_ListPayments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPaymentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).ListPayments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/ListPayments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).ListPayments(ctx, req.(*ListPaymentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_DeleteAllPayments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAllPaymentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).DeleteAllPayments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/DeleteAllPayments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).DeleteAllPayments(ctx, req.(*DeleteAllPaymentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_DescribeGraph_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelGraphRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).DescribeGraph(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/DescribeGraph",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).DescribeGraph(ctx, req.(*ChannelGraphRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_GetChanInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChanInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).GetChanInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/GetChanInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).GetChanInfo(ctx, req.(*ChanInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_GetNodeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).GetNodeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/GetNodeInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).GetNodeInfo(ctx, req.(*NodeInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_QueryRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRoutesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).QueryRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/QueryRoutes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).QueryRoutes(ctx, req.(*QueryRoutesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_GetNetworkInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).GetNetworkInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/GetNetworkInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).GetNetworkInfo(ctx, req.(*NetworkInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_StopDaemon_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).StopDaemon(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/StopDaemon",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).StopDaemon(ctx, req.(*StopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_SubscribeChannelGraph_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GraphTopologySubscription)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LightningServer).SubscribeChannelGraph(m, &lightningSubscribeChannelGraphServer{stream})
}

type Lightning_SubscribeChannelGraphServer interface {
	Send(*GraphTopologyUpdate) error
	grpc.ServerStream
}

type lightningSubscribeChannelGraphServer struct {
	grpc.ServerStream
}

func (x *lightningSubscribeChannelGraphServer) Send(m *GraphTopologyUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func _Lightning_DebugLevel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DebugLevelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).DebugLevel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/DebugLevel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).DebugLevel(ctx, req.(*DebugLevelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_FeeReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FeeReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).FeeReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/FeeReport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).FeeReport(ctx, req.(*FeeReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_UpdateChannelPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicyUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).UpdateChannelPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/UpdateChannelPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).UpdateChannelPolicy(ctx, req.(*PolicyUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lightning_ForwardingHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForwardingHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServer).ForwardingHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lnrpc.Lightning/ForwardingHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServer).ForwardingHistory(ctx, req.(*ForwardingHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Lightning_serviceDesc = grpc.ServiceDesc{
	ServiceName: "lnrpc.Lightning",
	HandlerType: (*LightningServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "WalletBalance",
			Handler:    _Lightning_WalletBalance_Handler,
		},
		{
			MethodName: "ChannelBalance",
			Handler:    _Lightning_ChannelBalance_Handler,
		},
		{
			MethodName: "GetTransactions",
			Handler:    _Lightning_GetTransactions_Handler,
		},
		{
			MethodName: "SendCoins",
			Handler:    _Lightning_SendCoins_Handler,
		},
		{
			MethodName: "SendMany",
			Handler:    _Lightning_SendMany_Handler,
		},
		{
			MethodName: "NewAddress",
			Handler:    _Lightning_NewAddress_Handler,
		},
		{
			MethodName: "NewWitnessAddress",
			Handler:    _Lightning_NewWitnessAddress_Handler,
		},
		{
			MethodName: "SignMessage",
			Handler:    _Lightning_SignMessage_Handler,
		},
		{
			MethodName: "VerifyMessage",
			Handler:    _Lightning_VerifyMessage_Handler,
		},
		{
			MethodName: "ConnectPeer",
			Handler:    _Lightning_ConnectPeer_Handler,
		},
		{
			MethodName: "DisconnectPeer",
			Handler:    _Lightning_DisconnectPeer_Handler,
		},
		{
			MethodName: "ListPeers",
			Handler:    _Lightning_ListPeers_Handler,
		},
		{
			MethodName: "GetInfo",
			Handler:    _Lightning_GetInfo_Handler,
		},
		{
			MethodName: "PendingChannels",
			Handler:    _Lightning_PendingChannels_Handler,
		},
		{
			MethodName: "ListChannels",
			Handler:    _Lightning_ListChannels_Handler,
		},
		{
			MethodName: "ClosedChannels",
			Handler:    _Lightning_ClosedChannels_Handler,
		},
		{
			MethodName: "OpenChannelSync",
			Handler:    _Lightning_OpenChannelSync_Handler,
		},
		{
			MethodName: "SendPaymentSync",
			Handler:    _Lightning_SendPaymentSync_Handler,
		},
		{
			MethodName: "SendToRouteSync",
			Handler:    _Lightning_SendToRouteSync_Handler,
		},
		{
			MethodName: "AddInvoice",
			Handler:    _Lightning_AddInvoice_Handler,
		},
		{
			MethodName: "ListInvoices",
			Handler:    _Lightning_ListInvoices_Handler,
		},
		{
			MethodName: "LookupInvoice",
			Handler:    _Lightning_LookupInvoice_Handler,
		},
		{
			MethodName: "DecodePayReq",
			Handler:    _Lightning_DecodePayReq_Handler,
		},
		{
			MethodName: "ListPayments",
			Handler:    _Lightning_ListPayments_Handler,
		},
		{
			MethodName: "DeleteAllPayments",
			Handler:    _Lightning_DeleteAllPayments_Handler,
		},
		{
			MethodName: "DescribeGraph",
			Handler:    _Lightning_DescribeGraph_Handler,
		},
		{
			MethodName: "GetChanInfo",
			Handler:    _Lightning_GetChanInfo_Handler,
		},
		{
			MethodName: "GetNodeInfo",
			Handler:    _Lightning_GetNodeInfo_Handler,
		},
		{
			MethodName: "QueryRoutes",
			Handler:    _Lightning_QueryRoutes_Handler,
		},
		{
			MethodName: "GetNetworkInfo",
			Handler:    _Lightning_GetNetworkInfo_Handler,
		},
		{
			MethodName: "StopDaemon",
			Handler:    _Lightning_StopDaemon_Handler,
		},
		{
			MethodName: "DebugLevel",
			Handler:    _Lightning_DebugLevel_Handler,
		},
		{
			MethodName: "FeeReport",
			Handler:    _Lightning_FeeReport_Handler,
		},
		{
			MethodName: "UpdateChannelPolicy",
			Handler:    _Lightning_UpdateChannelPolicy_Handler,
		},
		{
			MethodName: "ForwardingHistory",
			Handler:    _Lightning_ForwardingHistory_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeTransactions",
			Handler:       _Lightning_SubscribeTransactions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "OpenChannel",
			Handler:       _Lightning_OpenChannel_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "CloseChannel",
			Handler:       _Lightning_CloseChannel_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SendPayment",
			Handler:       _Lightning_SendPayment_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SendToRoute",
			Handler:       _Lightning_SendToRoute_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SubscribeInvoices",
			Handler:       _Lightning_SubscribeInvoices_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeChannelGraph",
			Handler:       _Lightning_SubscribeChannelGraph_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "rpc.proto",
}

func init() { proto.RegisterFile("rpc.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 6227 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x5c, 0xcd, 0x6f, 0x1c, 0xc9,
	0x75, 0x57, 0x0f, 0x87, 0x1f, 0xf3, 0x66, 0x48, 0x0e, 0x8b, 0x14, 0x35, 0x9a, 0xdd, 0xd5, 0x6a,
	0xdb, 0xc2, 0x4a, 0x66, 0x36, 0x92, 0x96, 0xb6, 0x37, 0xeb, 0xdd, 0xc4, 0x8e, 0x44, 0x52, 0xa2,
	0x6c, 0xae, 0x44, 0x37, 0x25, 0x2b, 0xb1, 0x13, 0x8c, 0x9b, 0x33, 0xc5, 0x61, 0x5b, 0x33, 0xdd,
	0xed, 0xee, 0x1e, 0x52, 0xe3, 0x8d, 0x00, 0xe7, 0x03, 0x39, 0xc5, 0x08, 0x82, 0xe4, 0xe2, 0x00,
	0x41, 0x00, 0x07, 0x08, 0x9c, 0x3f, 0x20, 0xb9, 0x38, 0x01, 0x72, 0xc8, 0xc5, 0x01, 0x82, 0x1c,
	0x7c, 0x32, 0x72, 0x4c, 0x72, 0x48, 0x82, 0x5c, 0x02, 0xe4, 0x1a, 0x04, 0xef, 0xd5, 0x47, 0x57,
	0x75, 0x37, 0x45, 0xf9, 0x23, 0xb9, 0x4d, 0xfd, 0xea, 0x75, 0x7d, 0xbe, 0xaf, 0x7a, 0xf5, 0x6a,
	0xa0, 0x91, 0xc4, 0xfd, 0x9b, 0x71, 0x12, 0x65, 0x11, 0x9b, 0x1d, 0x85, 0x49, 0xdc, 0xef, 0xbe,
	0x3e, 0x8c, 0xa2, 0xe1, 0x88, 0xdf, 0xf2, 0xe3, 0xe0, 0x96, 0x1f, 0x86, 0x51, 0xe6, 0x67, 0x41,
	0x14, 0xa6, 0x82, 0xc8, 0xfd, 0x1a, 0x2c, 0xdd, 0xe7, 0xe1, 0x01, 0xe7, 0x03, 0x8f, 0x7f, 0x63,
	0xc2, 0xd3, 0x8c, 0xfd, 0x1c, 0xac, 0xf8, 0xfc, 0x9b, 0x9c, 0x0f, 0x7a, 0xb1, 0x9f, 0xa6, 0xf1,
	0x71, 0xe2, 0xa7, 0xbc, 0xe3, 0x5c, 0x75, 0x6e, 0xb4, 0xbc, 0xb6, 0xa8, 0xd8, 0xd7, 0x38, 0x7b,
	0x0b, 0x5a, 0x29, 0x92, 0xf2, 0x30, 0x4b, 0xa2, 0x78, 0xda, 0xa9, 0x11, 0x5d, 0x13, 0xb1, 0x1d,
	0x01, 0xb9, 0x23, 0x58, 0xd6, 0x3d, 0xa4, 0x71, 0x14, 0xa6, 0x9c, 0xdd, 0x86, 0xb5, 0x7e, 0x10,
	0x1f, 0xf3, 0xa4, 0x47, 0x1f, 0x8f, 0x43, 0x3e, 0x8e, 0xc2, 0xa0, 0xdf, 0x71, 0xae, 0xce, 0xdc,
	0x68, 0x78, 0x4c, 0xd4, 0xe1, 0x17, 0x1f, 0xc9, 0x1a, 0x76, 0x1d, 0x96, 0x79, 0x28, 0x70, 0x3e,
	0xa0, 0xaf, 0x64, 0x57, 0x4b, 0x39, 0x8c, 0x1f, 0xb8, 0x7f, 0xe7, 0xc0, 0xca, 0x83, 0x30, 0xc8,
	0x9e, 0xfa, 0xa3, 0x11, 0xcf, 0xd4, 0x9c, 0xae, 0xc3, 0xf2, 0x29, 0x01, 0x34, 0xa7, 0xd3, 0x28,
	0x19, 0xc8, 0x19, 0x2d, 0x09, 0x78, 0x5f, 0xa2, 0x67, 0x8e, 0xac, 0x76, 0xe6, 0xc8, 0x2a, 0x97,
	0x6b, 0xe6, 0x8c, 0xe5, 0xba, 0x0e, 0xcb, 0x09, 0xef, 0x47, 0x27, 0x3c, 0x99, 0xf6, 0x4e, 0x83,
	0x70, 0x10, 0x9d, 0x76, 0xea, 0x57, 0x9d, 0x1b, 0xb3, 0xde, 0x92, 0x82, 0x9f, 0x12, 0xea, 0xae,
	0x01, 0x33, 0x67, 0x21, 0xd6, 0xcd, 0x1d, 0xc2, 0xea, 0x93, 0x70, 0x14, 0xf5, 0x9f, 0xfd, 0x84,
	0xb3, 0xab, 0xe8, 0xbe, 0x56, 0xd9, 0xfd, 0x3a, 0xac, 0xd9, 0x1d, 0xc9, 0x01, 0x70, 0xb8, 0xb8,
	0x75, 0xec, 0x87, 0x43, 0xae, 0x9a, 0x54, 0x43, 0xf8, 0x24, 0xb4, 0xfb, 0x93, 0x24, 0xe1, 0x61,
	0x69, 0x0c, 0xcb, 0x12, 0xd7, 0x83, 0x78, 0x0b, 0x5a, 0x21, 0x3f, 0xcd, 0xc9, 0x24, 0xcb, 0x84,
	0xfc, 0x54, 0x91, 0xb8, 0x1d, 0x58, 0x2f, 0x76, 0x23, 0x07, 0xf0, 0x9d, 0x1a, 0x34, 0x1f, 0x27,
	0x7e, 0x98, 0xfa, 0x7d, 0xe4, 0x62, 0xd6, 0x81, 0xf9, 0xec, 0x79, 0xef, 0xd8, 0x4f, 0x8f, 0xa9,
	0xbb, 0x86, 0xa7, 0x8a, 0x6c, 0x1d, 0xe6, 0xfc, 0x71, 0x34, 0x09, 0x33, 0xea, 0x60, 0xc6, 0x93,
	0x25, 0xf6, 0x0e, 0xac, 0x84, 0x93, 0x71, 0xaf, 0x1f, 0x85, 0x47, 0x41, 0x32, 0x16, 0xb2, 0x40,
	0xfb, 0x35, 0xeb, 0x95, 0x2b, 0xd8, 0x15, 0x80, 0x43, 0x5c, 0x07, 0xd1, 0x45, 0x9d, 0xba, 0x30,
	0x10, 0xe6, 0x42, 0x4b, 0x96, 0x78, 0x30, 0x3c, 0xce, 0x3a, 0xb3, 0xd4, 0x90, 0x85, 0x61, 0x1b,
	0x59, 0x30, 0xe6, 0xbd, 0x34, 0xf3, 0xc7, 0x71, 0x67, 0x8e, 0x46, 0x63, 0x20, 0x54, 0x1f, 0x65,
	0xfe, 0xa8, 0x77, 0xc4, 0x79, 0xda, 0x99, 0x97, 0xf5, 0x1a, 0x61, 0x6f, 0xc3, 0xd2, 0x80, 0xa7,
	0x59, 0xcf, 0x1f, 0x0c, 0x12, 0x9e, 0xa6, 0x3c, 0xed, 0x2c, 0x10, 0x37, 0x16, 0x50, 0x5c, 0xb5,
	0xfb, 0x3c, 0x33, 0x56, 0x27, 0x95, 0xbb, 0xe3, 0xee, 0x01, 0x33, 0xe0, 0x6d, 0x9e, 0xf9, 0xc1,
	0x28, 0x65, 0xef, 0x41, 0x2b, 0x33, 0x88, 0x49, 0xfa, 0x9a, 0x9b, 0xec, 0x26, 0xa9, 0x8d, 0x9b,
	0xc6, 0x07, 0x9e, 0x45, 0xe7, 0xde, 0x87, 0x85, 0x7b, 0x9c, 0xef, 0x05, 0xe3, 0x20, 0x63, 0xeb,
	0x30, 0x7b, 0x14, 0x3c, 0xe7, 0x62, 0xb3, 0x67, 0x76, 0x2f, 0x78, 0xa2, 0xc8, 0xba, 0x30, 0x1f,
	0xf3, 0xa4, 0xcf, 0xd5, 0xf2, 0xef, 0x5e, 0xf0, 0x14, 0x70, 0x77, 0x1e, 0x66, 0x47, 0xf8, 0xb1,
	0xfb, 0xbd, 0x1a, 0x34, 0x0f, 0x78, 0xa8, 0x99, 0x88, 0x41, 0x1d, 0xa7, 0x24, 0x19, 0x87, 0x7e,
	0xb3, 0x37, 0xa1, 0x49, 0xd3, 0x4c, 0xb3, 0x24, 0x08, 0x87, 0xd4, 0x58, 0xc3, 0x03, 0x84, 0x0e,
	0x08, 0x61, 0x6d, 0x98, 0xf1, 0xc7, 0x19, 0xed, 0xe0, 0x8c, 0x87, 0x3f, 0x91, 0xc1, 0x62, 0x7f,
	0x3a, 0x46, 0x5e, 0xd4, 0xbb, 0xd6, 0xf2, 0x9a, 0x12, 0xdb, 0xc5, 0x6d, 0xbb, 0x09, 0xab, 0x26,
	0x89, 0x6a, 0x7d, 0x96, 0x5a, 0x5f, 0x31, 0x28, 0x65, 0x27, 0xd7, 0x61, 0x59, 0xd1, 0x27, 0x62,
	0xb0, 0xb4, 0x8f, 0x0d, 0x6f, 0x49, 0xc2, 0x6a, 0x0a, 0x37, 0xa0, 0x7d, 0x14, 0x84, 0xfe, 0xa8,
	0xd7, 0x1f, 0x65, 0x27, 0xbd, 0x01, 0x1f, 0x65, 0x3e, 0xed, 0xe8, 0xac, 0xb7, 0x44, 0xf8, 0xd6,
	0x28, 0x3b, 0xd9, 0x46, 0x94, 0xbd, 0x03, 0x8d, 0x23, 0xce, 0x7b, 0xb4, 0x12, 0x9d, 0x85, 0xab,
	0xce, 0x8d, 0xe6, 0xe6, 0xb2, 0x5c, 0x7a, 0xb5, 0xba, 0xde, 0xc2, 0x91, 0xfc, 0xe5, 0xfe, 0x91,
	0x03, 0x2d, 0xb1, 0x54, 0x52, 0x85, 0x5e, 0x83, 0x45, 0x35, 0x22, 0x9e, 0x24, 0x51, 0x22, 0xd9,
	0xdf, 0x06, 0xd9, 0x06, 0xb4, 0x15, 0x10, 0x27, 0x3c, 0x18, 0xfb, 0x43, 0x2e, 0xe5, 0xad, 0x84,
	0xb3, 0xcd, 0xbc, 0xc5, 0x24, 0x9a, 0x64, 0x42, 0x89, 0x35, 0x37, 0x5b, 0x72, 0x50, 0x1e, 0x62,
	0x9e, 0x4d, 0xe2, 0x7e, 0xdb, 0x01, 0x86, 0xc3, 0x7a, 0x1c, 0x89, 0x6a, 0xb9, 0x0a, 0xc5, 0x1d,
	0x70, 0x5e, 0x79, 0x07, 0x6a, 0x67, 0xed, 0xc0, 0x35, 0x98, 0xa3, 0x2e, 0x51, 0x56, 0x67, 0x4a,
	0xc3, 0x92, 0x75, 0xee, 0x77, 0x1d, 0x68, 0xa1, 0xe6, 0x08, 0xf9, 0x68, 0x3f, 0x0a, 0xc2, 0x8c,
	0xdd, 0x06, 0x76, 0x34, 0x09, 0x07, 0x41, 0x38, 0xec, 0x65, 0xcf, 0x83, 0x41, 0xef, 0x70, 0x8a,
	0x4d, 0xd0, 0x78, 0x76, 0x2f, 0x78, 0x15, 0x75, 0xec, 0x1d, 0x68, 0x5b, 0x68, 0x9a, 0x25, 0x62,
	0x54, 0xbb, 0x17, 0xbc, 0x52, 0x0d, 0xca, 0x7f, 0x34, 0xc9, 0xe2, 0x49, 0xd6, 0x0b, 0xc2, 0x01,
	0x7f, 0x4e, 0x6b, 0xb6, 0xe8, 0x59, 0xd8, 0xdd, 0x25, 0x68, 0x99, 0xdf, 0xb9, 0x9f, 0x83, 0xf6,
	0x1e, 0x2a, 0x86, 0x30, 0x08, 0x87, 0x77, 0x84, 0xf4, 0xa2, 0xb6, 0x8a, 0x27, 0x87, 0xcf, 0xf8,
	0x54, 0xee, 0xa3, 0x2c, 0xa1, 0x48, 0x1c, 0x47, 0x69, 0x26, 0xd7, 0x85, 0x7e, 0xbb, 0xff, 0xec,
	0xc0, 0x32, 0x2e, 0xfa, 0x47, 0x7e, 0x38, 0x55, 0x2b, 0xbe, 0x07, 0x2d, 0x6c, 0xea, 0x71, 0x74,
	0x47, 0xe8, 0x3c, 0x21, 0xcb, 0x37, 0xe4, 0x22, 0x15, 0xa8, 0x6f, 0x9a, 0xa4, 0x68, 0xa6, 0xa7,
	0x9e, 0xf5, 0x35, 0x0a, 0x5d, 0xe6, 0x27, 0x43, 0x9e, 0x91, 0x36, 0x94, 0xda, 0x11, 0x04, 0xb4,
	0x15, 0x85, 0x47, 0xec, 0x2a, 0xb4, 0x52, 0x3f, 0xeb, 0xc5, 0x3c, 0xa1, 0x55, 0x23, 0xc1, 0x99,
	0xf1, 0x20, 0xf5, 0xb3, 0x7d, 0x9e, 0xdc, 0x9d, 0x66, 0xbc, 0xfb, 0x79, 0x58, 0x29, 0xf5, 0x82,
	0xb2, 0x9a, 0x4f, 0x11, 0x7f, 0xb2, 0x35, 0x98, 0x3d, 0xf1, 0x47, 0x13, 0x2e, 0x95, 0xb4, 0x28,
	0x7c, 0x50, 0x7b, 0xdf, 0x71, 0xdf, 0x86, 0x76, 0x3e, 0x6c, 0xc9, 0xf4, 0x0c, 0xea, 0xb8, 0x82,
	0xb2, 0x01, 0xfa, 0xed, 0xfe, 0xa6, 0x23, 0x08, 0xb7, 0xa2, 0x40, 0x2b, 0x3c, 0x24, 0x44, 0xbd,
	0xa8, 0x08, 0xf1, 0xf7, 0x99, 0x06, 0xe1, 0xa7, 0x9f, 0xac, 0x7b, 0x1d, 0x56, 0x8c, 0x21, 0xbc,
	0x64, 0xb0, 0xdf, 0x76, 0x60, 0xe5, 0x21, 0x3f, 0x95, 0xbb, 0xae, 0x46, 0xfb, 0x3e, 0xd4, 0xb3,
	0x69, 0x2c, 0x9c, 0xac, 0xa5, 0xcd, 0x6b, 0x72, 0xd3, 0x4a, 0x74, 0x37, 0x65, 0xf1, 0xf1, 0x34,
	0xe6, 0x1e, 0x7d, 0xe1, 0x7e, 0x0e, 0x9a, 0x06, 0xc8, 0x2e, 0xc1, 0xea, 0xd3, 0x07, 0x8f, 0x1f,
	0xee, 0x1c, 0x1c, 0xf4, 0xf6, 0x9f, 0xdc, 0xfd, 0xe2, 0xce, 0xaf, 0xf6, 0x76, 0xef, 0x1c, 0xec,
	0xb6, 0x2f, 0xb0, 0x75, 0x60, 0x0f, 0x77, 0x0e, 0x1e, 0xef, 0x6c, 0x5b, 0xb8, 0xe3, 0x76, 0xa1,
	0xf3, 0x90, 0x9f, 0x3e, 0x0d, 0xb2, 0x90, 0xa7, 0xa9, 0xdd, 0x9b, 0x7b, 0x13, 0x98, 0x39, 0x04,
	0x39, 0xab, 0x0e, 0xcc, 0x4b, 0x8b, 0xa3, 0x0c, 0xae, 0x2c, 0xba, 0x6f, 0x03, 0x3b, 0x08, 0x86,
	0xe1, 0x47, 0x3c, 0x4d, 0xfd, 0xa1, 0x56, 0x05, 0x6d, 0x98, 0x19, 0xa7, 0x43, 0xa9, 0x01, 0xf0,
	0xa7, 0xfb, 0x29, 0x58, 0xb5, 0xe8, 0x64, 0xc3, 0xaf, 0x43, 0x23, 0x0d, 0x86, 0xa1, 0x9f, 0x4d,
	0x12, 0x2e, 0x9b, 0xce, 0x01, 0xf7, 0x1e, 0xac, 0x7d, 0x99, 0x27, 0xc1, 0xd1, 0xf4, 0xbc, 0xe6,
	0xed, 0x76, 0x6a, 0xc5, 0x76, 0x76, 0xe0, 0x62, 0xa1, 0x1d, 0xd9, 0xbd, 0x60, 0x44, 0xb9, 0x5d,
	0x0b, 0x9e, 0x28, 0x18, 0x62, 0x59, 0x33, 0xc5, 0xd2, 0x7d, 0x02, 0x6c, 0x2b, 0x0a, 0x43, 0xde,
	0xcf, 0xf6, 0x39, 0x4f, 0x72, 0xcf, 0x39, 0xe7, 0xba, 0xe6, 0xe6, 0x25, 0xb9, 0x8f, 0x45, 0x59,
	0x97, 0xec, 0xc8, 0xa0, 0x1e, 0xf3, 0x64, 0x4c, 0x0d, 0x2f, 0x78, 0xf4, 0xdb, 0xbd, 0x08, 0xab,
	0x56, 0xb3, 0xd2, 0xe9, 0x79, 0x17, 0x2e, 0x6e, 0x07, 0x69, 0xbf, 0xdc, 0x61, 0x07, 0xe6, 0xe3,
	0xc9, 0x61, 0x2f, 0x97, 0x29, 0x55, 0x44, 0x5f, 0xa0, 0xf8, 0x89, 0x6c, 0xec, 0x77, 0x1d, 0xa8,
	0xef, 0x3e, 0xde, 0xdb, 0x62, 0x5d, 0x58, 0x08, 0xc2, 0x7e, 0x34, 0x46, 0xb5, 0x2b, 0x26, 0xad,
	0xcb, 0x67, 0xca, 0xca, 0xeb, 0xd0, 0x20, 0x6d, 0x8d, 0xee, 0x8d, 0x74, 0x72, 0x73, 0x00, 0x5d,
	0x2b, 0xfe, 0x3c, 0x0e, 0x12, 0xf2, 0x9d, 0x94, 0x47, 0x54, 0x27, 0x8d, 0x58, 0xae, 0x70, 0xff,
	0xa7, 0x0e, 0xf3, 0x52, 0x57, 0x53, 0x7f, 0xfd, 0x2c, 0x38, 0xe1, 0x72, 0x24, 0xb2, 0x84, 0x56,
	0x2e, 0xe1, 0xe3, 0x28, 0xe3, 0x3d, 0x6b, 0x1b, 0x6c, 0x10, 0xa9, 0xfa, 0xa2, 0xa1, 0x5e, 0x8c,
	0x5a, 0x9f, 0x46, 0xd6, 0xf0, 0x6c, 0x10, 0x17, 0x0b, 0x81, 0x5e, 0x30, 0xa0, 0x31, 0xd5, 0x3d,
	0x55, 0xc4, 0x95, 0xe8, 0xfb, 0xb1, 0xdf, 0x0f, 0xb2, 0xa9, 0x14, 0x6e, 0x5d, 0xc6, 0xb6, 0x47,
	0x51, 0xdf, 0x1f, 0xf5, 0x0e, 0xfd, 0x91, 0x1f, 0xf6, 0xb9, 0xf4, 0xdf, 0x6c, 0x10, 0x5d, 0x34,
	0x39, 0x24, 0x45, 0x26, 0xdc, 0xb8, 0x02, 0x8a, 0xae, 0x5e, 0x3f, 0x1a, 0x8f, 0x83, 0x0c, 0x3d,
	0x3b, 0xb2, 0xfa, 0x33, 0x9e, 0x81, 0xd0, 0x4c, 0x44, 0xe9, 0x54, 0xac, 0x5e, 0x43, 0xf4, 0x66,
	0x81, 0xd8, 0x0a, 0xba, 0x0e, 0xa8, 0x90, 0x9e, 0x9d, 0x76, 0x40, 0xb4, 0x92, 0x23, 0xb8, 0x0f,
	0x93, 0x30, 0xe5, 0x59, 0x36, 0xe2, 0x03, 0x3d, 0xa0, 0x26, 0x91, 0x95, 0x2b, 0xd8, 0x6d, 0x58,
	0x15, 0xce, 0x66, 0xea, 0x67, 0x51, 0x7a, 0x1c, 0xa4, 0xbd, 0x14, 0xdd, 0xb6, 0x16, 0xd1, 0x57,
	0x55, 0xb1, 0xf7, 0xe1, 0x52, 0x01, 0x4e, 0x78, 0x9f, 0x07, 0x27, 0x7c, 0xd0, 0x59, 0xa4, 0xaf,
	0xce, 0xaa, 0x66, 0x57, 0xa1, 0x89, 0x3e, 0xf6, 0x24, 0x1e, 0xf8, 0x68, 0x87, 0x97, 0x68, 0x1f,
	0x4c, 0x88, 0xbd, 0x0b, 0x8b, 0x31, 0x17, 0xc6, 0xf2, 0x38, 0x1b, 0xf5, 0xd3, 0xce, 0x32, 0x59,
	0xb2, 0xa6, 0x14, 0x26, 0xe4, 0x5c, 0xcf, 0xa6, 0x40, 0xa6, 0xec, 0xa7, 0xe4, 0x6c, 0xf9, 0xd3,
	0x4e, 0x9b, 0xd8, 0x2d, 0x07, 0x48, 0x46, 0x92, 0xe0, 0xc4, 0xcf, 0x78, 0x67, 0x85, 0x78, 0x4b,
	0x15, 0xdd, 0x3f, 0x75, 0x60, 0x75, 0x2f, 0x48, 0x33, 0xc9, 0x84, 0x5a, 0x1d, 0xbf, 0x09, 0x4d,
	0xc1, 0x7e, 0xbd, 0x28, 0x1c, 0x4d, 0x25, 0x47, 0x82, 0x80, 0x1e, 0x85, 0xa3, 0x29, 0xfb, 0x04,
	0x2c, 0x06, 0xa1, 0x49, 0x22, 0x64, 0xb8, 0xa5, 0x40, 0x22, 0x7a, 0x13, 0x9a, 0xf1, 0xe4, 0x70,
	0x14, 0xf4, 0x05, 0xc9, 0x8c, 0x68, 0x45, 0x40, 0x44, 0x80, 0x4e, 0x92, 0x18, 0x89, 0xa0, 0xa8,
	0x13, 0x45, 0x53, 0x62, 0x48, 0xe2, 0xde, 0x85, 0x35, 0x7b, 0x80, 0x52, 0x59, 0x6d, 0xc0, 0x82,
	0xe4, 0xed, 0xb4, 0xd3, 0xa4, 0xf5, 0x59, 0x92, 0xeb, 0x23, 0x49, 0x3d, 0x5d, 0xef, 0xfe, 0x79,
	0x1d, 0x56, 0x25, 0xba, 0x35, 0x8a, 0x52, 0x7e, 0x30, 0x19, 0x8f, 0xfd, 0xa4, 0x42, 0x68, 0x9c,
	0x73, 0x84, 0xa6, 0x66, 0x0b, 0x0d, 0xb2, 0xf2, 0xb1, 0x1f, 0x84, 0xc2, 0xc3, 0x13, 0x12, 0x67,
	0x20, 0xec, 0x06, 0x2c, 0xf7, 0x47, 0x51, 0x2a, 0xbc, 0x1e, 0xf3, 0xf8, 0x54, 0x84, 0xcb, 0x42,
	0x3e, 0x5b, 0x25, 0xe4, 0xa6, 0x90, 0xce, 0x15, 0x84, 0xd4, 0x85, 0x16, 0x36, 0xca, 0x95, 0xce,
	0x99, 0x17, 0x5e, 0x98, 0x89, 0xe1, 0x78, 0x8a, 0x22, 0x21, 0xe4, 0x6f, 0xb9, 0x4a, 0x20, 0xf0,
	0x74, 0x86, 0x3a, 0xcd, 0xa0, 0x6e, 0x48, 0x81, 0x28, 0x57, 0xb1, 0x7b, 0x00, 0xa2, 0x2f, 0x32,
	0xe3, 0x40, 0x66, 0xfc, 0x6d, 0x7b, 0x47, 0xcc, 0xb5, 0xbf, 0x89, 0x85, 0x49, 0xc2, 0xc9, 0x90,
	0x1b, 0x5f, 0xba, 0x1f, 0x43, 0xd3, 0xa8, 0x62, 0x17, 0x61, 0x65, 0xeb, 0xd1, 0xa3, 0xfd, 0x1d,
	0xef, 0xce, 0xe3, 0x07, 0x5f, 0xde, 0xe9, 0x6d, 0xed, 0x3d, 0x3a, 0xd8, 0x69, 0x5f, 0x40, 0x78,
	0xef, 0xd1, 0xd6, 0x9d, 0xbd, 0xde, 0xbd, 0x47, 0xde, 0x96, 0x82, 0x1d, 0xb4, 0xf1, 0xde, 0xce,
	0x47, 0x8f, 0x1e, 0xef, 0x58, 0x78, 0x8d, 0xb5, 0xa1, 0x75, 0xd7, 0xdb, 0xb9, 0xb3, 0xb5, 0x2b,
	0x91, 0x19, 0xb6, 0x06, 0xed, 0x7b, 0x4f, 0x1e, 0x6e, 0x3f, 0x78, 0x78, 0xbf, 0xb7, 0x75, 0xe7,
	0xe1, 0xd6, 0xce, 0xde, 0xce, 0x76, 0xbb, 0xee, 0xfe, 0xad, 0x03, 0x17, 0x69, 0x94, 0x83, 0xa2,
	0x40, 0x5c, 0x85, 0x66, 0x3f, 0x8a, 0x62, 0x8e, 0xfa, 0x5b, 0xab, 0x68, 0x13, 0x42, 0x66, 0x17,
	0x0a, 0xf1, 0x28, 0x4a, 0xfa, 0x5c, 0xca, 0x03, 0x10, 0x74, 0x0f, 0x11, 0x64, 0x76, 0xb9, 0x9d,
	0x82, 0x42, 0x88, 0x43, 0x53, 0x60, 0x82, 0x64, 0x1d, 0xe6, 0x0e, 0x13, 0xee, 0xf7, 0x8f, 0xa5,
	0x24, 0xc8, 0x12, 0xfb, 0x64, 0xee, 0x90, 0xf7, 0x71, 0xb5, 0x47, 0x7c, 0x40, 0x1c, 0xb2, 0xe0,
	0x2d, 0x4b, 0x7c, 0x4b, 0xc2, 0xee, 0x3e, 0xac, 0x17, 0x67, 0x20, 0x25, 0xe6, 0x3d, 0x43, 0x62,
	0x84, 0x6f, 0xdc, 0x3d, 0x7b, 0x7f, 0x0c, 0xe9, 0xf9, 0x77, 0x07, 0xea, 0x68, 0x3e, 0xcf, 0x36,
	0xb5, 0xa6, 0x47, 0x34, 0x63, 0x79, 0x44, 0x14, 0x3c, 0xc0, 0x33, 0x85, 0x50, 0xa8, 0xc2, 0xe8,
	0x18, 0x48, 0x5e, 0x9f, 0xf0, 0xfe, 0x09, 0xcd, 0x49, 0xd7, 0x23, 0x82, 0x2c, 0x8f, 0x8e, 0x27,
	0x7d, 0x2d, 0x59, 0x5e, 0x95, 0x55, 0x1d, 0x7d, 0x39, 0x9f, 0xd7, 0xd1, 0x77, 0x1d, 0x98, 0x0f,
	0xc2, 0xc3, 0x68, 0x12, 0x0e, 0x88, 0xc5, 0x17, 0x3c, 0x55, 0x44, 0x55, 0x19, 0x93, 0xe8, 0x05,
	0x63, 0xc5, 0xd0, 0x39, 0xe0, 0x32, 0x3c, 0x98, 0xa4, 0xe4, 0x2e, 0x68, 0x2f, 0xf0, 0x3d, 0x58,
	0x31, 0x30, 0xb9, 0x9a, 0x6f, 0xc1, 0x6c, 0x8c, 0x80, 0x5c, 0x4a, 0xa5, 0x9c, 0xc9, 0xcf, 0x10,
	0x35, 0x6e, 0x1b, 0x96, 0xee, 0xf3, 0xec, 0x41, 0x78, 0x14, 0xa9, 0x96, 0x7e, 0x34, 0x03, 0xcb,
	0x1a, 0x92, 0x0d, 0xdd, 0x80, 0xe5, 0x60, 0xc0, 0xc3, 0x2c, 0xc8, 0xa6, 0x3d, 0xeb, 0xfc, 0x53,
	0x84, 0xd1, 0x3f, 0xf3, 0x47, 0x81, 0x9f, 0x4a, 0x0f, 0x40, 0x14, 0xd8, 0x26, 0xac, 0xa1, 0xf1,
	0x50, 0xf6, 0x40, 0x6f, 0xb1, 0x38, 0x86, 0x55, 0xd6, 0xa1, 0x78, 0x23, 0x2e, 0xf5, 0xb7, 0xfe,
	0x44, 0xf8, 0x29, 0x55, 0x55, 0xb8, 0x6a, 0xa2, 0x25, 0x9c, 0xf2, 0xac, 0x30, 0x30, 0x1a, 0x28,
	0x85, 0x80, 0xe6, 0x84, 0xf2, 0x29, 0x86, 0x80, 0x8c, 0x30, 0xd2, 0x42, 0x29, 0x8c, 0x84, 0xca,
	0x69, 0x1a, 0xf6, 0xf9, 0xa0, 0x97, 0x45, 0x3d, 0x52, 0xa2, 0xb4, 0x3b, 0x0b, 0x5e, 0x11, 0xa6,
	0x80, 0x17, 0x4f, 0xb3, 0x90, 0x67, 0xa4, 0x67, 0x16, 0x3c, 0x55, 0x44, 0xf9, 0x21, 0x12, 0x61,
	0x12, 0x1a, 0x9e, 0x2c, 0xa1, 0xa3, 0x39, 0x49, 0x82, 0xb4, 0xd3, 0x22, 0x94, 0x7e, 0xb3, 0x4f,
	0xc3, 0xc5, 0x43, 0x9e, 0x66, 0xbd, 0x63, 0xee, 0x0f, 0x78, 0x42, 0xbb, 0x2f, 0xa2, 0x53, 0xc2,
	0x7e, 0x57, 0x57, 0x62, 0xdf, 0x27, 0x3c, 0x49, 0x83, 0x28, 0x24, 0xcb, 0xdd, 0xf0, 0x54, 0xd1,
	0xfd, 0x26, 0xf9, 0xc3, 0x3a, 0x6e, 0xf6, 0x84, 0x8c, 0x39, 0x7b, 0x0d, 0x1a, 0x62, 0x8e, 0xe9,
	0xb1, 0x2f, 0x5d, 0xf4, 0x05, 0x02, 0x0e, 0x8e, 0x7d, 0xd4, 0x08, 0xd6, 0xb2, 0x89, 0x40, 0x64,
	0x93, 0xb0, 0x5d, 0xb1, 0x6a, 0xd7, 0x60, 0x49, 0x45, 0xe4, 0xd2, 0xde, 0x88, 0x1f, 0x65, 0xea,
	0x78, 0x1d, 0x4e, 0xc6, 0xd8, 0x5d, 0xba, 0xc7, 0x8f, 0x32, 0xf7, 0x21, 0xac, 0x48, 0x19, 0x7e,
	0x14, 0x73, 0xd5, 0xf5, 0x67, 0xab, 0xac, 0x5b, 0x73, 0x73, 0xd5, 0x16, 0x7a, 0x8a, 0x11, 0x14,
	0x4c, 0x9e, 0xeb, 0x01, 0x33, 0x75, 0x82, 0x6c, 0x50, 0x9a, 0x18, 0x75, 0x88, 0x97, 0xd3, 0xb1,
	0x30, 0x5c, 0x9f, 0x74, 0xd2, 0xef, 0xa3, 0x26, 0x10, 0x1a, 0x50, 0x15, 0xdd, 0xef, 0x39, 0xb0,
	0x4a, 0xad, 0x29, 0xfb, 0xac, 0x4f, 0x7e, 0xaf, 0x3e, 0xcc, 0x56, 0xdf, 0x0c, 0x6c, 0xac, 0xc1,
	0xac, 0xa9, 0x6b, 0x45, 0xe1, 0xc7, 0x3f, 0xcb, 0xd6, 0x4b, 0x67, 0xd9, 0x1f, 0x39, 0xb0, 0x22,
	0x94, 0x61, 0xe6, 0x67, 0x93, 0x54, 0x4e, 0xff, 0x17, 0x61, 0x51, 0xd8, 0x29, 0x29, 0x4e, 0x72,
	0xa0, 0x6b, 0x5a, 0xf2, 0x09, 0x15, 0xc4, 0xbb, 0x17, 0x3c, 0x9b, 0x98, 0x7d, 0x1e, 0x5a, 0x66,
	0x58, 0x95, 0xc6, 0xdc, 0xdc, 0xbc, 0xac, 0x66, 0x59, 0xe2, 0x9c, 0xdd, 0x0b, 0x9e, 0xf5, 0x01,
	0xfb, 0x90, 0x9c, 0x8d, 0xb0, 0x47, 0xcd, 0xca, 0xc0, 0xd4, 0xe5, 0x0a, 0x05, 0xae, 0x3f, 0x37,
	0xc8, 0xef, 0x2e, 0xc0, 0x9c, 0xf0, 0x2e, 0xdd, 0xfb, 0xb0, 0x68, 0x8d, 0xd4, 0x3a, 0xa3, 0xb7,
	0xc4, 0x19, 0xbd, 0x14, 0xd2, 0xa9, 0x95, 0x43, 0x3a, 0xee, 0xbf, 0xd6, 0x80, 0x21, 0xb7, 0x15,
	0xb6, 0x13, 0xdd, 0xdb, 0x68, 0x60, 0x1d, 0x56, 0x5a, 0x9e, 0x09, 0xb1, 0x9b, 0xc0, 0x8c, 0xa2,
	0x8a, 0x7a, 0x09, 0xbb, 0x51, 0x51, 0x83, 0x0a, 0x4e, 0x1a, 0x56, 0x69, 0x02, 0xe5, 0xb1, 0x4c,
	0xec, 0x5b, 0x65, 0x1d, 0x9a, 0x86, 0x78, 0x92, 0x1e, 0xa3, 0xfb, 0xad, 0x8e, 0x33, 0xaa, 0x5c,
	0x64, 0x90, 0xb9, 0x73, 0x19, 0x64, 0xbe, 0xc8, 0x20, 0xa6, 0x43, 0xbd, 0x60, 0x39, 0xd4, 0xe8,
	0xc8, 0x8d, 0xd1, 0xfd, 0xcb, 0x46, 0xfd, 0xde, 0x18, 0x7b, 0x97, 0xa7, 0x17, 0x0b, 0x64, 0x1b,
	0xd0, 0x96, 0xae, 0x40, 0xee, 0xb5, 0x03, 0xad, 0x71, 0x09, 0x77, 0x7f, 0xe8, 0x40, 0x1b, 0xd7,
	0xd9, 0xe2, 0xc5, 0x0f, 0x80, 0x44, 0xe1, 0x15, 0x59, 0xd1, 0xa2, 0xfd, 0xe9, 0x39, 0xf1, 0x7d,
	0x68, 0x50, 0x83, 0x51, 0xcc, 0x43, 0xc9, 0x88, 0x1d, 0x9b, 0x11, 0x73, 0x2d, 0xb4, 0x7b, 0xc1,
	0xcb, 0x89, 0x0d, 0x36, 0xfc, 0x47, 0x07, 0x9a, 0x72, 0x98, 0x3f, 0xf1, 0x49, 0xbc, 0x0b, 0x0b,
	0xc8, 0x91, 0xc6, 0x71, 0x57, 0x97, 0xd1, 0x9a, 0x8c, 0xfd, 0x6c, 0x92, 0xa0, 0xf9, 0xb4, 0x4e,
	0xe1, 0x45, 0x18, 0x6d, 0x21, 0x29, 0xdc, 0xb4, 0x97, 0x05, 0xa3, 0x9e, 0xaa, 0x95, 0xb7, 0x18,
	0x55, 0x55, 0xa8, 0x77, 0xd2, 0xcc, 0x1f, 0x72, 0x69, 0xe6, 0x44, 0xc1, 0xed, 0xc0, 0xba, 0x9c,
	0x50, 0xc1, 0x77, 0x74, 0xff, 0xa6, 0x05, 0x97, 0x4a, 0x55, 0xfa, 0x1a, 0x50, 0x1e, 0x2f, 0x47,
	0xc1, 0xf8, 0x30, 0xd2, 0x8e, 0xb6, 0x63, 0x9e, 0x3c, 0xad, 0x2a, 0x36, 0x84, 0x8b, 0xca, 0x9e,
	0xe3, 0x9a, 0xe6, 0xd6, 0xbb, 0x46, 0x8e, 0xc8, 0xbb, 0x36, 0x0f, 0x14, 0x3b, 0x54, 0xb8, 0x29,
	0xb9, 0xd5, 0xed, 0xb1, 0x63, 0xe8, 0x68, 0xc7, 0x41, 0xaa, 0x78, 0xc3, 0xb9, 0xc0, 0xbe, 0xde,
	0x39, 0xa7, 0x2f, 0xcb, 0x11, 0xf5, 0xce, 0x6c, 0x8d, 0x4d, 0xe1, 0x8a, 0xaa, 0x23, 0x1d, 0x5e,
	0xee, 0xaf, 0xfe, 0x4a, 0x73, 0x23, 0x27, 0xda, 0xee, 0xf4, 0x9c, 0x86, 0xd9, 0xd7, 0x61, 0xfd,
	0xd4, 0x0f, 0x32, 0x35, 0x2c, 0xc3, 0x19, 0x9a, 0xa5, 0x2e, 0x37, 0xcf, 0xe9, 0xf2, 0xa9, 0xf8,
	0xd8, 0x32, 0x6c, 0x67, 0xb4, 0xd8, 0xfd, 0x7b, 0x07, 0x96, 0xec, 0x76, 0x90, 0x4d, 0xa5, 0xc0,
	0x2b, 0xc5, 0xa7, 0x9c, 0xbf, 0x02, 0x5c, 0x3e, 0xab, 0xd6, 0xaa, 0xce, 0xaa, 0xe6, 0x09, 0x71,
	0xe6, 0xbc, 0x30, 0x4e, 0xfd, 0xd5, 0xc2, 0x38, 0xb3, 0x55, 0x61, 0x9c, 0xee, 0x7f, 0x3b, 0xc0,
	0xca, 0xbc, 0xc4, 0xee, 0x8b, 0xc3, 0x72, 0xc8, 0x47, 0x52, 0x27, 0xfd, 0xfc, 0xab, 0xf1, 0xa3,
	0x5a, 0x3b, 0xf5, 0x35, 0x0a, 0x86, 0xa9, 0x74, 0x4c, 0x17, 0x69, 0xd1, 0xab, 0xaa, 0x2a, 0x04,
	0x96, 0xea, 0xe7, 0x07, 0x96, 0x66, 0xcf, 0x0f, 0x2c, 0xcd, 0x15, 0x03, 0x4b, 0xdd, 0xdf, 0x71,
	0x60, 0xb5, 0x62, 0xd3, 0x7f, 0x76, 0x13, 0xc7, 0x6d, 0xb2, 0x74, 0x41, 0x4d, 0x6e, 0x93, 0x09,
	0x76, 0x7f, 0x03, 0x16, 0x2d, 0x46, 0xff, 0xd9, 0xf5, 0x5f, 0xf4, 0xf2, 0x04, 0x9f, 0x59, 0x58,
	0xf7, 0x3f, 0x6a, 0xc0, 0xca, 0xc2, 0xf6, 0xff, 0x3a, 0x86, 0xf2, 0x3a, 0xcd, 0x54, 0xac, 0xd3,
	0xff, 0xa9, 0x1d, 0x78, 0x07, 0x56, 0x64, 0xce, 0x80, 0x11, 0x22, 0x11, 0x1c, 0x53, 0xae, 0x40,
	0x3f, 0xd7, 0x8e, 0xea, 0x2d, 0x58, 0x77, 0xcd, 0x86, 0x31, 0x2c, 0x04, 0xf7, 0xdc, 0x75, 0x58,
	0x13, 0x39, 0x08, 0x77, 0x45, 0x53, 0xca, 0xae, 0xfc, 0x89, 0x03, 0x17, 0x0b, 0x15, 0xf9, 0xcd,
	0xa8, 0x30, 0x1d, 0xb6, 0x3d, 0xb1, 0x41, 0x1c, 0xbf, 0x94, 0x23, 0x63, 0xfc, 0x82, 0xdb, 0xca,
	0x15, 0xb8, 0x3e, 0x93, 0xb0, 0x4c, 0x2f, 0x56, 0xbd, 0xaa, 0xca, 0xbd, 0x24, 0x32, 0x25, 0x42,
	0x3e, 0x2a, 0x0c, 0xfc, 0x48, 0xe4, 0x36, 0x98, 0x15, 0xf9, 0xd5, 0x8a, 0x3d, 0x64, 0x55, 0x44,
	0x2f, 0xd0, 0x32, 0x53, 0xf6, 0x78, 0x2b, 0xeb, 0xdc, 0xbf, 0x72, 0x80, 0x7d, 0x69, 0xc2, 0x93,
	0x29, 0xdd, 0x90, 0xea, 0x58, 0xce, 0xa5, 0x62, 0x1c, 0x63, 0x2e, 0x9e, 0x1c, 0x7e, 0x91, 0x4f,
	0xd5, 0x3d, 0x7a, 0x2d, 0xbf, 0x47, 0x7f, 0x03, 0x00, 0x8f, 0x5f, 0xfa, 0xda, 0x15, 0x79, 0x01,
	0xcf, 0xbd, 0xa2, 0xc1, 0xca, 0xab, 0xee, 0xfa, 0xf9, 0x57, 0xdd, 0xb3, 0xe7, 0x5d, 0x75, 0x7f,
	0x08, 0xab, 0xd6, 0xb8, 0xf5, 0xb6, 0xaa, 0x0b, 0x60, 0xe7, 0x25, 0x17, 0xc0, 0xff, 0xe9, 0xc0,
	0xcc, 0x6e, 0x14, 0x9b, 0x71, 0x4b, 0xc7, 0x8e, 0x5b, 0x4a, 0x5b, 0xd2, 0xd3, 0xa6, 0x42, 0xaa,
	0x18, 0x0b, 0x64, 0x1b, 0xb0, 0xe4, 0x8f, 0x33, 0x3c, 0x76, 0x1f, 0x45, 0xc9, 0xa9, 0x9f, 0x0c,
	0xc4, 0x5e, 0xdf, 0xad, 0x75, 0x1c, 0xaf, 0x50, 0xc3, 0xd6, 0x60, 0x46, 0x2b, 0x5d, 0x22, 0xc0,
	0x22, 0x3a, 0x6e, 0x74, 0xe7, 0x31, 0x95, 0x11, 0x03, 0x59, 0x42, 0x56, 0xb2, 0xbf, 0x17, 0xae,
	0xb2, 0x10, 0x9d, 0xaa, 0x2a, 0xb4, 0x6b, 0xb8, 0x7c, 0x44, 0x26, 0x43, 0x3d, 0xaa, 0xec, 0xfe,
	0x9b, 0x03, 0xb3, 0xb4, 0x02, 0x28, 0xec, 0x82, 0xc3, 0x75, 0x80, 0x92, 0x66, 0xbe, 0xe8, 0x15,
	0x61, 0xe6, 0x5a, 0xf9, 0x26, 0x35, 0x3d, 0x6c, 0x33, 0xe7, 0xe4, 0x2a, 0x34, 0x44, 0x49, 0xe7,
	0x56, 0x10, 0x49, 0x0e, 0xb2, 0x2b, 0x50, 0x3f, 0x8e, 0x62, 0xe5, 0x9d, 0x80, 0x8a, 0xcf, 0x47,
	0xb1, 0x47, 0x78, 0x3e, 0x1e, 0x6c, 0x4f, 0x0c, 0x5e, 0xd8, 0x9c, 0x22, 0x8c, 0x56, 0x57, 0x37,
	0x6b, 0x2e, 0x46, 0x01, 0x75, 0x37, 0x60, 0xf9, 0x61, 0x34, 0xe0, 0x46, 0x4c, 0xe9, 0x4c, 0x6e,
	0x76, 0xbf, 0xe5, 0xc0, 0x82, 0x22, 0x66, 0x37, 0xa0, 0x8e, 0xae, 0x44, 0xe1, 0xa0, 0xa0, 0xef,
	0xe5, 0x90, 0xce, 0x23, 0x0a, 0xd4, 0xbd, 0x14, 0x71, 0xc8, 0xdd, 0x4a, 0x15, 0x6f, 0xc8, 0xbd,
	0x26, 0x3d, 0xdc, 0x82, 0xb3, 0x51, 0x40, 0xdd, 0xbf, 0x70, 0x60, 0xd1, 0xea, 0x03, 0x8f, 0x87,
	0x23, 0x3f, 0xcd, 0xe4, 0x5d, 0x87, 0xdc, 0x1e, 0x13, 0x32, 0xa3, 0x8c, 0x35, 0x3b, 0xca, 0xa8,
	0xe3, 0x5f, 0x33, 0x66, 0xfc, 0xeb, 0x36, 0x34, 0xf2, 0xac, 0xa0, 0xba, 0xa5, 0x53, 0xb1, 0x47,
	0x75, 0xe3, 0x98, 0x13, 0x61, 0x3b, 0xfd, 0x68, 0x14, 0x25, 0x32, 0xc8, 0x2e, 0x0a, 0xee, 0x87,
	0xd0, 0x34, 0xe8, 0x71, 0x18, 0x21, 0xcf, 0x4e, 0xa3, 0xe4, 0x99, 0x0a, 0x76, 0xca, 0xa2, 0xbe,
	0x58, 0xaf, 0xe5, 0x17, 0xeb, 0xee, 0x0f, 0x1c, 0x58, 0x44, 0x1e, 0x0c, 0xc2, 0xe1, 0x7e, 0x34,
	0x0a, 0xfa, 0x53, 0xda, 0x7b, 0xc5, 0x6e, 0x52, 0x33, 0x28, 0x5e, 0xb4, 0x61, 0xe4, 0x6d, 0x75,
	0x3a, 0x94, 0x82, 0xa8, 0xcb, 0x28, 0xa9, 0xc8, 0xe7, 0x87, 0x7e, 0x2a, 0x99, 0x5f, 0x1a, 0x39,
	0x0b, 0x44, 0x79, 0x42, 0x20, 0xf1, 0x33, 0xde, 0x1b, 0x07, 0xa3, 0x51, 0x20, 0x68, 0x85, 0x0b,
	0x54, 0x55, 0x85, 0x7d, 0x0e, 0x82, 0xd4, 0x3f, 0xcc, 0x03, 0xc9, 0xba, 0xec, 0x7e, 0xbf, 0x06,
	0x4d, 0xa9, 0x9e, 0x77, 0x06, 0x43, 0x2e, 0x6f, 0x39, 0xc8, 0xc9, 0xd4, 0xaa, 0xc4, 0x40, 0x54,
	0xbd, 0xe5, 0x96, 0x1a, 0x48, 0x71, 0xcb, 0x67, 0xca, 0x5b, 0xfe, 0x3a, 0x34, 0x90, 0xf5, 0xde,
	0x25, 0xff, 0x57, 0xdc, 0x90, 0xe4, 0x80, 0xaa, 0xdd, 0xa4, 0xda, 0xd9, 0xbc, 0x96, 0x80, 0x97,
	0xde, 0x89, 0xbc, 0x0f, 0x2d, 0xd9, 0x0c, 0xed, 0x09, 0x69, 0x8e, 0x9c, 0xf9, 0xad, 0xfd, 0xf2,
	0x2c, 0x4a, 0xf5, 0xe5, 0xa6, 0xfa, 0x72, 0xe1, 0xbc, 0x2f, 0x15, 0x25, 0xdd, 0x5f, 0x8b, 0xb5,
	0xb9, 0x9f, 0xf8, 0xf1, 0xb1, 0x32, 0x79, 0x03, 0x9d, 0x94, 0x43, 0x30, 0xdb, 0x80, 0x59, 0xfc,
	0x4c, 0x69, 0xf2, 0x6a, 0x81, 0x14, 0x24, 0xec, 0x06, 0xcc, 0xf2, 0xc1, 0x90, 0xab, 0x13, 0x1e,
	0xb3, 0xcf, 0xda, 0xb8, 0x47, 0x9e, 0x20, 0x40, 0xf5, 0x80, 0x68, 0x41, 0x3d, 0xd8, 0x56, 0x60,
	0x0e, 0x8b, 0x0f, 0x06, 0xee, 0x1a, 0xb0, 0x87, 0x82, 0xa3, 0xcd, 0x08, 0xf5, 0x6f, 0xcf, 0x40,
	0xd3, 0x80, 0x51, 0xd2, 0x87, 0x38, 0xe0, 0xde, 0x20, 0xf0, 0xc7, 0x3c, 0xe3, 0x89, 0xe4, 0xe2,
	0x02, 0x8a, 0x74, 0xfe, 0xc9, 0xb0, 0x17, 0x4d, 0xb2, 0xde, 0x80, 0x0f, 0x13, 0x2e, 0x0c, 0x33,
	0x1a, 0x0a, 0x0b, 0x45, 0xba, 0xb1, 0xff, 0xdc, 0xa4, 0x13, 0xfc, 0x50, 0x40, 0x55, 0xbc, 0x59,
	0xac, 0x51, 0x3d, 0x8f, 0x37, 0x8b, 0x15, 0x29, 0xea, 0xa8, 0xd9, 0x0a, 0x1d, 0xf5, 0x1e, 0xac,
	0x0b, 0x6d, 0x24, 0xe5, 0xb6, 0x57, 0x60, 0x93, 0x33, 0x6a, 0xd9, 0x06, 0xb4, 0x71, 0xcc, 0x8a,
	0xc1, 0xd3, 0xe0, 0x9b, 0x22, 0x02, 0xe4, 0x78, 0x25, 0x1c, 0x69, 0x51, 0x54, 0x2d, 0x5a, 0x71,
	0xa3, 0x56, 0xc2, 0x89, 0xd6, 0x7f, 0x6e, 0xd3, 0x36, 0x24, 0x6d, 0x01, 0x77, 0x17, 0xa1, 0x79,
	0x90, 0x45, 0xb1, 0xda, 0x94, 0x25, 0x68, 0x89, 0xa2, 0xcc, 0x5f, 0x78, 0x0d, 0x2e, 0x13, 0x17,
	0x3d, 0x8e, 0xe2, 0x68, 0x14, 0x0d, 0xa7, 0x07, 0x93, 0xc3, 0xb4, 0x9f, 0x04, 0x31, 0x9e, 0x86,
	0xdc, 0x7f, 0x70, 0x60, 0xd5, 0xaa, 0x95, 0x21, 0xa3, 0x4f, 0x0b, 0x96, 0xd6, 0x17, 0xcf, 0x82,
	0xf1, 0x56, 0x0c, 0x55, 0x29, 0x08, 0x45, 0xb0, 0xee, 0x89, 0xbc, 0x8b, 0xbe, 0x03, 0xcb, 0x6a,
	0x64, 0xea, 0x43, 0xc1, 0x85, 0x9d, 0x32, 0x17, 0xca, 0xef, 0x97, 0xe4, 0x07, 0xaa, 0x89, 0x5f,
	0x92, 0x37, 0x93, 0x03, 0x9a, 0xa3, 0x8a, 0x1d, 0xe8, 0xbb, 0x27, 0xf3, 0x04, 0xa1, 0x46, 0xd0,
	0xd7, 0x60, 0xea, 0xfe, 0x9e, 0x03, 0x90, 0x8f, 0x0e, 0x19, 0x23, 0x57, 0xf7, 0x22, 0x59, 0xda,
	0x50, 0xed, 0x6f, 0x41, 0x4b, 0xdf, 0x9a, 0xe4, 0x16, 0xa4, 0xa9, 0x30, 0x74, 0xf2, 0xae, 0xc3,
	0xf2, 0x70, 0x14, 0x1d, 0x92, 0xf9, 0xa5, 0x84, 0x98, 0x54, 0x66, 0x71, 0x2c, 0x09, 0xf8, 0x9e,
	0x44, 0x73, 0x73, 0x53, 0x37, 0xcc, 0x8d, 0xfb, 0xed, 0x9a, 0x8e, 0xb5, 0xe7, 0x73, 0x3e, 0x53,
	0xca, 0xd8, 0x66, 0x49, 0x39, 0x9e, 0x11, 0xda, 0xa6, 0x28, 0xd9, 0xfe, 0xb9, 0x87, 0xf8, 0x0f,
	0x61, 0x29, 0x11, 0xda, 0x47, 0xa9, 0xa6, 0xfa, 0x4b, 0x54, 0xd3, 0x62, 0x62, 0xd9, 0xa4, 0x4f,
	0x42, 0xdb, 0x1f, 0x9c, 0xf0, 0x24, 0x0b, 0xe8, 0x18, 0x45, 0x0e, 0x81, 0x50, 0xa8, 0xcb, 0x06,
	0x4e, 0x76, 0xfa, 0x3a, 0x2c, 0xcb, 0xcc, 0x19, 0x4d, 0x29, 0xb3, 0x3d, 0x73, 0x18, 0x09, 0xdd,
	0x3f, 0x53, 0x61, 0x7d, 0x7b, 0x0f, 0xcf, 0x5e, 0x11, 0x73, 0x76, 0xb5, 0xc2, 0xec, 0x3e, 0x21,
	0x43, 0xec, 0x03, 0x75, 0x56, 0x9b, 0x31, 0x6e, 0xb1, 0x07, 0xf2, 0x4a, 0xc4, 0x5e, 0xd2, 0xfa,
	0xab, 0x2c, 0xa9, 0xfb, 0x43, 0x07, 0xe6, 0x77, 0xa3, 0x78, 0x57, 0xde, 0xe7, 0x93, 0x20, 0xe8,
	0xbc, 0x34, 0x55, 0x7c, 0xc9, 0x4d, 0x7f, 0xa5, 0x1d, 0x5e, 0x2c, 0xda, 0xe1, 0x5f, 0x86, 0xd7,
	0x28, 0x52, 0x90, 0x44, 0x71, 0x94, 0xa0, 0x30, 0xfa, 0x23, 0x61, 0x74, 0xa3, 0x30, 0x3b, 0x56,
	0x6a, 0xec, 0x65, 0x24, 0x74, 0x24, 0xc3, 0xa3, 0x84, 0x70, 0x94, 0xa5, 0xdf, 0x20, 0xb4, 0x5b,
	0xb9, 0xc2, 0xfd, 0x2c, 0x34, 0xc8, 0xf1, 0xa5, 0x69, 0xbd, 0x03, 0x8d, 0xe3, 0x28, 0xee, 0x1d,
	0x07, 0x61, 0xa6, 0x84, 0x7b, 0x29, 0xf7, 0x48, 0x77, 0x69, 0x41, 0x34, 0x81, 0xfb, 0x83, 0x3a,
	0xcc, 0x3f, 0x08, 0x4f, 0xa2, 0xa0, 0x4f, 0x37, 0x00, 0x63, 0x3e, 0x8e, 0x54, 0x96, 0x1e, 0xfe,
	0xc6, 0xa5, 0xa0, 0x8c, 0x95, 0x38, 0x93, 0x21, 0x7c, 0x55, 0x44, 0x73, 0x9f, 0xe4, 0x99, 0xb4,
	0x42, 0x74, 0x0c, 0x04, 0x9d, 0xfe, 0xc4, 0x4c, 0x3a, 0x96, 0xa5, 0x3c, 0xcd, 0x71, 0xd6, 0x48,
	0x73, 0xa4, 0xfb, 0x22, 0x91, 0x7b, 0x40, 0xfc, 0xb5, 0xe0, 0xa9, 0x22, 0x1d, 0x52, 0x12, 0x2e,
	0x22, 0x3c, 0xe4, 0x38, 0xcc, 0xcb, 0x43, 0x8a, 0x09, 0xa2, 0x73, 0x21, 0x3e, 0x10, 0x34, 0x42,
	0xf9, 0x9a, 0x10, 0x3a, 0x62, 0xc5, 0xbc, 0xe5, 0x86, 0xe0, 0xf9, 0x02, 0x8c, 0x1a, 0x7a, 0xc0,
	0xb5, 0x22, 0x15, 0x73, 0x00, 0x91, 0x29, 0x5c, 0xc4, 0x8d, 0xa3, 0x8d, 0x48, 0x2a, 0x52, 0x47,
	0x1b, 0x64, 0x14, 0x7f, 0x34, 0x3a, 0xf4, 0xfb, 0xcf, 0x28, 0x2d, 0x9d, 0x72, 0x88, 0x1a, 0x9e,
	0x0d, 0x52, 0x36, 0x41, 0xbe, 0x9b, 0x74, 0xe3, 0x58, 0xf7, 0x4c, 0x88, 0x6d, 0x42, 0x93, 0x8e,
	0x73, 0x72, 0x3f, 0x97, 0x68, 0x3f, 0xdb, 0xe6, 0x79, 0x8f, 0x76, 0xd4, 0x24, 0x32, 0x6f, 0x25,
	0x96, 0xed, 0x5b, 0x09, 0xa1, 0x34, 0xe5, 0x65, 0x4e, 0x9b, 0x7a, 0xcb, 0x01, 0xb4, 0xa6, 0x72,
	0xc1, 0x04, 0xc1, 0x0a, 0x11, 0x58, 0x18, 0x4a, 0x2d, 0x1e, 0x42, 0x62, 0x3f, 0x18, 0x74, 0x98,
	0x90, 0x5a, 0x55, 0x76, 0x33, 0x60, 0x77, 0x06, 0x03, 0xc9, 0x4d, 0xfa, 0xb0, 0x9a, 0xf3, 0x81,
	0x63, 0xf1, 0x41, 0xc5, 0x7e, 0xd4, 0xaa, 0xf7, 0xe3, 0xa5, 0xa3, 0x76, 0x77, 0xa0, 0xb9, 0x6f,
	0x24, 0x53, 0x13, 0x5b, 0xaa, 0x34, 0x6a, 0xc9, 0xca, 0x06, 0x62, 0x0c, 0xa7, 0x66, 0x0e, 0xc7,
	0xfd, 0x05, 0x60, 0x7b, 0x41, 0x9a, 0xe9, 0xd1, 0xe7, 0xd9, 0xdb, 0x2a, 0xa2, 0x90, 0x27, 0x40,
	0x35, 0x25, 0x46, 0x89, 0x49, 0x77, 0x44, 0xe6, 0x54, 0x71, 0xda, 0x1b, 0xb0, 0x10, 0x08, 0xa8,
	0x28, 0x85, 0x8a, 0x52, 0xd7, 0xbb, 0x4f, 0x61, 0x55, 0x82, 0xa6, 0x05, 0xb7, 0xe7, 0xed, 0x9c,
	0xb7, 0x5b, 0xb5, 0xf2, 0x6e, 0xb9, 0xdf, 0x77, 0x60, 0x5e, 0x2e, 0x0e, 0xd2, 0x97, 0x12, 0xd1,
	0x1b, 0x9e, 0x85, 0x55, 0xa7, 0x20, 0x97, 0x25, 0x70, 0xa6, 0x4a, 0x02, 0x19, 0xd4, 0x63, 0x3f,
	0x3b, 0xa6, 0xa3, 0x57, 0xc3, 0xa3, 0xdf, 0xac, 0x2d, 0xc2, 0x01, 0x42, 0xd2, 0x29, 0x14, 0x50,
	0x95, 0x85, 0x2f, 0x0c, 0x4a, 0x09, 0x47, 0x17, 0x9a, 0xf2, 0x2d, 0x04, 0xae, 0xaf, 0x51, 0x64,
	0x26, 0x58, 0x0e, 0xe7, 0x2b, 0x2e, 0x9b, 0x28, 0xae, 0xb8, 0x24, 0xf5, 0x74, 0xbd, 0xdb, 0x85,
	0xce, 0x36, 0x1f, 0xf1, 0x8c, 0xdf, 0x19, 0x8d, 0x8a, 0xed, 0xbf, 0x06, 0x97, 0x2b, 0xea, 0xa4,
	0xcb, 0x75, 0x0f, 0x56, 0xb6, 0xf9, 0xe1, 0x64, 0xb8, 0xc7, 0x4f, 0xf2, 0xbb, 0x4e, 0x06, 0xf5,
	0xf4, 0x38, 0x3a, 0x95, 0xdc, 0x41, 0xbf, 0xd9, 0x1b, 0x00, 0x23, 0xa4, 0xe9, 0xa5, 0x31, 0xef,
	0xab, 0xe4, 0x5b, 0x42, 0x0e, 0x62, 0xde, 0x77, 0xdf, 0x03, 0x66, 0xb6, 0x23, 0xa7, 0x80, 0x5a,
	0x6c, 0x72, 0xd8, 0x4b, 0xa7, 0x69, 0xc6, 0xc7, 0x2a, 0xab, 0xd8, 0x84, 0xdc, 0xeb, 0xd0, 0xda,
	0xf7, 0xa7, 0x1e, 0xff, 0x86, 0x7c, 0x0b, 0x80, 0xa7, 0x7e, 0x7f, 0x8a, 0xa2, 0xa2, 0x4f, 0xfd,
	0x54, 0xed, 0xfe, 0x57, 0x0d, 0xe6, 0x04, 0x25, 0xb6, 0x3a, 0xe0, 0x69, 0x16, 0x84, 0xe2, 0x9e,
	0x4f, 0xb6, 0x6a, 0x40, 0x25, 0xde, 0xa8, 0x55, 0xf0, 0x86, 0xf4, 0xb5, 0x55, 0x22, 0xa3, 0x64,
	0x02, 0x0b, 0x43, 0x8e, 0xcd, 0xf3, 0x27, 0xc4, 0xb1, 0x33, 0x07, 0x0a, 0x61, 0xa0, 0x5c, 0x57,
	0x8a, 0xf1, 0x29, 0xb6, 0x97, 0xec, 0x60, 0x42, 0x95, 0x1a, 0x79, 0x5e, 0x70, 0x4d, 0x49, 0x23,
	0x97, 0x34, 0xef, 0xc2, 0x2b, 0x68, 0x5e, 0xe1, 0x80, 0xbf, 0x4c, 0xf3, 0xc2, 0x2b, 0x68, 0x5e,
	0x97, 0x41, 0xfb, 0x1e, 0xe7, 0x1e, 0x47, 0x9b, 0xae, 0xd8, 0xe9, 0x3b, 0x0e, 0xb4, 0xa5, 0x3b,
	0xa2, 0xeb, 0xd8, 0x5b, 0x96, 0xef, 0x52, 0x99, 0x6e, 0x78, 0x0d, 0x16, 0xc9, 0xa3, 0xd0, 0xf1,
	0x2e, 0x19, 0x9c, 0xb3, 0x40, 0x9c, 0x87, 0xba, 0x94, 0x18, 0x07, 0x23, 0xb9, 0x29, 0x26, 0xa4,
	0x42, 0x66, 0x78, 0xf2, 0xa7, 0x2d, 0x71, 0x3c, 0x5d, 0x76, 0xff, 0xda, 0x81, 0x15, 0x63, 0xc0,
	0x92, 0x0b, 0x3f, 0x04, 0x95, 0x5f, 0x21, 0xc2, 0x62, 0x42, 0x98, 0x2e, 0xd9, 0xae, 0x55, 0xfe,
	0x99, 0x45, 0x4c, 0x9b, 0xe9, 0x4f, 0x69, 0x80, 0xe9, 0x64, 0x2c, 0xb5, 0x92, 0x09, 0x21, 0x23,
	0x9d, 0x72, 0xfe, 0x4c, 0x93, 0xcc, 0x08, 0xc5, 0x65, 0x62, 0x74, 0x7d, 0x8e, 0x9e, 0x90, 0x26,
	0x12, 0x19, 0x63, 0x36, 0xe8, 0xfe, 0x93, 0x03, 0xab, 0xc2, 0xa5, 0x95, 0x07, 0x06, 0x9d, 0x0b,
	0x3e, 0x27, 0x7c, 0x78, 0x21, 0x91, 0xbb, 0x17, 0x3c, 0x59, 0x66, 0x9f, 0x79, 0x45, 0x37, 0x5c,
	0xa7, 0x4d, 0x9c, 0xb1, 0x17, 0x33, 0x55, 0x7b, 0xf1, 0x92, 0x95, 0xae, 0x0a, 0x03, 0xcd, 0x56,
	0x86, 0x81, 0xee, 0xce, 0xc3, 0x6c, 0xda, 0x8f, 0x62, 0xee, 0xae, 0xc3, 0x9a, 0x3d, 0x39, 0xa9,
	0x82, 0xbe, 0xeb, 0x40, 0xe7, 0x9e, 0x08, 0x8a, 0x06, 0xe1, 0x70, 0x37, 0x48, 0xb3, 0x28, 0xd1,
	0x8f, 0x5f, 0xae, 0x00, 0xa4, 0x99, 0x9f, 0x64, 0x22, 0xad, 0x4d, 0x06, 0x69, 0x72, 0x04, 0xc7,
	0xc8, 0xc3, 0x81, 0xa8, 0x15, 0x7b, 0xa3, 0xcb, 0xb8, 0x31, 0x64, 0x36, 0x7a, 0xd1, 0xd1, 0x51,
	0xca, 0xb5, 0xd3, 0x6d, 0x62, 0x78, 0x6e, 0x47, 0x89, 0xc7, 0x93, 0x2a, 0x3f, 0x21, 0x55, 0x2b,
	0xbc, 0xd9, 0x02, 0xea, 0xfe, 0xa5, 0x03, 0xcb, 0xf9, 0x20, 0x77, 0x10, 0xb4, 0xb5, 0x83, 0xb4,
	0x67, 0xb9, 0x76, 0x50, 0xe1, 0xa3, 0x00, 0x0d, 0x9c, 0x1c, 0x9b, 0x81, 0x90, 0xc4, 0xca, 0x52,
	0x34, 0x51, 0x29, 0x84, 0x26, 0x24, 0xf2, 0x03, 0x32, 0xfc, 0x5a, 0xe4, 0x0f, 0xca, 0x12, 0x65,
	0x25, 0x8e, 0x33, 0xfa, 0x6a, 0x4e, 0xb8, 0xf3, 0xb2, 0xa8, 0xec, 0xd3, 0x3c, 0xa1, 0xf8, 0xd3,
	0xfd, 0x7d, 0x07, 0x2e, 0x57, 0x2c, 0xae, 0x94, 0x8c, 0x6d, 0x58, 0x39, 0xd2, 0x95, 0x6a, 0x01,
	0x84, 0x78, 0xac, 0xab, 0x28, 0xbe, 0x3d, 0x69, 0xaf, 0xfc, 0x01, 0x3a, 0xf7, 0x14, 0xf5, 0x12,
	0x4b, 0x6a, 0xa5, 0xd6, 0x94, 0x2b, 0x36, 0xff, 0x60, 0x06, 0x96, 0xc4, 0xed, 0x8e, 0x78, 0x86,
	0xca, 0x13, 0xf6, 0x11, 0xcc, 0xcb, 0x67, 0xc4, 0xec, 0xa2, 0xec, 0xd6, 0x7e, 0xb8, 0xdc, 0x5d,
	0x2f, 0xc2, 0x92, 0x77, 0x56, 0x7f, 0xeb, 0x87, 0xff, 0xf2, 0x87, 0xb5, 0x45, 0xd6, 0xbc, 0x75,
	0xf2, 0xee, 0xad, 0x21, 0x0f, 0x53, 0x6c, 0xe3, 0xd7, 0x00, 0xf2, 0x07, 0xb6, 0xac, 0xa3, 0xdd,
	0x94, 0xc2, 0xcb, 0xe1, 0xee, 0xe5, 0x8a, 0x1a, 0xd9, 0xee, 0x65, 0x6a, 0x77, 0xd5, 0x5d, 0xc2,
	0x76, 0x83, 0x30, 0xc8, 0xc4, 0x6b, 0xdb, 0x0f, 0x9c, 0x0d, 0x36, 0x80, 0x96, 0xf9, 0x7e, 0x96,
	0xa9, 0x03, 0x7f, 0xc5, 0xeb, 0xdd, 0xee, 0x6b, 0x95, 0x75, 0x2a, 0xda, 0x41, 0x7d, 0x5c, 0x74,
	0xdb, 0xd8, 0xc7, 0x84, 0x28, 0xf2, 0x5e, 0x46, 0xb0, 0x64, 0x3f, 0x93, 0x65, 0xaf, 0x1b, 0x62,
	0x5d, 0x7a, 0xa4, 0xdb, 0x7d, 0xe3, 0x8c, 0x5a, 0xd9, 0xd7, 0x1b, 0xd4, 0xd7, 0x25, 0x97, 0x61,
	0x5f, 0x7d, 0xa2, 0x51, 0x8f, 0x74, 0x3f, 0x70, 0x36, 0x36, 0xbf, 0x75, 0x05, 0x1a, 0x3a, 0x44,
	0xc7, 0xbe, 0x0e, 0x8b, 0xd6, 0xf5, 0x1b, 0x53, 0xd3, 0xa8, 0xba, 0xad, 0xeb, 0xbe, 0x5e, 0x5d,
	0x29, 0x3b, 0xbe, 0x42, 0x1d, 0x77, 0xd8, 0x3a, 0x76, 0x2c, 0xef, 0xaf, 0x6e, 0xd1, 0xa5, 0xa3,
	0xc8, 0x79, 0x7c, 0x26, 0xe6, 0x99, 0x5f, 0x99, 0x59, 0xf3, 0x2c, 0x5d, 0xb1, 0x59, 0xf3, 0x2c,
	0xdf, 0xb3, 0xb9, 0xaf, 0x53, 0x77, 0xeb, 0x6c, 0xcd, 0xec, 0x4e, 0x87, 0xce, 0x38, 0x65, 0xa9,
	0x9a, 0xaf, 0x68, 0xd9, 0x1b, 0x9a, 0xb1, 0xaa, 0x5e, 0xd7, 0x6a, 0x16, 0x29, 0x3f, 0xb1, 0x75,
	0x3b, 0xd4, 0x15, 0x63, 0xb4, 0x7d, 0xe6, 0x23, 0x5a, 0xf6, 0x55, 0x68, 0xe8, 0x27, 0x63, 0xec,
	0x92, 0xf1, 0x4e, 0xcf, 0x7c, 0xc7, 0xd6, 0xed, 0x94, 0x2b, 0xaa, 0x18, 0xc3, 0x6c, 0x19, 0x19,
	0x63, 0x0f, 0x2e, 0x4a, 0xa7, 0xfa, 0x90, 0xff, 0x38, 0x33, 0xa9, 0x78, 0xfb, 0x7b, 0xdb, 0x61,
	0x1f, 0xc2, 0x82, 0x7a, 0x89, 0xc7, 0xd6, 0xab, 0x5f, 0x14, 0x76, 0x2f, 0x95, 0x70, 0xa9, 0x3d,
	0xee, 0x00, 0xe4, 0xaf, 0xc8, 0xb4, 0x9c, 0x95, 0xde, 0xb6, 0xe9, 0x45, 0xac, 0x78, 0x72, 0x36,
	0xa4, 0x37, 0x73, 0xf6, 0x23, 0x35, 0xf6, 0x66, 0x4e, 0x5f, 0xf9, 0x7c, 0xed, 0x25, 0x0d, 0xba,
	0xeb, 0xb4, 0x76, 0x6d, 0x46, 0x82, 0x1b, 0xf2, 0x53, 0x95, 0xaf, 0xbd, 0x0d, 0x4d, 0xe3, 0x65,
	0x1a, 0x53, 0x2d, 0x94, 0x5f, 0xb5, 0x75, 0xbb, 0x55, 0x55, 0x72, 0xb8, 0x5f, 0x80, 0x45, 0xeb,
	0x89, 0x99, 0x96, 0x8c, 0xaa, 0x07, 0x6c, 0x5a, 0x32, 0xaa, 0x5f, 0xa5, 0x7d, 0x05, 0x9a, 0xc6,
	0x83, 0x30, 0x66, 0xe4, 0xa9, 0x15, 0x9e, 0x82, 0xe9, 0x11, 0x55, 0xbd, 0x1f, 0x5b, 0xa3, 0xf9,
	0x2e, 0xb9, 0x0d, 0x9c, 0x2f, 0x25, 0x2d, 0x23, 0x93, 0x7c, 0x1d, 0x96, 0xec, 0x27, 0x62, 0x5a,
	0xaa, 0x2a, 0x1f, 0x9b, 0x69, 0xa9, 0x3a, 0xe3, 0x5d, 0x99, 0x64, 0xc8, 0x8d, 0x55, 0xdd, 0xc9,
	0xad, 0x8f, 0xe5, 0xe5, 0xd5, 0x0b, 0xf6, 0x25, 0x54, 0x1d, 0x32, 0x8b, 0x9c, 0xe5, 0x0f, 0xe3,
	0xec, 0x5c, 0x73, 0xcd, 0xed, 0xa5, 0x84, 0x73, 0x77, 0x85, 0x1a, 0x6f, 0xb2, 0x7c, 0x06, 0xc2,
	0x1e, 0x50, 0x36, 0xb9, 0x61, 0x0f, 0xcc, 0x84, 0x73, 0xc3, 0x1e, 0x58, 0x49, 0xe7, 0x45, 0x7b,
	0x90, 0x05, 0xd8, 0x46, 0x08, 0xcb, 0x85, 0x44, 0x0d, 0x2d, 0x2c, 0xd5, 0x99, 0x6d, 0xdd, 0x2b,
	0x2f, 0xcf, 0xef, 0xb0, 0xd5, 0x8c, 0x52, 0x2f, 0xb7, 0x54, 0x22, 0xe2, 0xaf, 0x43, 0xcb, 0x7c,
	0xda, 0xa3, 0x2d, 0x44, 0xc5, 0x83, 0x24, 0x6d, 0x21, 0xaa, 0xde, 0x02, 0xa9, 0xcd, 0x65, 0x2d,
	0xb3, 0x1b, 0xdc, 0x5c, 0xfb, 0x25, 0x44, 0xae, 0x32, 0xab, 0x9e, 0x78, 0xe4, 0x2a, 0xb3, 0xf2,
	0xf9, 0x84, 0xda, 0x5c, 0xb6, 0x6a, 0xcd, 0x45, 0x44, 0x26, 0xd9, 0x57, 0x60, 0xd9, 0xc8, 0x82,
	0x3a, 0x98, 0x86, 0x7d, 0xcd, 0xa8, 0xe5, 0x1c, 0xd9, 0x6e, 0x95, 0xe7, 0xe9, 0x5e, 0xa2, 0xf6,
	0x57, 0x5c, 0x6b, 0x12, 0xc8, 0xa4, 0x5b, 0xd0, 0x34, 0x33, 0xac, 0x5e, 0xd2, 0xee, 0x25, 0xa3,
	0xca, 0x4c, 0x17, 0xbd, 0xed, 0xb0, 0x3f, 0x76, 0xa0, 0x65, 0xe5, 0x2b, 0x59, 0xf1, 0xf7, 0x42,
	0x3b, 0x1d, 0xb3, 0xce, 0x6c, 0xc8, 0xf5, 0x68, 0x90, 0x7b, 0x1b, 0x5f, 0xb0, 0x16, 0xe1, 0x63,
	0xeb, 0x04, 0x73, 0xb3, 0xf8, 0x42, 0xfc, 0x45, 0x91, 0xc0, 0xcc, 0x23, 0x7e, 0x71, 0xdb, 0x61,
	0x1f, 0x88, 0xff, 0x40, 0x50, 0x11, 0x0b, 0x66, 0x28, 0xd2, 0xe2, 0x92, 0x99, 0x7f, 0x00, 0x70,
	0xc3, 0xb9, 0xed, 0xb0, 0xaf, 0x89, 0x87, 0xe0, 0xf2, 0x5b, 0x5a, 0xf9, 0x57, 0xfd, 0xde, 0xbd,
	0x46, 0xb3, 0xb9, 0xe2, 0x5e, 0xb6, 0x66, 0x53, 0xb4, 0x24, 0x77, 0xc4, 0xe8, 0xe4, 0xfb, 0xfe,
	0x5c, 0x25, 0x96, 0xde, 0xfc, 0x9f, 0x3d, 0xc8, 0xb1, 0x18, 0xa4, 0x24, 0xb7, 0xd8, 0xe3, 0x15,
	0x9b, 0x71, 0x37, 0x68, 0xac, 0xd7, 0xdc, 0x37, 0xcf, 0x1c, 0xeb, 0x2d, 0x3a, 0x91, 0xe2, 0x88,
	0xf7, 0x01, 0xf2, 0x80, 0x1c, 0x2b, 0xc4, 0x9f, 0xb4, 0x55, 0x28, 0xc7, 0xec, 0x6c, 0x1e, 0x54,
	0x61, 0x2a, 0x6c, 0xf1, 0xab, 0x42, 0x54, 0x25, 0x7d, 0xaa, 0x47, 0x5f, 0x0e, 0x9d, 0x75, 0xbb,
	0x55, 0x55, 0x55, 0x82, 0xaa, 0xda, 0x67, 0x4f, 0x60, 0x71, 0x2f, 0x8a, 0x9e, 0x4d, 0x62, 0x1d,
	0x90, 0xb6, 0xe3, 0x37, 0xbb, 0x7e, 0x7a, 0xdc, 0x2d, 0xcc, 0xc2, 0xbd, 0x4a, 0x4d, 0x75, 0x59,
	0xc7, 0x68, 0xea, 0xd6, 0xc7, 0x79, 0xc0, 0xef, 0x05, 0xf3, 0x61, 0x45, 0x7b, 0x00, 0x7a, 0xe0,
	0x5d, 0xbb, 0x19, 0x33, 0xee, 0x56, 0xea, 0xc2, 0xf2, 0xc9, 0xd4, 0x68, 0x6f, 0xa5, 0xaa, 0xcd,
	0xdb, 0x0e, 0xdb, 0x87, 0xd6, 0x36, 0xef, 0x47, 0x03, 0x2e, 0x23, 0x2e, 0xab, 0xf9, 0xc0, 0x75,
	0xa8, 0xa6, 0xbb, 0x68, 0x81, 0xb6, 0x4e, 0x8c, 0xfd, 0x69, 0xc2, 0xbf, 0x71, 0xeb, 0x63, 0x19,
	0xcb, 0x79, 0xa1, 0x74, 0xa2, 0x8a, 0x3f, 0x59, 0x3a, 0xb1, 0x10, 0xb0, 0xb2, 0x74, 0x62, 0x29,
	0x60, 0x65, 0x2d, 0xb5, 0x8a, 0x7f, 0xb1, 0x11, 0xac, 0x94, 0x62, 0x5c, 0xda, 0x8f, 0x38, 0x2b,
	0x32, 0xd6, 0xbd, 0x7a, 0x36, 0x81, 0xdd, 0xdb, 0x86, 0xdd, 0xdb, 0x01, 0x2c, 0x6e, 0x73, 0xb1,
	0x58, 0xe2, 0xd6, 0xbb, 0xf0, 0xe0, 0xcc, 0xbc, 0x21, 0x2f, 0x2a, 0x45, 0xaa, 0xb3, 0x8d, 0x1e,
	0x5d, 0x39, 0xb3, 0xaf, 0x42, 0xf3, 0x3e, 0xcf, 0xd4, 0x35, 0xb7, 0xf6, 0xc6, 0x0a, 0xf7, 0xde,
	0xdd, 0x8a, 0x5b, 0x72, 0x9b, 0x67, 0xa8, 0xb5, 0x5b, 0x7c, 0x30, 0xe4, 0x42, 0x3d, 0xf5, 0x82,
	0xc1, 0x0b, 0xf6, 0x2b, 0xd4, 0xb8, 0xce, 0x9a, 0x59, 0x37, 0x6e, 0x47, 0xcd, 0xc6, 0x97, 0x0b,
	0x78, 0x55, 0xcb, 0x61, 0x34, 0xe0, 0x86, 0xf9, 0x0f, 0xa1, 0x69, 0xa4, 0x74, 0x69, 0x01, 0x2a,
	0xa7, 0xa7, 0x69, 0x01, 0xaa, 0xc8, 0x00, 0x73, 0x6f, 0x50, 0x3f, 0x2e, 0xbb, 0x9a, 0xf7, 0x23,
	0xb2, 0xbe, 0xf2, 0x9e, 0x6e, 0x7d, 0xec, 0x8f, 0xb3, 0x17, 0xec, 0x29, 0x3d, 0x3e, 0x33, 0xaf,
	0xf2, 0x73, 0x6f, 0xb0, 0x78, 0xeb, 0xaf, 0x17, 0xcb, 0xa8, 0xb2, 0x3d, 0x44, 0xd1, 0x15, 0x79,
	0x09, 0x9f, 0x01, 0x38, 0xc8, 0xa2, 0x78, 0xdb, 0xe7, 0xe3, 0x28, 0xcc, 0x75, 0x6d, 0x7e, 0x5d,
	0x9d, 0xeb, 0x2f, 0xe3, 0xce, 0x9a, 0x3d, 0x35, 0xfc, 0x71, 0x2b, 0x13, 0x42, 0x31, 0xd7, 0x99,
	0x37, 0xda, 0x7a, 0x41, 0x2a, 0x6e, 0xb5, 0x6f, 0x3b, 0xe8, 0x5d, 0xe7, 0x11, 0x55, 0xed, 0x5d,
	0x97, 0x82, 0xb5, 0x5a, 0xed, 0x55, 0x84, 0x5f, 0xf7, 0xa1, 0x91, 0x87, 0xe8, 0x2e, 0xe5, 0x69,
	0x79, 0x56, 0x40, 0x4f, 0x5b, 0xc5, 0x52, 0xe0, 0xcc, 0x6d, 0xd3, 0x52, 0x01, 0x5b, 0xc0, 0xa5,
	0xa2, 0x68, 0x58, 0x00, 0xab, 0x62, 0x80, 0xda, 0xc4, 0xd3, 0x05, 0xac, 0x9a, 0x49, 0x45, 0xf0,
	0x4a, 0x4b, 0x73, 0x65, 0xec, 0xc7, 0x3a, 0x67, 0x23, 0xb7, 0x8a, 0xcb, 0x5f, 0x54, 0xcd, 0x63,
	0x58, 0x29, 0x05, 0x2e, 0xb4, 0x48, 0x9f, 0x15, 0x2f, 0xd2, 0x22, 0x7d, 0x66, 0xcc, 0xc3, 0xbd,
	0x48, 0x5d, 0x2e, 0xbb, 0x80, 0x5d, 0xa6, 0xa7, 0x41, 0xd6, 0x3f, 0xfe, 0xc0, 0xd9, 0x38, 0x9c,
	0xa3, 0xff, 0x4c, 0xfb, 0xd4, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0x2e, 0xa2, 0xa7, 0xf7, 0x65,
	0x4d, 0x00, 0x00,
}
